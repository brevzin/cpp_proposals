<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-06-24" />
  <title>constexpr INVOKE</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f6f8fa; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #006e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center"><code class="sourceCode cpp"><span class="kw">constexpr</span></code> <em><code class="sourceCode cpp">INVOKE</code></em></h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>D1065R2</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2019-06-24</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      LWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Tomasz Kamiński<br>&lt;<a href="mailto:tomaszkam@gmail.com" class="email">tomaszkam@gmail.com</a>&gt;<br>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history"><span class="toc-section-number">1</span> Revision History<span></span></a></li>
<li><a href="#motivation"><span class="toc-section-number">2</span> Motivation<span></span></a></li>
<li><a href="#history"><span class="toc-section-number">3</span> History<span></span></a></li>
<li><a href="#proposal"><span class="toc-section-number">4</span> Proposal<span></span></a><ul>
<li><a href="#wording"><span class="toc-section-number">4.1</span> Wording<span></span></a></li>
</ul></li>
<li><a href="#acknowledgements"><span class="toc-section-number">5</span> Acknowledgements<span></span></a></li>
<li><a href="#references"><span class="toc-section-number">6</span> References<span></span></a></li>
</ul>
</div>
<h1 id="revision-history" style="border-bottom:1px solid #cccccc"><span class="header-section-number">1</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p>Since <span class="citation" data-cites="P1065R0">[<a href="#ref-P1065R0" role="doc-biblioref">P1065R0</a>]</span>, just wording changes to correctly describe what it means for things <code class="sourceCode cpp">bind</code> to be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> and also including <code class="sourceCode cpp">bind_front<span class="op">()</span></code>.</p>
<h1 id="motivation" style="border-bottom:1px solid #cccccc"><span class="header-section-number">2</span> Motivation<a href="#motivation" class="self-link"></a></h1>
<p>Currently, one of the most important utility functions in the standard libary, <code class="sourceCode cpp">std<span class="op">::</span>invoke<span class="op">()</span></code>, is not <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. Even though <code class="sourceCode cpp">std<span class="op">::</span>apply<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>visit<span class="op">()</span></code>, both of which rely on <code><em>INVOKE</em></code>, are both <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. The standard library thus finds itself in an odd state where <code class="sourceCode cpp">std<span class="op">::</span>invoke<span class="op">()</span></code> is and is not <code class="sourceCode cpp"><span class="kw">constexpr</span></code>.</p>
<p>The reason that <code class="sourceCode cpp">std<span class="op">::</span>invoke<span class="op">()</span></code> is not <code class="sourceCode cpp"><span class="kw">constexpr</span></code> has some interesting history associated with it. But at this point, it is simply history, and there is no further blocker to making this change. This proposal resolves <span class="citation" data-cites="LWG2894">[<a href="#ref-LWG2894" role="doc-biblioref">LWG2894</a>]</span> but also goes one step further and addresses various other <code><em>INVOKE</em></code>-related machinery.</p>
<h1 id="history" style="border-bottom:1px solid #cccccc"><span class="header-section-number">3</span> History<a href="#history" class="self-link"></a></h1>
<p>Our tale beings in April, 2015 with <span class="citation" data-cites="llvm23141">[<a href="#ref-llvm23141" role="doc-biblioref">llvm23141</a>]</span>, which presented this code which broke in clang in C++14 (but had compiled in C++11 mode) due to the introduction of a <code class="sourceCode cpp"><span class="kw">constexpr</span> __invoke</code> (which ended up breaking range-v3):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">struct</span> Fun</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>T <span class="op">&amp;&amp;</span> t, U <span class="op">&amp;&amp;</span> u<span class="op">)</span> <span class="kw">const</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same<span class="op">&lt;</span>U, <span class="dt">int</span> <span class="op">&amp;&gt;::</span>value, <span class="st">&quot;&quot;</span><span class="op">)</span>;</span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="op">}</span>;</span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    std<span class="op">::</span>bind<span class="op">(</span>Fun<span class="op">{}</span>, std<span class="op">::</span>placeholders<span class="op">::</span>_1, <span class="dv">42</span><span class="op">)(</span><span class="st">&quot;hello&quot;</span><span class="op">)</span>;</span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="op">}</span></span></code></pre></div>
<p>as well as the similar <span class="citation" data-cites="llvm23135">[<a href="#ref-llvm23135" role="doc-biblioref">llvm23135</a>]</span>, which was about this program:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">int</span> f<span class="op">(</span>T x<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="cf">return</span> x<span class="op">.</span>get<span class="op">()</span>;</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">constexpr</span> <span class="dt">int</span> g<span class="op">(</span>T x<span class="op">)</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="cf">return</span> x<span class="op">.</span>get<span class="op">()</span>;</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a>  <span class="co">// O.K. The body of `f&#39; is not required.</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="kw">decltype</span><span class="op">(</span>f<span class="op">(</span><span class="dv">0</span><span class="op">))</span> a;</span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a>  <span class="co">// Seems to instantiate the body of `g&#39;</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>  <span class="co">// and results in an error.</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span class="kw">decltype</span><span class="op">(</span>g<span class="op">(</span><span class="dv">0</span><span class="op">))</span> b;</span>
<span id="cb2-21"><a href="#cb2-21"></a></span>
<span id="cb2-22"><a href="#cb2-22"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="op">}</span></span></code></pre></div>
<p>In both cases the fundamental issue was eager instantiation of the body, which doesn’t actually seem necessary to determine the results here. In neither example is the return type deduced.</p>
<p>These are incarnations of <span class="citation" data-cites="CWG1581">[<a href="#ref-CWG1581" role="doc-biblioref">CWG1581</a>]</span>, which dealt with the question of when, exactly, are <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions defined. In the broken programs above, the <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions (the non-<code class="sourceCode cpp"><span class="kw">const</span></code> call operator of the binder object being returned in the first case and <code class="sourceCode cpp">g<span class="op">()</span></code> in the second) were eagerly instantiated, triggering hard compile errors, in cases where the program ultimately would not have required their instantiation.</p>
<p>Thankfully, this difficult problem has been resolved by the adoption of <span class="citation" data-cites="P0859R0">[<a href="#ref-P0859R0" role="doc-biblioref">P0859R0</a>]</span> in Albuquerque, 2017. As a result, both of the above programs are valid.</p>
<p>This issue was the blocker for having a <code class="sourceCode cpp"><span class="kw">constexpr</span> std<span class="op">::</span>invoke<span class="op">()</span></code> due to this eager instantiation issue - which no longer exists.</p>
<h1 id="proposal" style="border-bottom:1px solid #cccccc"><span class="header-section-number">4</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>This proposal adds <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to the following <code><em>INVOKE</em></code>-related machinery: <code class="sourceCode cpp">invoke<span class="op">()</span></code>, <code class="sourceCode cpp">reference_wrapper<span class="op">&lt;</span>T<span class="op">&gt;</span></code>, <code class="sourceCode cpp">not_fn<span class="op">()</span></code>, <code class="sourceCode cpp">bind<span class="op">()</span></code>, <code class="sourceCode cpp">bind_front<span class="op">()</span></code>, and <code class="sourceCode cpp">mem_fn<span class="op">()</span></code>. The remaining non-<code class="sourceCode cpp"><span class="kw">constexpr</span></code> elements of the library that are <code><em>INVOKE</em></code>-adjacent are <code class="sourceCode cpp">function<span class="op">&lt;</span>Sig<span class="op">&gt;</span></code>, <code class="sourceCode cpp">packaged_task<span class="op">&lt;</span>Sig<span class="op">&gt;</span></code>, <code class="sourceCode cpp">async<span class="op">()</span></code>, <code class="sourceCode cpp">thread</code>, and <code class="sourceCode cpp">call_once<span class="op">()</span></code>.</p>
<p>This proposal resolves <span class="citation" data-cites="LWG2894">[<a href="#ref-LWG2894" role="doc-biblioref">LWG2894</a>]</span>, <span class="citation" data-cites="LWG2957">[<a href="#ref-LWG2957" role="doc-biblioref">LWG2957</a>]</span>, and <span class="citation" data-cites="LWG3023">[<a href="#ref-LWG3023" role="doc-biblioref">LWG3023</a>]</span>. The last is addressed by guaranteeing that call wrappers that are produced by <code class="sourceCode cpp">not_fn<span class="op">()</span></code> and <code class="sourceCode cpp">bind<span class="op">()</span></code> have the same type if their state entities have the same type (note that this guarantee does not imply any restriction on implementors). Thus the types of <code class="sourceCode cpp">f1</code>, <code class="sourceCode cpp">f2</code>, <code class="sourceCode cpp">f3</code>, and <code class="sourceCode cpp">f4</code> in the following example are now guaranteed to be the same:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">auto</span> func <span class="op">=</span> <span class="op">[](</span>std<span class="op">::</span>string<span class="op">)</span> <span class="op">{}</span>;</span>
<span id="cb3-2"><a href="#cb3-2"></a>std<span class="op">::</span>string s<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">)</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">auto</span> f1 <span class="op">=</span> std<span class="op">::</span>bind<span class="op">(</span>func, s<span class="op">)</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">auto</span> f2 <span class="op">=</span> std<span class="op">::</span>bind<span class="op">(</span>std<span class="op">::</span>as_const<span class="op">(</span>func<span class="op">)</span>, std<span class="op">::</span>as_const<span class="op">(</span>s<span class="op">))</span>;</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">auto</span> f3 <span class="op">=</span> std<span class="op">::</span>bind<span class="op">(</span>func, std<span class="op">::</span>string<span class="op">(</span><span class="st">&quot;bar&quot;</span><span class="op">))</span>;</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">auto</span> f4 <span class="op">=</span> std<span class="op">::</span>bind<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>func<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>s<span class="op">))</span>;</span></code></pre></div>
<p>The wording uses the phrase “shall be constexpr functions” in a couple places. We don’t seem to have a way to say that in Library, see also <span class="citation" data-cites="LWG2833">[<a href="#ref-LWG2833" role="doc-biblioref">LWG2833</a>]</span> and <span class="citation" data-cites="LWG2289">[<a href="#ref-LWG2289" role="doc-biblioref">LWG2289</a>]</span>.</p>
<h2 id="wording"><span class="header-section-number">4.1</span> Wording<a href="#wording" class="self-link"></a></h2>
<style>
code span.co { color: #898887; }
</style>
<p>Add <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to several places in the synopsis in 20.14.1 [functional.syn]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb4"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb4-1"><a href="#cb4-1"></a>namespace std {</span>
<span id="cb4-2"><a href="#cb4-2"></a>  // [func.invoke], invoke</span>
<span id="cb4-3"><a href="#cb4-3"></a>  template&lt;class F, class... Args&gt;</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="st">-   invoke_result_t&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="va">+   <span class="diffins">constexpr</span> invoke_result_t&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>      noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;);</span>
<span id="cb4-7"><a href="#cb4-7"></a>      </span>
<span id="cb4-8"><a href="#cb4-8"></a>  // [refwrap], reference_wrapper</span>
<span id="cb4-9"><a href="#cb4-9"></a>  template&lt;class T&gt; class reference_wrapper;</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp;) noexcept;</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp;) noexcept;</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;T&gt; ref(T&amp;) noexcept;</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;const T&gt; cref(const T&amp;) noexcept;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>  template&lt;class T&gt; void ref(const T&amp;&amp;) = delete;</span>
<span id="cb4-16"><a href="#cb4-16"></a>  template&lt;class T&gt; void cref(const T&amp;&amp;) = delete;</span>
<span id="cb4-17"><a href="#cb4-17"></a></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;) noexcept;</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;);</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;) noexcept;</span></span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;) noexcept;   </span></span>
<span id="cb4-22"><a href="#cb4-22"></a>  </span>
<span id="cb4-23"><a href="#cb4-23"></a>  // [arithmetic.operations], arithmetic operations</span>
<span id="cb4-24"><a href="#cb4-24"></a>  // ...</span>
<span id="cb4-25"><a href="#cb4-25"></a>  </span>
<span id="cb4-26"><a href="#cb4-26"></a>  // [comparisons], comparisons</span>
<span id="cb4-27"><a href="#cb4-27"></a>  // ...</span>
<span id="cb4-28"><a href="#cb4-28"></a></span>
<span id="cb4-29"><a href="#cb4-29"></a>  // [logical.operations], logical operations</span>
<span id="cb4-30"><a href="#cb4-30"></a>  // ...</span>
<span id="cb4-31"><a href="#cb4-31"></a></span>
<span id="cb4-32"><a href="#cb4-32"></a>  // [bitwise.operations], bitwise operations</span>
<span id="cb4-33"><a href="#cb4-33"></a>  // ...</span>
<span id="cb4-34"><a href="#cb4-34"></a></span>
<span id="cb4-35"><a href="#cb4-35"></a>  // [func.identity], identity</span>
<span id="cb4-36"><a href="#cb4-36"></a>  // ...</span>
<span id="cb4-37"><a href="#cb4-37"></a></span>
<span id="cb4-38"><a href="#cb4-38"></a>  // [func.not.fn], function template not_fn</span>
<span id="cb4-39"><a href="#cb4-39"></a><span class="st">- template&lt;class F&gt; <em>unspecified</em> not_fn(F&amp;&amp; f);</span></span>
<span id="cb4-40"><a href="#cb4-40"></a><span class="va">+ template&lt;class F&gt; <span class="diffins">constexpr</span> <em>unspecified</em> not_fn(F&amp;&amp; f);</span></span>
<span id="cb4-41"><a href="#cb4-41"></a></span>
<span id="cb4-42"><a href="#cb4-42"></a>  // [func.bind.front], function template bind_front</span>
<span id="cb4-43"><a href="#cb4-43"></a><span class="st">- template&lt;class F, class... Args&gt; <em>unspecified</em> bind_front(F&amp;&amp;, Args&amp;&amp;...);</span></span>
<span id="cb4-44"><a href="#cb4-44"></a><span class="va">+ template&lt;class F, class... Args&gt; <span class="diffins">constexpr</span> <em>unspecified</em> bind_front(F&amp;&amp;, Args&amp;&amp;...);</span></span>
<span id="cb4-45"><a href="#cb4-45"></a> </span>
<span id="cb4-46"><a href="#cb4-46"></a>  // [func.bind], bind</span>
<span id="cb4-47"><a href="#cb4-47"></a>  template&lt;class T&gt; struct is_bind_expression;</span>
<span id="cb4-48"><a href="#cb4-48"></a>  template&lt;class T&gt; struct is_placeholder;</span>
<span id="cb4-49"><a href="#cb4-49"></a></span>
<span id="cb4-50"><a href="#cb4-50"></a><span class="st">- template&lt;class F, class... BoundArgs&gt;</span></span>
<span id="cb4-51"><a href="#cb4-51"></a><span class="st">-   <em>unspecified</em> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);</span></span>
<span id="cb4-52"><a href="#cb4-52"></a><span class="st">- template&lt;class R, class F, class... BoundArgs&gt;</span></span>
<span id="cb4-53"><a href="#cb4-53"></a><span class="st">-   <em>unspecified</em> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);</span></span>
<span id="cb4-54"><a href="#cb4-54"></a><span class="va">+ template&lt;class F, class... BoundArgs&gt;</span></span>
<span id="cb4-55"><a href="#cb4-55"></a><span class="va">+   <span class="diffins">constexpr</span> <em>unspecified</em> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);</span></span>
<span id="cb4-56"><a href="#cb4-56"></a><span class="va">+ template&lt;class R, class F, class... BoundArgs&gt;</span></span>
<span id="cb4-57"><a href="#cb4-57"></a><span class="va">+   <span class="diffins">constexpr</span> <em>unspecified</em> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);</span></span>
<span id="cb4-58"><a href="#cb4-58"></a></span>
<span id="cb4-59"><a href="#cb4-59"></a>  namespace placeholders {</span>
<span id="cb4-60"><a href="#cb4-60"></a>    // M is the implementation-defined number of placeholders</span>
<span id="cb4-61"><a href="#cb4-61"></a>    <em>see below</em> _1;</span>
<span id="cb4-62"><a href="#cb4-62"></a>    <em>see below</em> _2;</span>
<span id="cb4-63"><a href="#cb4-63"></a>               .</span>
<span id="cb4-64"><a href="#cb4-64"></a>               .</span>
<span id="cb4-65"><a href="#cb4-65"></a>               .</span>
<span id="cb4-66"><a href="#cb4-66"></a>    <em>see below</em> _M;</span>
<span id="cb4-67"><a href="#cb4-67"></a>  }</span>
<span id="cb4-68"><a href="#cb4-68"></a></span>
<span id="cb4-69"><a href="#cb4-69"></a>  // [func.memfn], member function adaptors</span>
<span id="cb4-70"><a href="#cb4-70"></a>  template&lt;class R, class T&gt;</span>
<span id="cb4-71"><a href="#cb4-71"></a><span class="st">-   <em>unspecified</em> mem_fn(R T::*) noexcept;</span></span>
<span id="cb4-72"><a href="#cb4-72"></a><span class="va">+   <span class="diffins">constexpr</span> <em>unspecified</em> mem_fn(R T::*) noexcept;</span></span>
<span id="cb4-73"><a href="#cb4-73"></a></span>
<span id="cb4-74"><a href="#cb4-74"></a>  // ...    </span>
<span id="cb4-75"><a href="#cb4-75"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>The definition of the <em>simple call wrapper</em> (used only for <code class="sourceCode cpp">mem_fn</code>) is changed to be a refinement of <em>perfect forwarding call wrapper</em>, instead of <em>argument forwarding call wrapper</em>. These make the invocation operator conditionally <code class="sourceCode cpp"><span class="kw">constexpr</span></code> and <code class="sourceCode cpp"><span class="kw">noexcept</span></code>. In addition we state explicitly the copy/move constructor/assignment of simple call wrapper is core constant expression. [ <em>Note</em>: The definition of simple call wrapper is still required to guarantee assignability. ]</p>
<p>The requirement of copy/move operation to be defined in terms of state entities is now extended to any argument forwarding call wrapper (as we define them for <code class="sourceCode cpp">not_fn</code> and <code class="sourceCode cpp">bind</code>).</p>
<p>Apply following changes to 20.14.3 [func.require]:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> Every call wrapper ([func.def]) <span class="addu">meets the</span> <span class="rm" style="color: #bf0303"><del>is</del></span> <em>Cpp17MoveConstructible</em> <span class="addu">and <em>Cpp17Destructible</em> requirements</span>. <span class="rm" style="color: #bf0303"><del>A</del></span> <span class="addu">An</span> <em>argument forwarding call wrapper</em> is a call wrapper that can be called with an arbitrary argument list and delivers the arguments to the wrapped callable object as references. This forwarding step delivers rvalue arguments as rvalue references and lvalue arguments as lvalue references. <span class="rm" style="color: #bf0303"><del>A <em>simple call wrapper</em> is an argument forwarding call wrapper that is <em>Cpp17CopyConstructible</em> and <em>Cpp17CopyAssignable</em> and whose copy constructor, move constructor, copy assignment operator, and move assignment operator do not throw exceptions.</del></span> [ <em>Note</em>: In a typical implementation, argument forwarding call wrappers have an overloaded function call operator of the form</p>
<div>
<div class="sourceCode" id="cb5"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb5-1"><a href="#cb5-1"></a> template&lt;class... UnBoundArgs&gt;</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="st">-   R operator()(UnBoundArgs&amp;&amp;... unbound_args) <em>cv-qual</em>;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="va">+   <span class="diffins">constexpr</span> R operator()(UnBoundArgs&amp;&amp;... unbound_args) <em>cv-qual</em>;</span></span></code></pre></div>
</div>
<p>—<em>end note</em>]</p>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> A <em>perfect forwarding call wrapper</em> is an argument forwarding call wrapper that forwards its state entities to the underlying call expression. This forwarding step delivers a state entity of type <code class="sourceCode cpp">T</code> as <em>cv</em> <code class="sourceCode cpp">T<span class="op">&amp;</span></code> when the call is performed on an lvalue of the call wrapper type and as <em>cv</em> <code class="sourceCode cpp">T<span class="op">&amp;&amp;</span></code> otherwise, where <em>cv</em> represents the cv-qualifiers of the call wrapper and where <em>cv</em> shall be neither <code class="sourceCode cpp"><span class="kw">volatile</span></code> nor <code class="sourceCode cpp"><span class="kw">const</span> <span class="kw">volatile</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> A <em>call pattern</em> defines the semantics of invoking a perfect forwarding call wrapper. A postfix call performed on a perfect forwarding call wrapper is expression-equivalent ([defns.expression-equivalent]) to an expression <code class="sourceCode cpp">e</code> determined from its call pattern cp by replacing all occurrences of the arguments of the call wrapper and its state entities with references as described in the corresponding forwarding steps.</p>
<p><span class="marginalizedparent"><a class="marginalized">a</a></span> <span class="addu">A <em>simple call wrapper</em> is a perfect forwarding call wrapper that meets the <em>Cpp17CopyConstructible</em> and <em>Cpp17CopyAssignable</em> and whose copy constructor, move constructor, and assignment operator are constexpr functions which do not throw exceptions.</span></p>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> The copy/move constructor of <span class="rm" style="color: #bf0303"><del>a perfect</del></span> <span class="addu">an argument</span> forwarding call wrapper has the same apparent semantics as if memberwise copy/move of its state entities were performed ([class.copy.ctor]). [ <em>Note</em>: This implies that each of the copy/move constructors has the same <em>exception-specification</em> as the corresponding implicit definition and is declared as <code class="sourceCode cpp"><span class="kw">constexpr</span></code> if the corresponding implicit definition would be considered to be constexpr. —<em>end note</em> ]</p>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <span class="rm" style="color: #bf0303"><del>Perfect</del></span> <span class="addu">Argument</span> forwarding call wrappers returned by a given standard library function template have the same type if the types of their corresponding state entities are the same.</p>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to <code class="sourceCode cpp">std<span class="op">::</span>invoke<span class="op">()</span></code> in 20.14.4 [func.invoke]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb6"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb6-1"><a href="#cb6-1"></a>  template&lt;class F, class... Args&gt;</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="st">-   invoke_result_t&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="va">+   <span class="diffins">constexpr</span> invoke_result_t&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>      noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;);</span></code></pre></div>
</div>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to <code class="sourceCode cpp">std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>T<span class="op">&gt;</span></code> in 20.14.5 [refwrap]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb7"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb7-1"><a href="#cb7-1"></a>namespace std {</span>
<span id="cb7-2"><a href="#cb7-2"></a>  template&lt;class T&gt; class reference_wrapper {</span>
<span id="cb7-3"><a href="#cb7-3"></a>  public:</span>
<span id="cb7-4"><a href="#cb7-4"></a>    // types</span>
<span id="cb7-5"><a href="#cb7-5"></a>    using type = T;</span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a>    // construct/copy/destroy</span>
<span id="cb7-8"><a href="#cb7-8"></a>    template&lt;class U&gt;</span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="st">-     reference_wrapper(U&amp;&amp;) noexcept(<em>see below</em>);</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="st">-   reference_wrapper(const reference_wrapper&amp; x) noexcept;</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="va">+     <span class="diffins">constexpr</span> reference_wrapper(U&amp;&amp;) noexcept(<em>see below</em>);</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="va">+   <span class="diffins">constexpr</span> reference_wrapper(const reference_wrapper&amp; x) noexcept;</span></span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a>    // assignment</span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="st">-   reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;</span></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="va">+   <span class="diffins">constexpr</span> reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;</span></span>
<span id="cb7-17"><a href="#cb7-17"></a></span>
<span id="cb7-18"><a href="#cb7-18"></a>    // access</span>
<span id="cb7-19"><a href="#cb7-19"></a><span class="st">-   operator T&amp; () const noexcept;</span></span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="st">-   T&amp; get() const noexcept;</span></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="va">+   <span class="diffins">constexpr</span> operator T&amp; () const noexcept;</span></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="va">+   <span class="diffins">constexpr</span> T&amp; get() const noexcept;</span></span>
<span id="cb7-23"><a href="#cb7-23"></a></span>
<span id="cb7-24"><a href="#cb7-24"></a>    // invocation</span>
<span id="cb7-25"><a href="#cb7-25"></a>    template&lt;class... ArgTypes&gt;</span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="st">-     invoke_result_t&lt;T&amp;, ArgTypes...&gt; operator()(ArgTypes&amp;&amp;...) const;</span></span>
<span id="cb7-27"><a href="#cb7-27"></a><span class="va">+     <span class="diffins">constexpr</span> invoke_result_t&lt;T&amp;, ArgTypes...&gt; operator()(ArgTypes&amp;&amp;...) const;</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>  };</span>
<span id="cb7-29"><a href="#cb7-29"></a>  template&lt;class T&gt;</span>
<span id="cb7-30"><a href="#cb7-30"></a>    reference_wrapper(T&amp;) -&gt; reference_wrapper&lt;T&gt;;</span>
<span id="cb7-31"><a href="#cb7-31"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>And its corresponding subsections, 20.14.5.1 [refwrap.const]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb8"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb8-1"><a href="#cb8-1"></a>  template&lt;class U&gt;</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="st">-   reference_wrapper(U&amp;&amp; u) noexcept(<em>see below</em>);</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="va">+   <span class="diffins">constexpr</span> reference_wrapper(U&amp;&amp; u) noexcept(<em>see below</em>);</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a>  [...]</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="st">- reference_wrapper(const reference_wrapper&amp; x) noexcept;</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="va">+ <span class="diffins">constexpr</span> reference_wrapper(const reference_wrapper&amp; x) noexcept;</span></span></code></pre></div>
</div>
</blockquote>
<p>20.14.5.2 [refwrap.assign]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb9"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb9-1"><a href="#cb9-1"></a><span class="st">- reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="va">+ <span class="diffins">constexpr</span> reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;</span></span></code></pre></div>
</div>
</blockquote>
<p>20.14.5.3 [refwrap.access]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb10"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb10-1"><a href="#cb10-1"></a><span class="st">- operator T&amp; () const noexcept;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="va">+ <span class="diffins">constexpr</span> operator T&amp; () const noexcept;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a>  [...]</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="st">- T&amp; get() const noexcept;</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="va">+ <span class="diffins">constexpr</span> T&amp; get() const noexcept;</span></span></code></pre></div>
</div>
</blockquote>
<p>20.14.5.4 [refwrap.invoke]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb11"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb11-1"><a href="#cb11-1"></a>  template&lt;class... ArgTypes&gt;</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="st">-   invoke_result_t&lt;T&amp;, ArgTypes...&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="va">+   <span class="diffins">constexpr</span> invoke_result_t&lt;T&amp;, ArgTypes...&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>      operator()(ArgTypes&amp;&amp;... args) const;</span></code></pre></div>
</div>
</blockquote>
<p>and its helper functions, 20.14.5.5 [refwrap.helpers]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb12"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb12-1"><a href="#cb12-1"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp; t) noexcept;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;T&gt; ref(T&amp; t) noexcept;</span></span></code></pre></div>
</div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">reference_wrapper<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span></code>.</p>
<div>
<div class="sourceCode" id="cb13"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb13-1"><a href="#cb13-1"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt; t) noexcept;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt; t) noexcept;</span></span></code></pre></div>
</div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">ref<span class="op">(</span>t<span class="op">.</span>get<span class="op">())</span></code>.</p>
<div>
<div class="sourceCode" id="cb14"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb14-1"><a href="#cb14-1"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp; t) noexcept;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;const T&gt; cref(const T&amp; t) noexcept;</span></span></code></pre></div>
</div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">reference_wrapper <span class="op">&lt;</span><span class="kw">const</span> T<span class="op">&gt;(</span>t<span class="op">)</span></code>.</p>
<div>
<div class="sourceCode" id="cb15"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb15-1"><a href="#cb15-1"></a><span class="st">- template&lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt; t) noexcept;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="va">+ template&lt;class T&gt; <span class="diffins">constexpr</span> reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt; t) noexcept;</span></span></code></pre></div>
</div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp">cref<span class="op">(</span>t<span class="op">.</span>get<span class="op">())</span></code>.</p>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to <code class="sourceCode cpp">std<span class="op">::</span>not_fn<span class="op">()</span></code> in 20.14.12 [func.not.fn]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb16"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb16-1"><a href="#cb16-1"></a><span class="st">- template&lt;class F&gt; <em>unspecified</em> not_fn(F&amp;&amp; f);</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="va">+ template&lt;class F&gt; <span class="diffins">constexpr</span> <em>unspecified</em> not_fn(F&amp;&amp; f);</span></span></code></pre></div>
</div>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to <code class="sourceCode cpp">std<span class="op">::</span>bind_front<span class="op">()</span></code> in 20.14.13 [func.bind.front]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb17"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb17-1"><a href="#cb17-1"></a>  template&lt;class F, class... Args&gt;</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="st">-   <em>unspecified</em> bind_front(F&amp;&amp; f, Args&amp;&amp;... args);</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="va">+   <span class="diffins">constexpr</span> <em>unspecified</em> bind_front(F&amp;&amp; f, Args&amp;&amp;... args);</span></span></code></pre></div>
</div>
</blockquote>
<p>Apply the following changes to <code class="sourceCode cpp">std<span class="op">::</span>bind<span class="op">()</span></code> in 20.14.14.3 [func.bind.bind], merging <code class="sourceCode cpp">bind</code> and <code class="sourceCode cpp">bind<span class="op">&lt;</span>R<span class="op">&gt;</span></code>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> In the text that follows:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(1.0)</a></span><span class="addu"><code class="sourceCode cpp">g</code> is a value of the result of a <code class="sourceCode cpp">bind</code> invocation,</span></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> <code class="sourceCode cpp">FD</code> is the type <code class="sourceCode cpp">decay_t<span class="op">&lt;</span>F<span class="op">&gt;</span></code>,</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> <code class="sourceCode cpp">fd</code> is an lvalue <span class="rm" style="color: #bf0303"><del>of type <span><code class="sourceCode cpp">FD</code></span> constructed from <span><code class="sourceCode cpp">std<span class="op">::</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)</span></code></span>,</del></span> <span class="addu">that is a target object of <code class="sourceCode cpp">g</code> ([func.def]) of type <code class="sourceCode cpp">FD</code> direct-non-list-initialized with <code class="sourceCode cpp">std<span class="op">::</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)</span></code>,</span></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.3)</a></span> <code>T<sub>i</sub></code> is the <code class="sourceCode cpp">i</code>th type in the template parameter pack <code class="sourceCode cpp">BoundArgs</code>,</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.4)</a></span> <code>TD<sub>i</sub></code> is the type <code>decay_t&lt;T<sub>i</sub>&gt;</code>,</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.5)</a></span> <code>t<sub>i</sub></code> is the <code class="sourceCode cpp">i</code>th argument in the function parameter pack <code class="sourceCode cpp">bound_args</code>,</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.6)</a></span> <code>td<sub>i</sub></code> is <span class="rm" style="color: #bf0303"><del>an lvalue of type <code>TD<sub>i</sub></code> constructed from <code>std::forward&lt;T<sub>i</sub>&gt;(t<sub>i</sub>)</code>,</del></span> <span class="addu">a bound argument entity of <code class="sourceCode cpp">g</code> ([func.def]) of type <code>TD<sub>i</sub></code> direct-non-list-initialized with <code>std::forward&lt;T<sub>i</sub>&gt;(t<sub>i</sub>)</code>,</span></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.7)</a></span> <code>U<sub>j</sub></code> is the <code class="sourceCode cpp">j</code>th deduced type of the <code class="sourceCode cpp">UnBoundArgs<span class="op">&amp;&amp;...</span></code> parameter of the argument forwarding call wrapper, and</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.8)</a></span> <code>u<sub>j</sub></code> is the <code class="sourceCode cpp">j</code>th argument associated with <code>U<sub>j</sub></code>.</li>
</ul>
<div>
<div class="sourceCode" id="cb18"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb18-1"><a href="#cb18-1"></a>  template&lt;class F, class... BoundArgs&gt;</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="st">-   <em>unspecified</em> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="va">+   <span class="diffins">constexpr</span> <em>unspecified</em> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="va">+ template&lt;class R, class F, class... BoundArgs&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="va">+   <span class="diffins">constexpr</span> <em>unspecified</em> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);</span></span></code></pre></div>
</div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <span class="rm" style="color: #bf0303"><del><em>Requires</em></del></span> <span class="addu"><em>Mandates</em></span>: <code class="sourceCode cpp">is_constructible_v<span class="op">&lt;</span>FD, F<span class="op">&gt;</span></code> <span class="rm" style="color: #bf0303"><del>shall be</del></span> <span class="addu">is</span> <code class="sourceCode cpp"><span class="kw">true</span></code>. For each <code>T<sub>i</sub></code> in <code class="sourceCode cpp">BoundArgs</code>, <code>is_constructible_v&lt;TD<sub>i</sub>, T<sub>i</sub>&gt;</code> <span class="rm" style="color: #bf0303"><del>shall be</del></span> <span class="addu">is</span> <code class="sourceCode cpp"><span class="kw">true</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">2a</a></span> <span class="addu"><em>Expects</em>: <code class="sourceCode cpp">FD</code> and each <code>TD<sub>i</sub></code> meet the <em>Cpp17MoveConstructible</em> and <em>Cpp17Destructible</em> requirements.</span> <code>INVOKE(fd, w<sub>1</sub>, w<sub>2</sub>, …, w<sub>N</sub>)</code> ([func.require]) <span class="rm" style="color: #bf0303"><del>shall be</del></span> <span class="addu">is</span> a valid expression for some values <code>w<sub>1</sub>, w<sub>2</sub>, …, w<sub>N</sub></code>, where <code class="sourceCode cpp">N</code> has the value <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>bound_args<span class="op">)</span></code>. <span class="rm" style="color: #bf0303"><del>The cv-qualifiers <em>cv</em> of the call wrapper <span><code class="sourceCode cpp">g</code></span>, as specified below, shall be neither <span><code class="sourceCode cpp"><span class="kw">volatile</span></code></span> nor <span><code class="sourceCode cpp"><span class="kw">const</span> <span class="kw">volatile</span></code></span>.</del></span></p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: An argument forwarding call wrapper <code class="sourceCode cpp">g</code> ([func.require]). <span class="addu">A program that attempts to invoke a volatile-qualified <code class="sourceCode cpp">g</code> is ill-formed. When <code class="sourceCode cpp">g</code> is not volatile-qualified,</span> <span class="rm" style="color: #bf0303"><del>The effect of</del></span> <span class="addu">invocation</span> <code>g(u<sub>1</sub>, u<sub>2</sub>, …, u<sub>M</sub>)</code> <span class="rm" style="color: #bf0303"><del>shall be</del></span> <span class="addu">is expression-equivalent ([defns.expression-equivalent]) to</span> <span class="rm" style="color: #bf0303"><del><code>INVOKE(fd, std::forward&lt;V<sub>1</sub>&gt;(v<sub>1</sub>), std::forward&lt;V<sub>2</sub>&gt;(v<sub>2</sub>), …, std::forward&lt;V<sub>N</sub>&gt;(v<sub>N</sub>))</code></del></span> <span class="addu"><code>INVOKE(static_cast&lt;V<sub>fd</sub>&gt;(v<sub>fd</sub>), static_cast&lt;V<sub>1</sub>&gt;(v<sub>1</sub>), static_cast&lt;V<sub>2</sub>&gt;(v<sub>2</sub>), …, static_cast&lt;V<sub>N</sub>&gt;(v<sub>N</sub>))</code> for the first overload, and <code>INVOKE&lt;R&gt;(static_cast&lt;V<sub>fd</sub>&gt;(v<sub>fd</sub>), static_cast&lt;V<sub>1</sub>&gt;(v<sub>1</sub>), static_cast&lt;V<sub>2</sub>&gt;(v<sub>2</sub>), …, static_cast&lt;V<sub>N</sub>&gt;(v<sub>N</sub>))</code> for the second overload,</span> where the values and types of <span class="addu">the target argument <code>v<sub>fd</sub></code> and of</span> the bound arguments <code>v<sub>1</sub>, v<sub>2</sub>, …, v<sub>N</sub></code> are determined as specified below. <span class="rm" style="color: #bf0303"><del>The copy constructor and move constructor of the argument forwarding call wrapper shall throw an exception if and only if the corresponding constructor of <span><code class="sourceCode cpp">FD</code></span> or of any of the types <code>TD<sub>i</sub></code> throws an exception.</del></span></p>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Throws</em>: <span class="rm" style="color: #bf0303"><del>Nothing unless the construction of <span><code class="sourceCode cpp">fd</code></span> or of one of the values <code>td<sub>i</sub></code> throws an exception.</del></span> <span class="addu">Any exception thrown by the initialization of the state entities of <code class="sourceCode cpp">g</code>.</span></p>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <span class="rm" style="color: #bf0303"><del><em>Remarks</em>: The return type shall satisfy the <em>Cpp17MoveConstructible</em> requirements. If all of <span><code class="sourceCode cpp">FD</code></span> and <code>TD<sub>i</sub></code> satisfy the <em>Cpp17CopyConstructible</em> requirements, then the return type shall satisfy the <em>Cpp17CopyConstructible</em> requirements. [<em>Note</em>: This implies that all of <code>FD</code> and <code>TD<sub>i</sub></code> are <em>Cpp17MoveConstructible</em>. —<em>end note</em>]</del></span></p>
<p><span class="marginalizedparent"><a class="marginalized">5a</a></span> <span class="addu">[<em>Note</em>: If all of <code class="sourceCode cpp">FD</code> and <code>TD<sub>i</sub></code> meet the requirements of <em>Cpp17CopyConstructible</em>, then the return type meets the requirements of <em>Cpp17CopyConstructible</em>. -<em>end note</em>]</span></p>
<div class="rm" style="color: #bf0303">

<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1"></a>template&lt;class R, class F, class... BoundArgs&gt;</span>
<span id="cb19-2"><a href="#cb19-2"></a>  <em>unspecified</em> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Requires</em>: <code class="sourceCode cpp">is_constructible_v<span class="op">&lt;</span>FD, F<span class="op">&gt;</span></code> shall be <code class="sourceCode cpp"><span class="kw">true</span></code>. For each <code>T<sub>i</sub></code> in <code class="sourceCode cpp">BoundArgs</code>, <code>is_constructible_v&lt;TD<sub>i</sub>, T<sub>i</sub>&gt;</code> shall be true. <code>INVOKE(fd, w<sub>1</sub>, w<sub>2</sub>, …, w<sub>N</sub>)</code> ([func.require]) shall be a valid expression for some values <code>w<sub>1</sub>, w<sub>2</sub>, …, w<sub>N</sub></code>, where <code class="sourceCode cpp">N</code> has the value <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>bound_args<span class="op">)</span></code>. The cv-qualifiers <em>cv</em> of the call wrapper <code class="sourceCode cpp">g</code>, as specified below, shall be neither <code class="sourceCode cpp"><span class="kw">volatile</span></code> nor <code class="sourceCode cpp"><span class="kw">const</span> <span class="kw">volatile</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: An argument forwarding call wrapper g ([func.require]). The effect of <code>g(u<sub>1</sub>, u<sub>2</sub>, …, u<sub>M</sub>)</code> shall be <code>INVOKE&lt;R&gt;(fd, std::forward&lt;V<sub>1</sub>&gt;(v<sub>1</sub>), std::forward&lt;V<sub>2</sub>&gt;(v<sub>2</sub>), …, std::forward&lt;V<sub>N</sub>&gt;(v<sub>N</sub>))</code> where the values and types of the bound arguments <code>v<sub>1</sub>, v<sub>2</sub>, …, v<sub>N</sub></code> are determined as specified below. The copy constructor and move constructor of the argument forwarding call wrapper shall throw an exception if and only if the corresponding constructor of <code class="sourceCode cpp">FD</code> or of any of the types <code>TD<sub>i</sub></code> throws an exception.</p>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Throws</em>: Nothing unless the construction of <code class="sourceCode cpp">fd</code> or of one of the values <code>td<sub>i</sub></code> throws an exception.</p>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Remarks</em>: The return type shall satisfy the <em>Cpp17MoveConstructible</em> requirements. If all of <code class="sourceCode cpp">FD</code> and <code>TD<sub>i</sub></code> satisfy the <em>Cpp17CopyConstructible</em> requirements, then the return type shall satisfy the <em>Cpp17CopyConstructible</em> requirements. [<em>Note</em>: This implies that all of <code>FD</code> and <code>TD<sub>i</sub></code> are <em>Cpp17MoveConstructible</em>. —<em>end note</em>]</p>
</div>
</blockquote>
<p>Define <code>v<sub>fd</sub></code> and add reference to the <em>cv</em>-qualifies in 20.14.14.3 [func.bind.bind]/10:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> The values of the <em>bound arguments</em> <code>v<sub>1</sub></code>, <code>v<sub>2</sub></code>, …, <code>v<sub>N</sub></code> and their corresponding types <code>V<sub>1</sub></code>, <code>V<sub>2</sub></code>, …, <code>V<sub>N</sub></code> depend on the types <code>TD<sub><i>i</i></sub></code> derived from the call to bind and the cv-qualifiers <em>cv</em> of the call wrapper <code class="sourceCode cpp">g</code> as follows:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(10.1)</a></span> if <code>TD<sub><i>i</i></sub></code> is <code class="sourceCode cpp">reference_wrapper<span class="op">&lt;</span>T<span class="op">&gt;</span></code>, […]</li>
<li><span class="marginalizedparent"><a class="marginalized">(10.2)</a></span> if the value of <code>is_bind_expression_v&lt;TD<sub><i>i</i></sub>&gt;</code> is <code class="sourceCode cpp"><span class="kw">true</span></code>, the argument is <code><span class="rm" style="color: #bf0303"><del>td<sub><i>i</i></sub></del></span> <span class="addu">static_cast&lt;TD<sub><i>i</i></sub> <i>cv</i> &amp;&gt;(td<sub><i>i</i></sub>)</span>(std::forward&lt;U<sub>j</sub>&gt;(u<sub>j</sub>)…)</code> and its type <code>V<sub><i>i</i></sub></code> is <code>invoke_result_t&lt;TD<sub><i>i</i></sub> <i>cv</i> &amp;, U<sub><i>j</i></sub>…&gt;&amp;&amp;</code>;</li>
<li><span class="marginalizedparent"><a class="marginalized">(10.3)</a></span> if the value <code class="sourceCode cpp">j</code> of […]</li>
<li><span class="marginalizedparent"><a class="marginalized">(10.4)</a></span> otherwise, […]</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <span class="addu">The value of the <i>target argument</i> <code>v<sub>fd</sub></code> is <code>fd</code> and its corresponding type <code>V<sub>fd</sub></code> is <code>FD <i>cv</i> &amp;</code>.</span></p>
</blockquote>
<p>Add constant requirement to the placeholders in 20.14.14.4 [func.bind.place]/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> All placeholder types <span class="addu">meet the</span> <span class="rm" style="color: #bf0303"><del>shall be</del></span> <em>Cpp17DefaultConstructible</em> and <em>Cpp17CopyConstructible</em><span class="addu">requirements</span>, and their default constructors and copy/move constructors <span class="addu">are constexpr functions which do</span> <span class="rm" style="color: #bf0303"><del>shall</del></span> not throw exceptions. It is implementation-defined whether placeholder types <span class="addu">meet the</span> <span class="rm" style="color: #bf0303"><del>are</del></span> <em>Cpp17CopyAssignable</em> <span class="addu">requirements, but if so, their</span> <span class="rm" style="color: #bf0303"><del>. <em>Cpp17CopyAssignable</em> placeholders’</del></span> copy assignment operators <span class="addu">are constexpr functions which do</span> <span class="rm" style="color: #bf0303"><del>shall</del></span> not throw exceptions.</p>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to <code class="sourceCode cpp">std<span class="op">::</span>mem_fn<span class="op">()</span></code> in 20.14.15 [func.memfn]</p>
<blockquote>
<div>
<div class="sourceCode" id="cb20"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb20-1"><a href="#cb20-1"></a><span class="st">- template&lt;class R, class T&gt; <em>unspecified</em> mem_fn(R T::* pm) noexcept;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="va">+ template&lt;class R, class T&gt; <span class="diffins">constexpr</span> <em>unspecified</em> mem_fn(R T::* pm) noexcept;</span></span></code></pre></div>
</div>
</blockquote>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: A simple call wrapper <code class="sourceCode cpp">fn</code> <span class="rm" style="color: #bf0303"><del>such that the expression <code>fn(t, a<sub>2</sub>, …, a<sub>N</sub>)</code> is equivalent to <code>INVOKE(pm, t, a<sub>2</sub>, …, a<sub>N</sub>)</code> ([func.require]).</del></span> <span class="addu">with call pattern <code class="sourceCode cpp">invoke<span class="op">(</span>pmd, call_args<span class="op">...)</span></code>, where <code class="sourceCode cpp">pmd</code> is the target object of <code class="sourceCode cpp">fn</code> of type <code class="sourceCode cpp">R T<span class="op">::*</span></code> direct-non-list-initialized with <code class="sourceCode cpp">pm</code>, and <code class="sourceCode cpp">call_args</code> is an argument pack used in a function call expression ([expr.call]) of <code class="sourceCode cpp">pm</code>.</span></p>
</blockquote>
<h1 id="acknowledgements" style="border-bottom:1px solid #cccccc"><span class="header-section-number">5</span> Acknowledgements<a href="#acknowledgements" class="self-link"></a></h1>
<p>Thanks to Casey Carter and Agustín Bergé for going over the history of issues surrounding <code class="sourceCode cpp"><span class="kw">constexpr</span> invoke</code> and suggesting that this proposal be written. Thanks to Daniel Krügler, Tim Song and, Casey Carter for help on the wording.</p>
<h1 id="references" style="border-bottom:1px solid #cccccc"><span class="header-section-number">6</span> References<a href="#references" class="self-link"></a></h1>

<div id="refs" role="doc-bibliography">
<div id="ref-CWG1581">
<p>[CWG1581] Richard Smith. 2012. When are constexpr member functions defined? <br />
<a href="https://wg21.link/cwg1581">https://wg21.link/cwg1581</a></p>
</div>
<div id="ref-llvm23135">
<p>[llvm23135] Gonzalo BG. 2015. [C++11/14] Body of constexpr function templates instantiated too eagerly in unevaluated operands. <br />
<a href="https://bugs.llvm.org/show_bug.cgi?id=23135">https://bugs.llvm.org/show_bug.cgi?id=23135</a></p>
</div>
<div id="ref-llvm23141">
<p>[llvm23141] Eric Niebler. 2015. <code class="sourceCode cpp">std<span class="op">::</span>bind</code> const-qualifying bound arguments captured by value when compiled as C++14. <br />
<a href="https://bugs.llvm.org/show_bug.cgi?id=23141">https://bugs.llvm.org/show_bug.cgi?id=23141</a></p>
</div>
<div id="ref-LWG2289">
<p>[LWG2289] Daniel Krügler. constexpr guarantees of defaulted functions still insufficient. <br />
<a href="https://wg21.link/lwg2289">https://wg21.link/lwg2289</a></p>
</div>
<div id="ref-LWG2833">
<p>[LWG2833] Richard Smith. Library needs to specify what it means when it declares a function constexpr. <br />
<a href="https://wg21.link/lwg2833">https://wg21.link/lwg2833</a></p>
</div>
<div id="ref-LWG2894">
<p>[LWG2894] Great Britain. The function template std::apply() is required to be constexpr, but std::invoke() isn’t. <br />
<a href="https://wg21.link/lwg2894">https://wg21.link/lwg2894</a></p>
</div>
<div id="ref-LWG2957">
<p>[LWG2957] Tim Song. bind’s specification doesn’t apply the cv-qualification of the call wrapper to the callable object. <br />
<a href="https://wg21.link/lwg2957">https://wg21.link/lwg2957</a></p>
</div>
<div id="ref-LWG3023">
<p>[LWG3023] Detlef Vollmann. Clarify unspecified call wrappers. <br />
<a href="https://wg21.link/lwg3023">https://wg21.link/lwg3023</a></p>
</div>
<div id="ref-P0859R0">
<p>[P0859R0] Richard Smith. 2017. Core Issue 1581: When are constexpr member functions defined? <br />
<a href="https://wg21.link/p0859r0">https://wg21.link/p0859r0</a></p>
</div>
<div id="ref-P1065R0">
<p>[P1065R0] Barry Revzin. 2018. constexpr INVOKE. <br />
<a href="https://wg21.link/p1065r0">https://wg21.link/p1065r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
