<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-12-27" />
  <title>String Interpolation with Template Strings</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.csl-block{margin-left: 1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
text-align: justify;
}
@media screen and (max-width: 30em) {
body {
margin: 1.5em;
}
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
td > div > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #C9FBC9;
--diff-strongins: #acf2bd;
--diff-del: #FFC8EB;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.addu td pre { background-color: inherit; }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
div.std blockquote { color: #000000; background-color: #F1F1F1;
border: 1px solid #D1D1D1;
padding-left: 0.5em; padding-right: 0.5em; }
div.std.ins blockquote {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.ins > div.example {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.std div.sourceCode { background-color: inherit; margin-left: 1em; }
div.rm li {
text-decoration: line-through;
color: #bf0303;
}
div.std blockquote del, div.rm {
text-decoration: line-through;
color: #bf0303;
background-color: var(--diff-del);
border: none;
}
code del { border: 1px solid #ECB3C7; }
span.orange {
background-color: #ffa500;
}
span.yellow {
background-color: #ffff00;
}</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">String Interpolation with
Template Strings</h1>
<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P3951R0 <a href="https://wg21.link/P3951">[Latest]</a> <a href="https://wg21.link/P3951/status">[Status]</a></td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2025-12-27</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>
</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction<span></span></a>
<ul>
<li><a href="#prior-work" id="toc-prior-work"><span class="toc-section-number">1.1</span> Prior Work<span></span></a></li>
<li><a href="#prior-art-in-python" id="toc-prior-art-in-python"><span class="toc-section-number">1.2</span> Prior Art in
Python<span></span></a></li>
</ul></li>
<li><a href="#design" id="toc-design"><span class="toc-section-number">2</span> Design<span></span></a>
<ul>
<li><a href="#parsing" id="toc-parsing"><span class="toc-section-number">2.1</span> Parsing<span></span></a></li>
<li><a href="#parsing-nested-expressions" id="toc-parsing-nested-expressions"><span class="toc-section-number">2.2</span> Parsing Nested
Expressions<span></span></a></li>
<li><a href="#data-members" id="toc-data-members"><span class="toc-section-number">2.3</span> Data Members<span></span></a></li>
<li><a href="#interpolation-information" id="toc-interpolation-information"><span class="toc-section-number">2.4</span> Interpolation
Information<span></span></a></li>
<li><a href="#the-templatestring-concept" id="toc-the-templatestring-concept"><span class="toc-section-number">2.5</span> The
<code class="sourceCode cpp">TemplateString</code>
Concept<span></span></a></li>
<li><a href="#implementation-experience" id="toc-implementation-experience"><span class="toc-section-number">2.6</span> Implementation
Experience<span></span></a></li>
</ul></li>
<li><a href="#bibliography" id="toc-bibliography"><span class="toc-section-number">3</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">1</span>
Introduction<a href="#introduction" class="self-link"></a></h1>
<p>The
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
approach to formatting offers many significant benefits over the prior
<code class="sourceCode cpp"><span class="op">&lt;</span>iostream<span class="op">&gt;</span></code>s
approach that need not be revisited here. However, <code class="sourceCode cpp"><span class="op">&lt;</span>iostream<span class="op">&gt;</span></code>
does still have one significant advantage: ordering. It is easy to see
at a glance with a long
<code class="sourceCode cpp">std<span class="op">::</span>cout</code>
statement which pieces are to be formatted in which order. With
<code class="sourceCode cpp">std<span class="op">::</span>format</code>,
as the amount of replacement fields increases, it becomes increasingly
difficult to ensure that they are all correctly ordered.</p>
<p>The solution to this problem is string interpolation: the ability to
put the expression to be formatted inside of the format string. This
lets us preserve all of the advantages of
<code class="sourceCode cpp">std<span class="op">::</span>format</code>,
while also regaining ordering. String interpolation is a wildly popular
language feature due to the ease with which it allows users to express
complex ideas. It’s not surprising that a huge number of modern
languages support this to some degree or another. A non-exhaustive list
includes: C#, D, Elixir, F#, Groovy, Kotlin, JavaScript, Perl, PHP,
Python, Ruby, Rust, Scala, Swift, and VB.</p>
<h2 data-number="1.1" id="prior-work"><span class="header-section-number">1.1</span> Prior Work<a href="#prior-work" class="self-link"></a></h2>
<p>There have been two prior WG21 papers pursuing string interpolation
as a C++ language feature: <span class="title"><span class="citation" data-cites="P1819R0"><a href="https://wg21.link/p1819r0" role="doc-biblioref">[P1819R0] (Interpolated Literals)</a></span></span>
and <span class="title"><span class="citation" data-cites="P3412R3"><a href="https://wg21.link/p3412r3" role="doc-biblioref">[P3412R3] (String
Interpolation)</a></span></span>. The two proposals are quite different,
so let’s consider an example to work through the details:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> get_result<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">42</span>; <span class="op">}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> interp <span class="op">=</span> f<span class="st">&quot;The result is {get_result()}</span><span class="sc">\n</span><span class="st">&quot;</span>;     <span class="co">// #1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>interp<span class="op">)</span>;                                  <span class="co">// #2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>f<span class="st">&quot;The result is {get_result()}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>;       <span class="co">// #3</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>In P1819, the <code class="sourceCode cpp">interp</code> is an object
that is roughly equivalent to:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> interp <span class="op">=</span> <span class="op">[&amp;](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f<span class="op">(</span><span class="st">&quot;The result is &quot;</span>, get_result<span class="op">()</span>, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>So line
<code class="sourceCode cpp"><span class="pp">#1</span></code> does
nothing. The call to
<code class="sourceCode cpp">get_result<span class="op">()</span></code>
does not happen yet. Instead, the library would provide new overloads of
<code class="sourceCode cpp">std<span class="op">::</span>print</code>
and friends so that in line
<code class="sourceCode cpp"><span class="pp">#2</span></code>, the
library would invoke <code class="sourceCode cpp">interp</code> with the
appropriate function to do the printing. The call to
<code class="sourceCode cpp">get_result<span class="op">()</span></code>
happens at that point. Line
<code class="sourceCode cpp"><span class="pp">#3</span></code> does the
same things as lines
<code class="sourceCode cpp"><span class="pp">#1</span></code> and
<code class="sourceCode cpp"><span class="pp">#2</span></code>, just
together.</p>
<p>In P3412, the behavior is very different.
<code class="sourceCode cpp">interp</code> is already a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>,
which is evaluated as:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> interp <span class="op">=</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;The result is {}</span><span class="sc">\n</span><span class="st">&quot;</span>, get_result<span class="op">())</span>;</span></code></pre></div>
</blockquote>
</div>
<p>This makes the call in line
<code class="sourceCode cpp"><span class="pp">#2</span></code>
ill-formed, since
<code class="sourceCode cpp">std<span class="op">::</span>print</code>
cannot accept a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>.
However, the call in line
<code class="sourceCode cpp"><span class="pp">#3</span></code> is valid
— by way of a change to overload resolution that recognizes this case as
special and instead evaluates the call directly as:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;The result is {}</span><span class="sc">\n</span><span class="st">&quot;</span>, get_result<span class="op">())</span>;</span></code></pre></div>
</blockquote>
</div>
<p>In short, P1819 gives us an object (that doesn’t evaluate any of the
expressions) while P3412 gives us either a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>
or an argument list, depending on context.</p>
<p>Of the two, I think P1819 is significantly better. We get a simple
object that can allow for a wide variety of potential functionality. It
has two big problems though. The first is that it evaluates lazily and
stores its data opaquely — which leads to more surprising behavior, the
potential for dangling references, and arbitrarily limited usage. The
other is its breakup into pieces doesn’t actually play very well with
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
— where we would want there to be a format string and we don’t have one.
The original motivation for the lambda approach was ease of use — get
all the expressions in one convenient format. But the language has
evolved since 2019. We have both reflection and packs in structured
bindings now, so we don’t need the lambda approach anymore.</p>
<p>On the other hand, P3412 is a very complex design, with an overload
resolution mechanism that is very strongly coupled to the current
implementation strategy of formatting. What if we someday get
<code class="sourceCode cpp"><span class="kw">constexpr</span></code>
function parameters and it turns out to be better to implement <code class="sourceCode cpp">basic_format_string<span class="op">&lt;</span><span class="dt">char</span>, Args<span class="op">...&gt;</span></code>
as taking a <code class="sourceCode cpp"><span class="kw">constexpr</span> string_view</code>
instead of it being a
<code class="sourceCode cpp"><span class="kw">consteval</span></code>
constructor? Would we need to change how string interpolation is defined
too? All this complexity buys us is the ability to create a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>
in a single character. However, I don’t think that’s even a good goal
for C++ — we shouldn’t hide an operation as costly as string formatting
in a single character, and we shouldn’t tie the language so tightly to
this particular library (as this proposal does via
<code class="sourceCode cpp">__format__</code>).</p>
<p>Instead, this paper proposes an idea much closer to the P1819
model.</p>
<h2 data-number="1.2" id="prior-art-in-python"><span class="header-section-number">1.2</span> Prior Art in Python<a href="#prior-art-in-python" class="self-link"></a></h2>
<p>Python 3.6 introduced literal string interpolation (<code class="sourceCode cpp">f<span class="st">&quot;...&quot;</span></code>)
in <span class="citation" data-cites="PEP-498"><a href="https://peps.python.org/pep-0498/" role="doc-biblioref">[PEP-498]</a></span>, which was later extended in
Python 3.14 by template strings (<code class="sourceCode cpp">t<span class="st">&quot;...&quot;</span></code>)
in <span class="citation" data-cites="PEP-750"><a href="https://peps.python.org/pep-0750/" role="doc-biblioref">[PEP-750]</a></span>. The former directly produces
a <code class="sourceCode cpp">string</code>, while the latter gives a
template string — an object with enough information in it to be
formatted later. This is similar to Rust’s
<code class="sourceCode cpp">format_args<span class="op">!</span></code>,
which gives you a completely opaque object (unlike Python’s which is
completely specified).</p>
<p>Both languages gives you a facility to take an interpolated string
and produce an object for future work (similar to P1819).</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="design"><span class="header-section-number">2</span> Design<a href="#design" class="self-link"></a></h1>
<p>This paper proposes that we introduce string interpolation for C++
following the same idea as Python’s template strings. We’ll have to come
up with a better name than “template string” for this, but for now I’m
going to stick with it. A template string literal will eagerly evaluate
all of the expressions and produce a new object with all of the relevant
pieces, such that it will be suitable for both formatting APIs (like
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
and
<code class="sourceCode cpp">std<span class="op">::</span>print</code>)
and other APIs that have nothing to do with formatting.</p>
<p>Our example from earlier:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> get_result<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">42</span>; <span class="op">}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> interp <span class="op">=</span> t<span class="st">&quot;The result is {get_result()}</span><span class="sc">\n</span><span class="st">&quot;</span>;     <span class="co">// #1</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>interp<span class="op">)</span>;                                  <span class="co">// #2</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>t<span class="st">&quot;The result is {get_result()}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>;       <span class="co">// #3</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>will evaluate as:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <em>Template</em> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt <span class="op">=</span> <span class="st">&quot;The result is {}</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> strings<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;The result is &quot;</span>, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">}</span>;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> std<span class="op">::</span>interpolation interpolations<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="st">&quot;get_result()&quot;</span>, <span class="st">&quot;{}&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span><span class="op">}}</span>;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <em>_0</em>;</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> interp <span class="op">=</span> <em>Template</em><span class="op">{</span>get_result<span class="op">()}</span>;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>interp<span class="op">)</span>;</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span><em>Template</em><span class="op">{</span>get_result<span class="op">()})</span>;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Let’s go through all of these pieces in order. A template string will
generate an instance of a not-necessarily-unique type (unlike a lambda
expression, which always has a unique type) by parsing the replacement
fields of the string literal. The parsing logic here is very basic and
does not need to understand very much about either the format specifier
mini-language or C++ expressions more broadly. The interpolation type
will have four public pieces of information in it:</p>
<ul>
<li><code class="sourceCode cpp">fmt</code> is a static data member that
contains a format string,</li>
<li><code class="sourceCode cpp">strings</code> is a static array of
string literals that are just the string parts,</li>
<li><code class="sourceCode cpp">interpolations</code> is a static array
of the <a href="#interpolation-information">interpolation
information</a>, and then</li>
<li>one non-static data member for each expression. The type of the
member for expression <code class="sourceCode cpp"><em>E</em></code> is
<code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">((</span><em>E</em><span class="op">))</span></code>,
and the name of the member is unspecified.</li>
</ul>
<p>With this structure, we can easily add additional overloads to the
format library to handle template strings:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> print<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>pieces<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>fmt<span class="op">()</span>, pieces<span class="op">...)</span>;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Note that there is no difference in handling between lines
<code class="sourceCode cpp"><span class="pp">#1-2</span></code> and
line <code class="sourceCode cpp"><span class="pp">#3</span></code> in
the example (like the P1819 design and unlike the P3412 one). A template
string is just an object, that contains within it all the relevant
information.</p>
<p>The rest of the paper will go through details on first on how the
parsing works and then into other examples to help motivate the
structure.</p>
<p>Keep in mind that since a template string object is <em>just an
object</em>, where most of the information are static data members, this
ends up being a very embedded-friendly design too.</p>
<h2 data-number="2.1" id="parsing"><span class="header-section-number">2.1</span> Parsing<a href="#parsing" class="self-link"></a></h2>
<p>A template string is conceptually an alternating sequence of string
literals and interpolations. The string literal parts are just normal
string literals — we look ahead until we find a non-escaped
<code class="sourceCode cpp"><span class="op">{</span></code> to start
the next replacement field (<code class="sourceCode cpp"><span class="st">&quot;{{&quot;</span></code> in
a format string is used to print the single character
<code class="sourceCode cpp"><span class="ch">&#39;{&#39;</span></code>).
A replacement-field comes in two forms:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><em>replacement-field</em><span class="op">:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <em>expr</em> <span class="op">}</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <em>expr</em> <span class="op">:</span> <em>format-spec</em> <span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>C++ expressions can be arbitrary complicated. Notably, they can also
include <code class="sourceCode cpp"><span class="op">:</span></code> or
<code class="sourceCode cpp"><span class="op">}</span></code>. both of
which are significant in formatting and indicate the end of the
expression. So how do we know when we’re done with the
<code class="sourceCode cpp"><em>expr</em></code> part here?</p>
<p>One approach would be to simply limit the kinds of expressions that
can appear in template strings. Rust, for instance, <em>only</em>
supports identifiers. That obviously makes parsing quite easy, but it
also is very limiting. On the other extreme, supporting <em>all</em>
expressions can easily lead to undecipherable code. I think on balance,
supporting only identifiers is far too restrictive. But once you start
adding what other kinds of expressions to allow (surely, at least class
member access), it quickly becomes too difficult to keep track of what
is allowed (indexing? function calls? splices?) and ironically makes
both the implementation more difficult (to enforce what is and isn’t
allowed) and harder to understand for the user (to know which
expressions are and aren’t allowed).</p>
<p>I think it’s best to simply allow anything in the expression (as
Python does) and trust the user to refactor their expressions to be as
legible as they desire. This allows us to take a very simple approach:
we simply lex <code class="sourceCode cpp"><em>expr</em></code> as a
balanced token sequence (just counting
<code class="sourceCode cpp"><span class="op">{}</span></code>s,
<code class="sourceCode cpp"><span class="op">()</span></code>s, and
<code class="sourceCode cpp"><span class="op">[]</span></code>s), so
that colons and braces inside of any of the bracket kinds are treated as
part of an expression. But the first
<code class="sourceCode cpp"><span class="op">:</span></code> or
<code class="sourceCode cpp"><span class="op">}</span></code>
encountered when we’re at a brace depth of zero means we’re done with
<code class="sourceCode cpp"><em>expr</em></code>.</p>
<p>Here are some examples of template string formatting calls and how
they would be evaluated:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>template string</strong>
</div></th>
<th><div style="text-align:center">
<strong>evaluated as</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;x={x}&quot;</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;x={}&quot;</span>, x<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;x={[]{ return 42; }()}&quot;</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;x={}&quot;</span>, <span class="op">[]{</span> <span class="cf">return</span> <span class="dv">42</span>; <span class="op">}())</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;x={co_await f(x) + g(y) / z}&quot;</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;x={}&quot;</span>, <span class="kw">co_await</span> f<span class="op">(</span>x<span class="op">)</span> <span class="op">+</span> g<span class="op">(</span>y<span class="op">)</span> <span class="op">/</span> z<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;x={a::b}&quot;</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;x={::b}&quot;</span>, a<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;x={(a::b)}&quot;</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;x={}&quot;</span>, <span class="op">(</span>a<span class="op">::</span>b<span class="op">))</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;x={cond ? a : b}&quot;</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;x={:b}&quot;</span>, cond <span class="op">?</span> a<span class="op">)</span></code>
❌</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;x={(cond ? a : b)}&quot;</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;x={}&quot;</span>, <span class="op">(</span>cond <span class="op">?</span> a <span class="op">:</span> b<span class="op">))</span></code></td>
</tr>
</tbody>
</table>
<p>In order to format expressions that use scoping or the conditional
operator, you’ll just have to write parentheses. That seems easy enough
to both understand and use. Otherwise, anything goes.</p>
<h2 data-number="2.2" id="parsing-nested-expressions"><span class="header-section-number">2.2</span> Parsing Nested Expressions<a href="#parsing-nested-expressions" class="self-link"></a></h2>
<p>Consider the template string:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>t<span class="st">&quot;{name:&gt;{width}}&quot;</span></span></code></pre></div>
</blockquote>
</div>
<p>There are two expressions here:
<code class="sourceCode cpp">name</code> and
<code class="sourceCode cpp">width</code>. Or rather, we know
<code class="sourceCode cpp">name</code> is an expression, but how do we
know that <code class="sourceCode cpp">width</code> is? In the format
model, the format specifiers can be <em>anything</em>. There really are
no rules — as long as the type’s formatter can handle it. Having nested
braces in a format specifier commonly refers to another argument, but it
need not actually mean that.</p>
<p>In my CppCon 2022 talk <a href="https://youtu.be/EQELdyecZlU?t=2397">The Surprising Complexity of
Formatting Ranges</a>, I work through an example of how one might add
underlying specifiers to
<code class="sourceCode cpp">std<span class="op">::</span>pair</code>
and
<code class="sourceCode cpp">std<span class="op">::</span>tuple</code>,
<a href="https://godbolt.org/z/vPfE7er3M">where</a>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> elems <span class="op">=</span> std<span class="op">::</span>tuple<span class="op">(</span><span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span><span class="op">)</span>;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}</span><span class="sc">\n</span><span class="st">&quot;</span>, elems<span class="op">)</span>;                  <span class="co">// (10, 20, 30)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{:{x}{#x}{-^4}}</span><span class="sc">\n</span><span class="st">&quot;</span>, elems<span class="op">)</span>;     <span class="co">// (a, 0x14, -30-)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{:{x}{}{x}}</span><span class="sc">\n</span><span class="st">&quot;</span>, elems<span class="op">)</span>;         <span class="co">// (a, 20, 1e)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>There, <code class="sourceCode cpp"><span class="op">{</span>x<span class="op">}</span></code>
doesn’t refer to the expression <code class="sourceCode cpp">x</code>,
it was just chosen as notational convenience. So how can we get this to
work?</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span>t<span class="st">&quot;{elems:{x}{}{x}}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>The short answer is: we cannot. We need to make sense of the template
string literal separate from type information, and even if we had type
information, it’s not like we have a way for the
<code class="sourceCode cpp">formatter</code> API to signal when it’s
expecting an expression. We just have to make a choice up front for what
to do here. I think we have three options:</p>
<ol type="1">
<li>We could explicitly opt <em>in</em> to a nested expression. That is,
maybe something like <code class="sourceCode cpp">t<span class="st">&quot;{elems:{x}{}${x}}&quot;</span></code>
signals that the first <code class="sourceCode cpp"><span class="op">{</span>x<span class="op">}</span></code>
is just a string but the second <code class="sourceCode cpp"><span class="op">{</span>x<span class="op">}</span></code>
is actually the expression <code class="sourceCode cpp">x</code>. So in
the above example, we simply wouldn’t use the
<code><span class="op">$</span></code>.</li>
<li>We could explicitly opt <em>out</em> of being a nested expression
with added escaping. Which in this case would be <code class="sourceCode cpp">t<span class="st">&quot;{elems:{{x}}{{}}{{x}}}&quot;</span></code>.</li>
<li>We could say that in a format specifier, encountering a
<code class="sourceCode cpp"><span class="op">{</span></code>
<em>always</em> begins an expression that ends at
<code class="sourceCode cpp"><span class="op">:</span></code> or
<code class="sourceCode cpp"><span class="op">}</span></code> (same as
top-level) and that there is neither opt-in nor opt-out. Meaning that
the approach to format specifiers that I demonstrated in that talk
wouldn’t work, and would instead have to be <code class="sourceCode cpp">t<span class="st">&quot;{elems:{:x}{}{:x}}&quot;</span></code>.</li>
</ol>
<p>I think the third option here is the best. It is at most a minor
burden on users as I doubt this approach is in widespread use, and
allows for a design that is as simple as possible.</p>
<p>Getting back to our original example:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>t<span class="st">&quot;{name:&gt;{width}}&quot;</span></span></code></pre></div>
</blockquote>
</div>
<p>This would parse as two expressions:
<code class="sourceCode cpp">name</code> and
<code class="sourceCode cpp">width</code>, with a single corresponding
format string <code class="sourceCode cpp"><span class="st">&quot;{:&gt;{}}&quot;</span></code>.
If we simply stored the expressions and the format string, that would be
straightforward: we just have two <a href="#data-members">data
members</a>. But we can do better than that. But before we get into the
<a href="#interpolation-information">interpolation information</a>, I’ll
talk about the data members.</p>
<h2 data-number="2.3" id="data-members"><span class="header-section-number">2.3</span> Data Members<a href="#data-members" class="self-link"></a></h2>
<p>For any expression, <code class="sourceCode cpp"><em>E</em></code>,
including nested expressions, a non-static data member will be generated
(and then initialized from
<code class="sourceCode cpp"><em>E</em></code>) having type <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">((</span><em>E</em><span class="op">))</span></code>.
This ensures that we get the right type, but also that we’re not copying
anything unnecessarily. For instance:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> verb<span class="op">()</span> <span class="op">-&gt;</span> std<span class="op">::</span>string;</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">(</span>std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;</span> name, std<span class="op">::</span>string relation<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> tmpl <span class="op">=</span> t<span class="st">&quot;Hello, my name is {name}. You killed my {relation}. Prepare to {verb()}.&quot;</span>;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>The object <code class="sourceCode cpp">tmpl</code> will have three
members:</p>
<ul>
<li>the first, corresponding to
<code class="sourceCode cpp">name</code>, has type <code class="sourceCode cpp">std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;</span></code></li>
<li>the second, corresponding to
<code class="sourceCode cpp">relation</code>, has type <code class="sourceCode cpp">std<span class="op">::</span>string<span class="op">&amp;</span></code></li>
<li>the third, corresponding to
<code class="sourceCode cpp">verb<span class="op">()</span></code>, has
type
<code class="sourceCode cpp">std<span class="op">::</span>string</code></li>
</ul>
<p>These are all public, non-static data members. If we want to copy all
of the members (e.g. because we want to serialize them), we can easily
do so. It’s just that there is no need for the template string itself to
do so directly. Note that the call to
<code class="sourceCode cpp">verb<span class="op">()</span></code>
happens immediately and the result is stored in
<code class="sourceCode cpp">tmpl</code>. We are not lazily holding onto
the expression
<code class="sourceCode cpp">verb<span class="op">()</span></code>.</p>
<h2 data-number="2.4" id="interpolation-information"><span class="header-section-number">2.4</span> Interpolation Information<a href="#interpolation-information" class="self-link"></a></h2>
<p>A template string will have a <code class="sourceCode cpp"><span class="kw">static</span> <span class="kw">constexpr</span></code>
data member of type <code class="sourceCode cpp">std<span class="op">::</span>interpolation</code>,
which is a simple aggregate with four members:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> interpolation <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> expression;</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt;</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> index;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> count;</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p><code class="sourceCode cpp">expression</code> is a string literal
that is the stringified version of the expression.
<code class="sourceCode cpp">fmt</code> is the full format specifier
with the expression removed, that you would need in order to format this
specific expression. Then, we need both
<code class="sourceCode cpp">index</code> and
<code class="sourceCode cpp">num</code> in order to support nested
replacement expressions, as we just went through. That gives us both the
first non-static data member and the amount of non-static data members
this interpolation is associated with.</p>
<p>The template string literal <code class="sourceCode cpp">t<span class="st">&quot;{name:&gt;{width}}&quot;</span></code>
needs to generate the object</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <em>Template</em> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt <span class="op">=</span> <span class="st">&quot;{:&gt;{}}&quot;</span>;</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> strings<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span><span class="op">}</span>;</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> interpolation interpolations<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>expression <span class="op">=</span> <span class="st">&quot;name&quot;</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>fmt <span class="op">=</span> <span class="st">&quot;{:&gt;{}}&quot;</span>,</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>index <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>count <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}}</span>;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;</span> <em>_0</em>;</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span> <em>_1</em>;</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>Why do we go through the trouble of proving
<code class="sourceCode cpp">strings</code> and
<code class="sourceCode cpp">interpolations</code>? Consider again our
example from earlier:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> tmpl <span class="op">=</span> t<span class="st">&quot;Hello, my name is {name}. You killed my {relation}. Prepare to {verb()}.&quot;</span>;</span></code></pre></div>
</blockquote>
</div>
<p>I already showed how we could print this normally, which didn’t use
either of those two arrays:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> print<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>pieces<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>fmt, pieces<span class="op">...)</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>But we could do a lot more with this object other than just print it.
We could write a function to automatically highlight the interpolations
green and bold, which is supported by the
<code class="sourceCode cpp">fmt</code> library but not the standard.
That’s straightforward, since we’re not tied into any particular
library, and we have all the information we need:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> highlighted_print<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="op">[</span>str, interp<span class="op">]</span> <span class="op">:</span> std<span class="op">::</span>views<span class="op">::</span>zip<span class="op">(</span>s<span class="op">.</span>strings, s<span class="op">.</span>interpolations<span class="op">))</span> <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>str<span class="op">)</span>;</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="op">[...</span>I<span class="op">]</span> <span class="op">=</span> std<span class="op">::</span>make_index_sequence<span class="op">&lt;</span>interp<span class="op">.</span>count<span class="op">&gt;()</span>;</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>fmt<span class="op">::</span>emphasis<span class="op">::</span>bold <span class="op">|</span> fg<span class="op">(</span>fmt<span class="op">::</span>color<span class="op">::</span>green<span class="op">)</span>,</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                   interp<span class="op">.</span>fmt,</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                   exprs<span class="op">...[</span>interp<span class="op">.</span>index <span class="op">+</span> I<span class="op">]...)</span>;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>strings<span class="op">[</span>std<span class="op">::</span>size<span class="op">(</span>s<span class="op">.</span>strings<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">])</span>;</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Or we could turn it into the JSON object <code class="sourceCode cpp"><span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;Inigo Montoya&quot;</span>, <span class="st">&quot;relation&quot;</span><span class="op">:</span> <span class="st">&quot;father&quot;</span>, <span class="st">&quot;verb()&quot;</span><span class="op">:</span> <span class="st">&quot;die&quot;</span><span class="op">}</span></code>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> into_json<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> boost<span class="op">::</span>json<span class="op">::</span>object <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    boost<span class="op">::</span>json<span class="op">::</span>object o;</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> interp <span class="op">:</span> s<span class="op">.</span>interpolations<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        o<span class="op">[</span>interp<span class="op">.</span>expression<span class="op">]</span> <span class="op">=</span> exprs<span class="op">...[</span>interp<span class="op">.</span>index<span class="op">]</span>;</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> o;</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>The important thing is to expose all the relevant information to
users to let them do whatever they want with it. Note that
<code class="sourceCode cpp">highlighted_print</code> uses the
<code class="sourceCode cpp">fmt</code>,
<code class="sourceCode cpp">index</code>, and
<code class="sourceCode cpp">count</code> fields of the interpolation,
since it is formatting all of them, but not the
<code class="sourceCode cpp">expression</code> field. Meanwhile,
<code class="sourceCode cpp">into_json</code> uses only
<code class="sourceCode cpp">expression</code> and
<code class="sourceCode cpp">index</code> — it doesn’t need any of the
format specifier logic, since it isn’t actually doing formatting.</p>
<p>Having both
<code class="sourceCode cpp">interp<span class="op">.</span>index</code>
and
<code class="sourceCode cpp">interp<span class="op">.</span>count</code>
is a little clunky, especially since
<code class="sourceCode cpp">interp<span class="op">.</span>count</code>
will almost always be
<code class="sourceCode cpp"><span class="dv">1</span></code>. But I
think it’s better to put the clunkiness there and maintain the trivial
formatting implementations (where you can just unpack the template
string object).</p>
<h2 data-number="2.5" id="the-templatestring-concept"><span class="header-section-number">2.5</span> The
<code class="sourceCode cpp">TemplateString</code> Concept<a href="#the-templatestring-concept" class="self-link"></a></h2>
<p>In these examples, I’ve been using this
<code class="sourceCode cpp">TemplateString</code> concept to identify a
template string object. The question is, what does that concept look
like? This one I’m not sure about yet. It can’t be a built-in, since
users might need to create one of these objects. Consider a logger:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>log<span class="op">::</span>info<span class="op">(</span>t<span class="st">&quot;Got a trade for in {symbol}: {side} {qty} @ {price}&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>The expressions here are all cheap to copy, but formatting is
expensive — so I might want to serialize all of the data into a
background thread to do my formatting there. I don’t want to just copy
the template string object, since it might have references. With
reflection, I can create a new type that has only value members, and
then keep the same <code class="sourceCode cpp">fmt</code>,
<code class="sourceCode cpp">strings</code>, and
<code class="sourceCode cpp">interpolations</code>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S, <span class="kw">class</span> F<span class="op">&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> map<span class="op">(</span>S s, F f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Base;</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>meta<span class="op">::</span>info<span class="op">&gt;</span> specs;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>meta<span class="op">::</span>info m <span class="op">:</span> nonstatic_data_members_of<span class="op">(^^</span>S<span class="op">))</span> <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>            specs<span class="op">.</span>push_back<span class="op">(</span>data_member_spec<span class="op">({</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>type<span class="op">=</span>invoke_result<span class="op">(^^</span>F, <span class="op">{</span>type_of<span class="op">(</span>m<span class="op">)})</span>,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>name<span class="op">=</span>identifier_of<span class="op">(</span>m<span class="op">)</span>,</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}))</span>;</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        define_aggregate<span class="op">(^^</span>Base, specs<span class="op">)</span>;</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> R <span class="op">:</span> Base <span class="op">{</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt <span class="op">=</span> S<span class="op">::</span>fmt;</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> strings <span class="op">=</span> S<span class="op">::</span>strings;</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> interpolations <span class="op">=</span> S<span class="op">::</span>interpolations;</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>pieces<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> R<span class="op">{{</span>f<span class="op">(</span>FWD<span class="op">(</span>pieces<span class="op">))...}}</span>;</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Which allows the implementation of all of the logging functions to
<code class="sourceCode cpp">map</code> their provided template string
object to decay or otherwise transform every member into something that
won’t dangle.</p>
<p>I’d want to make sure this <code class="sourceCode cpp">R</code> here
is also considered a template string for all of these purposes. There
are a few attributes here, not really sure which would be best:</p>
<ul>
<li>an attribute</li>
<li>an annotation</li>
<li>structural conformance: simply check for the presence of
<code class="sourceCode cpp">fmt</code>,
<code class="sourceCode cpp">strings</code>, and
<code class="sourceCode cpp">interpolations</code>?</li>
</ul>
<h2 data-number="2.6" id="implementation-experience"><span class="header-section-number">2.6</span> Implementation Experience<a href="#implementation-experience" class="self-link"></a></h2>
<p>I implemented this in Clang, on top of the p2996 reflection branch.
Code can be found in my fork in the
<code><span class="op">template-strings</span></code> branch <a href="https://github.com/brevzin/llvm-project/tree/template-strings">here</a>.
I’m sure there are better ways to do some of what I did, but on the
whole, the implementation is completely standalone. The only difference
between this paper and the implementation is that instead of introducing
the type <code class="sourceCode cpp">std<span class="op">::</span>interpolation</code>,
I just made <code class="sourceCode cpp">interpolation</code> a nested
class of each template string type, just for convenience.</p>
<p>This does raise the question of how <code class="sourceCode cpp">std<span class="op">::</span>interpolation</code>
should be defined. It does make sense for it to be one type, rather than
the distinct type per template string that I implemented. But should
this facility really require a new header? Maybe it’s a sufficiently
trivial type (an aggregate with no member functions and just four data
members, each of scalar type) that the compiler can just generate it?
Maybe we don’t care about additional headers because
<code class="sourceCode cpp"><span class="kw">import</span> std;</code>
anyway?</p>
<p>The same question goes for if we want to implement the <a href="#the-templatestring-concept">concept</a> by way of annotation.
That annotation would be an empty type, could the compiler just create
it?</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">3</span>
References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="1" role="doc-bibliography">
<div id="ref-P1819R0" class="csl-entry" role="doc-biblioentry">
[P1819R0] Vittorio Romeo. 2019-07-20. Interpolated Literals. <a href="https://wg21.link/p1819r0"><div class="csl-block">https://wg21.link/p1819r0</div></a>
</div>
<div id="ref-P3412R3" class="csl-entry" role="doc-biblioentry">
[P3412R3] Bengt Gustafsson, Victor Zverovich. 2025-12-14. String
Interpolation. <a href="https://wg21.link/p3412r3"><div class="csl-block">https://wg21.link/p3412r3</div></a>
</div>
<div id="ref-PEP-498" class="csl-entry" role="doc-biblioentry">
[PEP-498] Eric V. Smith. 2015-08-01. Literal String Interpolation. <a href="https://peps.python.org/pep-0498/"><div class="csl-block">https://peps.python.org/pep-0498/</div></a>
</div>
<div id="ref-PEP-750" class="csl-entry" role="doc-biblioentry">
[PEP-750] Jim Baker, Guido van Rossum, Paul Everitt, Koudai Aono,
Lysandros Nikolaou, and Dave Peck. 2024-07-08. Template Strings. <a href="https://peps.python.org/pep-0750/"><div class="csl-block">https://peps.python.org/pep-0750/</div></a>
</div>
</div>
</div>
</div>
</body>
</html>
