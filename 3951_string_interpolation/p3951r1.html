<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2026-02-16" />
  <title>String Interpolation with Template Strings</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.csl-block{margin-left: 1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
text-align: justify;
}
@media screen and (max-width: 30em) {
body {
margin: 1.5em;
}
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
td > div > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #C9FBC9;
--diff-strongins: #acf2bd;
--diff-del: #FFC8EB;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.addu td pre { background-color: inherit; }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
div.std blockquote { color: #000000; background-color: #F1F1F1;
border: 1px solid #D1D1D1;
padding-left: 0.5em; padding-right: 0.5em; }
div.std.ins blockquote {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.ins > div.example {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.std div.sourceCode { background-color: inherit; margin-left: 1em; }
div.rm li {
text-decoration: line-through;
color: #bf0303;
}
div.std blockquote del, div.rm {
text-decoration: line-through;
color: #bf0303;
background-color: var(--diff-del);
border: none;
}
code del { border: 1px solid #ECB3C7; }
span.orange {
background-color: #ffa500;
}
span.yellow {
background-color: #ffff00;
}</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">String Interpolation with
Template Strings</h1>
<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P3951R1 <a href="https://wg21.link/P3951">[Latest]</a> <a href="https://wg21.link/P3951/status">[Status]</a></td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2026-02-16</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>
</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction<span></span></a>
<ul>
<li><a href="#prior-work" id="toc-prior-work"><span class="toc-section-number">1.1</span> Prior Work<span></span></a></li>
<li><a href="#prior-art-in-other-languages" id="toc-prior-art-in-other-languages"><span class="toc-section-number">1.2</span> Prior Art in Other
Languages<span></span></a></li>
</ul></li>
<li><a href="#design" id="toc-design"><span class="toc-section-number">2</span> Design<span></span></a>
<ul>
<li><a href="#lexing" id="toc-lexing"><span class="toc-section-number">2.1</span> Lexing<span></span></a></li>
<li><a href="#handling-macro-expansion" id="toc-handling-macro-expansion"><span class="toc-section-number">2.2</span> Handling Macro
Expansion<span></span></a></li>
<li><a href="#lexing-trailing-equals" id="toc-lexing-trailing-equals"><span class="toc-section-number">2.3</span> Lexing Trailing
Equals<span></span></a></li>
<li><a href="#lexing-nested-expressions" id="toc-lexing-nested-expressions"><span class="toc-section-number">2.4</span> Lexing Nested
Expressions<span></span></a></li>
<li><a href="#concatenating-consecutive-string-literals" id="toc-concatenating-consecutive-string-literals"><span class="toc-section-number">2.5</span> Concatenating Consecutive String
Literals<span></span></a></li>
<li><a href="#data-members" id="toc-data-members"><span class="toc-section-number">2.6</span> Data Members<span></span></a></li>
<li><a href="#interpolation-information" id="toc-interpolation-information"><span class="toc-section-number">2.7</span> Interpolation
Information<span></span></a></li>
<li><a href="#examples" id="toc-examples"><span class="toc-section-number">2.8</span> Examples<span></span></a></li>
<li><a href="#the-templatestring-concept" id="toc-the-templatestring-concept"><span class="toc-section-number">2.9</span> The
<code class="sourceCode cpp">TemplateString</code>
Concept<span></span></a></li>
<li><a href="#implementation-experience" id="toc-implementation-experience"><span class="toc-section-number">2.10</span> Implementation
Experience<span></span></a></li>
<li><a href="#more-formal-lexing-specification" id="toc-more-formal-lexing-specification"><span class="toc-section-number">2.11</span> More Formal Lexing
Specification<span></span></a></li>
</ul></li>
<li><a href="#alternate-approaches" id="toc-alternate-approaches"><span class="toc-section-number">3</span> Alternate
Approaches<span></span></a>
<ul>
<li><a href="#f-strings" id="toc-f-strings"><span class="toc-section-number">3.1</span>
<code class="sourceCode cpp">f</code>-strings<span></span></a></li>
<li><a href="#reduced-representation" id="toc-reduced-representation"><span class="toc-section-number">3.2</span> Reduced
Representation<span></span></a></li>
<li><a href="#redundant-information" id="toc-redundant-information"><span class="toc-section-number">3.3</span> Redundant
Information<span></span></a></li>
<li><a href="#static-data-members-or-static-member-functions" id="toc-static-data-members-or-static-member-functions"><span class="toc-section-number">3.4</span> Static Data Members or Static
Member Functions<span></span></a></li>
<li><a href="#wait-for-reflection" id="toc-wait-for-reflection"><span class="toc-section-number">3.5</span> Wait for
Reflection<span></span></a></li>
<li><a href="#object-vs-expression-list" id="toc-object-vs-expression-list"><span class="toc-section-number">3.6</span> Object vs
Expression-List<span></span></a></li>
</ul></li>
<li><a href="#bibliography" id="toc-bibliography"><span class="toc-section-number">4</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">1</span>
Introduction<a href="#introduction" class="self-link"></a></h1>
<p>The
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
approach to formatting offers many significant benefits over the prior
<code class="sourceCode cpp"><span class="op">&lt;</span>iostream<span class="op">&gt;</span></code>s
approach that need not be revisited here. However, <code class="sourceCode cpp"><span class="op">&lt;</span>iostream<span class="op">&gt;</span></code>
does still have one significant advantage: ordering. It is easy to see
at a glance with a long
<code class="sourceCode cpp">std<span class="op">::</span>cout</code>
statement which pieces are to be formatted in which order. With
<code class="sourceCode cpp">std<span class="op">::</span>format</code>,
as the amount of replacement fields increases, it becomes increasingly
difficult to ensure that they are all correctly ordered.</p>
<p>The solution to this problem is string interpolation: the ability to
put the expression to be formatted inside of the format string. This
lets us preserve all of the advantages of
<code class="sourceCode cpp">std<span class="op">::</span>format</code>,
while also regaining ordering. String interpolation is a wildly popular
language feature due to the ease with which it allows users to express
complex ideas. It’s not surprising that a huge number of modern
languages support this to some degree or another. A non-exhaustive list
includes: C#, D, Elixir, F#, Groovy, Kotlin, JavaScript, Perl, PHP,
Python, Ruby, Rust, Scala, Swift, and VB.</p>
<h2 data-number="1.1" id="prior-work"><span class="header-section-number">1.1</span> Prior Work<a href="#prior-work" class="self-link"></a></h2>
<p>There have been two prior WG21 papers pursuing string interpolation
as a C++ language feature: <span class="title"><span class="citation" data-cites="P1819R0"><a href="https://wg21.link/p1819r0" role="doc-biblioref">[P1819R0] (Interpolated Literals)</a></span></span>
and <span class="title"><span class="citation" data-cites="P3412R3"><a href="https://wg21.link/p3412r3" role="doc-biblioref">[P3412R3] (String
Interpolation)</a></span></span>. The two proposals are quite different,
so let’s consider an example to work through the details:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> get_result<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">42</span>; <span class="op">}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> interp <span class="op">=</span> f<span class="st">&quot;The result is {get_result()}</span><span class="sc">\n</span><span class="st">&quot;</span>;     <span class="co">// #1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>interp<span class="op">)</span>;                                  <span class="co">// #2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>f<span class="st">&quot;The result is {get_result()}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>;       <span class="co">// #3</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>In P1819, the <code class="sourceCode cpp">interp</code> is an object
that is roughly equivalent to:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> interp <span class="op">=</span> <span class="op">[&amp;](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f<span class="op">(</span><span class="st">&quot;The result is &quot;</span>, get_result<span class="op">()</span>, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>So line
<code class="sourceCode cpp"><span class="pp">#1</span></code> does
nothing. The call to
<code class="sourceCode cpp">get_result<span class="op">()</span></code>
does not happen yet. Instead, the library would provide new overloads of
<code class="sourceCode cpp">std<span class="op">::</span>print</code>
and friends so that in line
<code class="sourceCode cpp"><span class="pp">#2</span></code>, the
library would invoke <code class="sourceCode cpp">interp</code> with the
appropriate function to do the printing. The call to
<code class="sourceCode cpp">get_result<span class="op">()</span></code>
happens at that point. Line
<code class="sourceCode cpp"><span class="pp">#3</span></code> does the
same things as lines
<code class="sourceCode cpp"><span class="pp">#1</span></code> and
<code class="sourceCode cpp"><span class="pp">#2</span></code>, just
together.</p>
<p>In P3412, the behavior is very different.
<code class="sourceCode cpp">interp</code> is already a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>,
which is evaluated as:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> interp <span class="op">=</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;The result is {}</span><span class="sc">\n</span><span class="st">&quot;</span>, get_result<span class="op">())</span>;</span></code></pre></div>
</blockquote>
</div>
<p>This makes the call in line
<code class="sourceCode cpp"><span class="pp">#2</span></code>
ill-formed, since
<code class="sourceCode cpp">std<span class="op">::</span>print</code>
cannot accept a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>.
However, the call in line
<code class="sourceCode cpp"><span class="pp">#3</span></code> is valid
— by way of a change to overload resolution that recognizes this case as
special and instead evaluates the call directly as:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;The result is {}</span><span class="sc">\n</span><span class="st">&quot;</span>, get_result<span class="op">())</span>;</span></code></pre></div>
</blockquote>
</div>
<p>In short, P1819 gives us an object (that doesn’t evaluate any of the
expressions) while P3412 gives us either a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>
or an argument list, depending on context.</p>
<p>Of the two, I think P1819 is significantly better. We get a simple
object that can allow for a wide variety of potential functionality. It
has two big problems though. The first is that it evaluates lazily and
stores its data opaquely — which leads to more surprising behavior, the
potential for dangling references, and arbitrarily limited usage. The
other is its breakup into pieces doesn’t actually play very well with
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
— where we would want there to be a format string and we don’t have one.
The original motivation for the lambda approach was ease of use — get
all the expressions in one convenient format. But the language has
evolved since 2019. We have both reflection and packs in structured
bindings now, so we don’t need the lambda approach anymore.</p>
<p>On the other hand, P3412 is actually not one but two different
language features — and it’s worth taking some time to evaluate this.
This is more explicit in <span class="citation" data-cites="P3412R1"><a href="https://wg21.link/p3412r1" role="doc-biblioref">[P3412R1]</a></span>:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Evaluates As</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>print<span class="op">(</span>x<span class="st">&quot;The result is {get_result()}&quot;</span><span class="op">)</span>;</span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;The result is {}&quot;</span>, get_result<span class="op">())</span>;</span></code></pre></div>

</div></td>
</tr>
<tr class="even">
<td><div>

<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s <span class="op">=</span> f<span class="st">&quot;The result is {get_result()}&quot;</span><span class="op">)</span>;</span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s <span class="op">=</span> std<span class="op">::</span>format<span class="op">(</span>x<span class="st">&quot;The result is {get_result()}&quot;</span><span class="op">)</span>;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s <span class="op">=</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;The result is {}&quot;</span>, get_result<span class="op">())</span>;</span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>The x-literal did string interpolation — it evaluated as an
expression-list. That’s the workhorse that provides the value of the
feature. In contrast, the f-literal was simply syntax sugar for a call
to
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
with the appropriate x-literal. It’s a language feature for simply
calling
<code class="sourceCode cpp">std<span class="op">::</span>format</code>.
Not precisely
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
— since not everybody uses
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
so instead this was introduced as a language customization mechanism.
But we’re really just abbreviating a function call.</p>
<p>In <span class="citation" data-cites="P3412R3"><a href="https://wg21.link/p3412r3" role="doc-biblioref">[P3412R3]</a></span>, this becomes significantly
more complicated because both of those features (the string
interpolation part, and the
just-calling-<code class="sourceCode cpp">std<span class="op">::</span>format</code>
part) converge to the same spelling as an f-literal. This is I think
inherently suspect because the same expression now means different
things in different contexts. Because the spelling is the same, there
needs to be a way for the language to differentiate which one the user
meant — and that mechanism is overload resolution coupled very strongly
to the current implementation strategy of formatting. The call</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>print<span class="op">(</span>f<span class="st">&quot;The result is {get_result()}&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>Works by relying on the first parameter to
<code class="sourceCode cpp">std<span class="op">::</span>print</code>
having a consteval constructor. But what if someday we get
<code class="sourceCode cpp"><span class="kw">constexpr</span></code>
function parameters and it turns out to be better to implement <code class="sourceCode cpp">basic_format_string<span class="op">&lt;</span><span class="dt">char</span>, Args<span class="op">...&gt;</span></code>
as taking a <code class="sourceCode cpp"><span class="kw">constexpr</span> string_view</code>
instead of it being a
<code class="sourceCode cpp"><span class="kw">consteval</span></code>
constructor? What if we someday get a different/better macro system such
that <code class="sourceCode cpp">std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;x={}&quot;</span>, x<span class="op">)</span></code>
evaluates not as a call to a function template but rather directly as
the expression <code class="sourceCode cpp">std<span class="op">::</span>vprint<span class="op">(</span>validate_fmt_string<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="st">&quot;x={}&quot;</span><span class="op">)</span>, std<span class="op">::</span>make_format_args<span class="op">(</span>x<span class="op">))</span></code>?</p>
<p>It’s not infeasible that some future language change gives us a
better way to solve this problem. But with the P3412R3 design, we
wouldn’t be able to adopt those changes to the formatting functions
because they would break string interpolation (unless we come up with a
new, more complicated interpolation design, which would now have to
recognize multiple implementation strategies).</p>
<p>All this complexity buys us is the ability to create a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>
in a single character. However, I don’t think that’s even a good goal
for C++ — we shouldn’t hide an operation as costly as string formatting
in a single character — and spelling
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
is not itself a huge burden. Now, without that aspect of the design, the
P3412 approach of having string interpolation emit an expression-list is
a lot simpler — I will do a comparison of the two approaches <a href="#object-vs-expression-list">later in this paper</a>.</p>
<p>Instead, this paper proposes an idea much closer to the P1819
model.</p>
<h2 data-number="1.2" id="prior-art-in-other-languages"><span class="header-section-number">1.2</span> Prior Art in Other Languages<a href="#prior-art-in-other-languages" class="self-link"></a></h2>
<p>Python 3.6 introduced literal string interpolation (<code class="sourceCode cpp">f<span class="st">&quot;...&quot;</span></code>)
in <span class="citation" data-cites="PEP-498"><a href="https://peps.python.org/pep-0498/" role="doc-biblioref">[PEP-498]</a></span>, which was later extended in
Python 3.14 by template strings (<code class="sourceCode cpp">t<span class="st">&quot;...&quot;</span></code>)
in <span class="citation" data-cites="PEP-750"><a href="https://peps.python.org/pep-0750/" role="doc-biblioref">[PEP-750]</a></span>. The former directly produces
a <code class="sourceCode cpp">string</code>, while the latter gives a
template string — an object with enough information in it to be
formatted later. This is similar to Rust’s
<code class="sourceCode cpp">format_args<span class="op">!</span></code>,
which gives you a completely opaque object (unlike Python’s which is
completely specified). Both languages gives you a facility to take an
interpolated string and produce an object for future work (similar to
P1819).</p>
<p>JavaScript also has <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template
literals</a>, which support tagging. A tagged template literal is quite
similar to what <span class="citation" data-cites="P3412R3"><a href="https://wg21.link/p3412r3" role="doc-biblioref">[P3412R3]</a></span> proposes: the expression <code class="sourceCode javascript"><span class="fu">myTag</span><span class="vs">`That </span><span class="sc">${</span>person<span class="sc">}</span><span class="vs"> is a </span><span class="sc">${</span>age<span class="sc">}</span><span class="vs">.`</span></code>
evaluates as <code class="sourceCode cpp">myTag<span class="op">([</span><span class="st">&quot;That &quot;</span>, <span class="st">&quot; is a &quot;</span>, <span class="st">&quot;.&quot;</span><span class="op">]</span>, person, age<span class="op">)</span></code>,
similar to the C++ proposal having <code class="sourceCode cpp">myTag<span class="op">(</span>f<span class="st">&quot;That {person} is a {age}&quot;</span><span class="op">)</span></code>
evaluate the transformed call <code class="sourceCode cpp">myTag<span class="op">(</span><span class="st">&quot;That {} is a {}&quot;</span>, person, age<span class="op">)</span></code>.
Here, the literal is <em>not</em> an object.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="design"><span class="header-section-number">2</span> Design<a href="#design" class="self-link"></a></h1>
<p>This paper proposes that we introduce string interpolation for C++
following the same idea as Python’s template strings. We’ll have to come
up with a better name than “template string” for this, but for now I’m
going to stick with it. A template string literal will eagerly evaluate
all of the expressions and produce a new object with all of the relevant
pieces, such that it will be suitable for both formatting APIs (like
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
and
<code class="sourceCode cpp">std<span class="op">::</span>print</code>)
and other APIs that have nothing to do with formatting.</p>
<p>Our example from earlier:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> get_result<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">42</span>; <span class="op">}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> interp <span class="op">=</span> t<span class="st">&quot;The result is {get_result()}</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>will evaluate as:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <em>Template</em> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> fmt<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;The result is {}</span><span class="sc">\n</span><span class="st">&quot;</span>; <span class="op">}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> num_interpolations<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">size_t</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span>; <span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> string<span class="op">(</span><span class="dt">size_t</span> i<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> data<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;The result is &quot;</span>, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">}</span>;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> data<span class="op">[</span>i<span class="op">]</span>;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> interpolation<span class="op">(</span><span class="dt">size_t</span> i<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>interpolation <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">constexpr</span> std<span class="op">::</span>interpolation data<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="st">&quot;get_result()&quot;</span>, <span class="st">&quot;{}&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span><span class="op">}}</span>;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> data<span class="op">[</span>i<span class="op">]</span>;</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <em>_0</em>;</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> interp <span class="op">=</span> <em>Template</em><span class="op">{</span>get_result<span class="op">()}</span>;</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Let’s go through all of these pieces in order. A template string will
generate an instance of a not-necessarily-unique type (unlike a lambda
expression, which always has a unique type) by parsing the replacement
fields of the string literal. The parsing logic here is very basic and
does not need to understand very much about either the format specifier
mini-language or C++ expressions more broadly. The interpolation type
will have five public pieces of information in it:</p>
<ul>
<li><code class="sourceCode cpp">fmt<span class="op">()</span></code> is
a static member function that returns the format string,</li>
<li><code class="sourceCode cpp">num_interpolations<span class="op">()</span></code>
is a static member function that returns the number of interpolations
(possibly 0),</li>
<li><code class="sourceCode cpp">string<span class="op">(</span>i<span class="op">)</span></code>
is a static member function that returns the
<code class="sourceCode cpp">i</code>th string part</li>
<li><code class="sourceCode cpp">interpolation<span class="op">(</span>i<span class="op">)</span></code>
is a static member function that returns the
<code class="sourceCode cpp">i</code>th <a href="#interpolation-information">interpolation information</a>, and
then lastly</li>
<li>one non-static <a href="#data-members">data member</a> for each
(possibly-nested) expression. The name of the member is unspecified, but
the order and types are.</li>
</ul>
<p>With this structure, we can easily add additional overloads to the
format library to handle template strings:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> print<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>fmt<span class="op">()</span>, exprs<span class="op">...)</span>;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Note that there is no difference in handling between lines
<code class="sourceCode cpp"><span class="pp">#1-2</span></code> and
line <code class="sourceCode cpp"><span class="pp">#3</span></code> in
the example (like the P1819 design and unlike the P3412 one). A template
string is just an object, that contains within it all the relevant
information. So whether we construct the object separately doesn’t
matter.</p>
<p>The rest of the paper will go through details on first on how the
parsing works and then into other examples to help motivate the
structure.</p>
<p>Keep in mind that since a template string object is <em>just an
object</em>, where most of the information are static data members, this
ends up being a very embedded-friendly design too.</p>
<h2 data-number="2.1" id="lexing"><span class="header-section-number">2.1</span> Lexing<a href="#lexing" class="self-link"></a></h2>
<p>A template string is conceptually an alternating sequence of string
literals and interpolations. The string literal parts are just normal
string literals — we look ahead until we find a non-escaped
<code class="sourceCode cpp"><span class="op">{</span></code> to start
the next replacement field (<code class="sourceCode cpp"><span class="st">&quot;{{&quot;</span></code> in
a format string is used to print the single character
<code class="sourceCode cpp"><span class="ch">&#39;{&#39;</span></code>).
A replacement-field comes in two forms:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><em>replacement-field</em><span class="op">:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <em>expr</em> <span class="op">}</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <em>expr</em> <span class="op">:</span> <em>format-spec</em> <span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>For example, a template string like <code class="sourceCode cpp">t<span class="st">&quot;The price of {id:x} is {price}.&quot;</span></code>
needs to be lexed into these five pieces:</p>
<table>
<tr>
<td>
String Literal
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot;The price of &quot;</span></code>
</td>
</tr>
<tr>
<td>
Interpolation
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot;{:x}&quot;</span></code>
with expression <code class="sourceCode cpp">id</code>
</td>
</tr>
<tr>
<td>
String Literal
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot; is &quot;</span></code>
</td>
</tr>
<tr>
<td>
Interpolation
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot;{}&quot;</span></code>
with expression <code class="sourceCode cpp">price</code>
</td>
</tr>
<tr>
<td>
String Literal
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot;.&quot;</span></code>
</td>
</tr>
</table>
<p>The first and last piece are always (possibly-empty) string literals
— for <code class="sourceCode cpp"><em>N</em></code> interpolations
there will be <code class="sourceCode cpp"><em>N</em><span class="op">+</span><span class="dv">1</span></code>
strings. Even for the template string <code class="sourceCode cpp">t<span class="st">&quot;{expr}&quot;</span></code>
which entirely consists of an expression, there will be two empty string
pieces.</p>
<p>However, C++ expressions can be arbitrary complicated. Notably, they
can also include
<code class="sourceCode cpp"><span class="op">:</span></code> or
<code class="sourceCode cpp"><span class="op">}</span></code>. both of
which are significant in formatting and indicate the end of the
expression. So how do we know when we’re done with the
<code class="sourceCode cpp"><em>expr</em></code> part here?</p>
<p>One approach would be to simply limit the kinds of expressions that
can appear in template strings. Rust, for instance, <em>only</em>
supports identifiers. That obviously makes parsing quite easy, but it
also is very limiting. On the other extreme, supporting <em>all</em>
expressions can easily lead to indecipherable code. I think on balance,
supporting only identifiers is far too restrictive. But once you start
adding what other kinds of expressions to allow (surely, at least class
member access), it quickly becomes too difficult to keep track of what
is allowed (indexing? function calls? splices?) and ironically makes
both the implementation more difficult (to enforce what is and isn’t
allowed) and harder to understand for the user (to know which
expressions are and aren’t allowed).</p>
<p>I think it’s best to simply allow anything in the expression (as
Python does) and trust the user to refactor their expressions to be as
legible as they desire. This allows us to take a very simple approach:
we simply lex <code class="sourceCode cpp"><em>expr</em></code> as a
balanced token sequence (just counting
<code class="sourceCode cpp"><span class="op">{}</span></code>s,
<code class="sourceCode cpp"><span class="op">()</span></code>s, and
<code class="sourceCode cpp"><span class="op">[]</span></code>s), so
that colons and braces inside of any of the bracket kinds are treated as
part of an expression. But the first
<code class="sourceCode cpp"><span class="op">:</span></code> or
<code class="sourceCode cpp"><span class="op">}</span></code>
encountered when we’re at a brace depth of zero means we’re done with
<code class="sourceCode cpp"><em>expr</em></code>.</p>
<p>Here are some examples of template string formatting calls and how
they would be evaluated. The first column will show a template string
that consists entirely of an expression. The second column will show how
the format string for that expression will be lexed and the third column
will show the expression.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>template string</strong>
</div></th>
<th><div style="text-align:center">
<strong>lexed format string</strong>
</div></th>
<th><div style="text-align:center">
<strong>lexed expression</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">t<span class="st">&quot;{x}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}&quot;</span></code></td>
<td><code class="sourceCode cpp">x</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">t<span class="st">&quot;{[]{ return 42; }()}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="op">[]{</span> <span class="cf">return</span> <span class="dv">42</span>; <span class="op">}()</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">t<span class="st">&quot;{co_await f(x) + g(y) / z}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="kw">co_await</span> f<span class="op">(</span>x<span class="op">)</span> <span class="op">+</span> g<span class="op">(</span>y<span class="op">)</span> <span class="op">/</span> z</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">t<span class="st">&quot;{a::b}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{::b}&quot;</span></code></td>
<td><code class="sourceCode cpp">a</code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">t<span class="st">&quot;{(a::b)}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}&quot;</span></code></td>
<td><code class="sourceCode cpp">a<span class="op">::</span>b</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">t<span class="st">&quot;{cond ? a : b}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{:b}&quot;</span></code></td>
<td><code class="sourceCode cpp">cond <span class="op">?</span> a</code>
❌</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">t<span class="st">&quot;{(cond ? a : b)}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="op">(</span>cond <span class="op">?</span> a <span class="op">:</span> b<span class="op">)</span></code></td>
</tr>
</tbody>
</table>
<p>Two important things to note here. First, it is possible to lex an
invalid expression due to finding a
<code class="sourceCode cpp"><span class="op">:</span></code> first, as
in the penultimate line. The lexing won’t know about this though.</p>
<p>Second, note that <code class="sourceCode cpp"><span class="st">&quot;{a::b}&quot;</span></code>
lexes as simply the expression <code class="sourceCode cpp">a</code>,
not <code class="sourceCode cpp">a<span class="op">::</span>b</code>. If
the latter is desired, it has to be parenthesized. That is, while
lexing, we are not simply looking for the <em>token</em>
<code class="sourceCode cpp"><span class="op">:</span></code>, but the
<em>character</em>
<code class="sourceCode cpp"><span class="op">:</span></code>. Which
could be the token
<code class="sourceCode cpp"><span class="op">:</span></code> but also
includes not just two-character tokens like
<code class="sourceCode cpp"><span class="op">::</span></code> and
<code class="sourceCode cpp"><span class="op">:]</span></code>, and even
the digraph
<code class="sourceCode cpp"><span class="op">:&lt;</span></code>
(e.g. <code class="sourceCode cpp"><span class="st">&quot;{a:&lt;5}&quot;</span></code>
lexes as the expression <code class="sourceCode cpp">a</code> with the
format specifier <code class="sourceCode cpp"><span class="op">&lt;</span><span class="dv">5</span></code>
— left-aligned with width
<code class="sourceCode cpp"><span class="dv">5</span></code> — not as
the incomplete expression <code class="sourceCode cpp">a<span class="op">[</span><span class="dv">5</span></code>).
This is a difference in the logic proposed in <span class="citation" data-cites="P3412R3"><a href="https://wg21.link/p3412r3" role="doc-biblioref">[P3412R3]</a></span>, which looks specifically for
the <em>token</em> (not character)
<code class="sourceCode cpp"><span class="op">:</span></code>. This is
important because it allows for the most functionality:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> v <span class="op">{</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">2</span>; <span class="op">}</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span><span class="op">}</span>;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>println<span class="op">(</span>t<span class="st">&quot;{v::x}&quot;</span><span class="op">)</span>;    <span class="co">// [a, 14, 1e]</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>println<span class="op">(</span>t<span class="st">&quot;{(v::x)}&quot;</span><span class="op">)</span>;  <span class="co">// 2</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>In order to format expressions that use scoping or the conditional
operator, you’ll just have to write parentheses. That seems easy enough
to both understand and use. Otherwise, anything goes.</p>
<p>Now, this approach incurs the burden that you just have to
parenthesize any expression with top-level scoping. But the benefit is
that all format specifiers just work — we have a formatting design that
is flexible, so it would be nice not restrict that. The logic laid out
in P3412 effectively forbids any format specifier that starts with a
<code class="sourceCode cpp"><span class="op">:</span></code> since that
<code class="sourceCode cpp"><span class="op">::</span></code> would
always be interpreted as a scope operator.</p>
<p>An alternative rule would: look for the character
<code class="sourceCode cpp"><span class="op">:</span></code>, unless
it’s the token
<code class="sourceCode cpp"><span class="op">::</span></code>,
<em>except</em> when it is immediately following a
<code class="sourceCode cpp"><span class="op">)</span></code>. That
would lead to this behavior:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>template string</strong>
</div></th>
<th><div style="text-align:center">
<strong>lexed format string</strong>
</div></th>
<th><div style="text-align:center">
<strong>lexed expression</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">t<span class="st">&quot;{a::b}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}&quot;</span></code></td>
<td><code class="sourceCode cpp">a<span class="op">::</span>b</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">t<span class="st">&quot;{(a)::b}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{::b}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="op">(</span>a<span class="op">)</span></code></td>
</tr>
</tbody>
</table>
<p>This raises the question of how to handle whitespace like <code class="sourceCode cpp">t<span class="st">&quot;{(a) ::b}&quot;</span></code>.
It’s a more complex rule, and it depends on how frequently we expect
top-level <code class="sourceCode cpp"><span class="op">::</span></code>
and how good the error recovery is. It might be worthwhile, since I
would expect top-level scoping to be significantly more common than
having a format specifier that starts with a colon. Note that
expressions like <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)::</span>b</code>
exist, which would have to be top-level parenthesized too, but that’s a
rare construction.</p>
<h2 data-number="2.2" id="handling-macro-expansion"><span class="header-section-number">2.2</span> Handling Macro Expansion<a href="#handling-macro-expansion" class="self-link"></a></h2>
<p>While lexing expressions, macro expansion occurs too (although at a
later phase, <a href="#more-formal-lexing-specification">see below</a>).
This is both what users expect and is important to support, otherwise
we’re not actually meeting the claim of supporting all expressions.
There are even standard utilities that are defined as macros, like
<code class="sourceCode cpp">errno</code>. The one thing to note is that
looking for the terminating
<code class="sourceCode cpp"><span class="op">:</span></code> or
<code class="sourceCode cpp"><span class="op">}</span></code> of an
expression will <em>not</em> consider such a character from macros.
Otherwise, the macros wouldn’t actually be usable properly and also the
format string itself would become illegible.</p>
<p>Extending the previous example:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> v <span class="op">{</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">2</span>; <span class="op">}</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span><span class="op">}</span>;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>println<span class="op">(</span>t<span class="st">&quot;{v::x}&quot;</span><span class="op">)</span>;    <span class="co">// [a, 14, 1e]</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>println<span class="op">(</span>t<span class="st">&quot;{(v::x)}&quot;</span><span class="op">)</span>;  <span class="co">// 2</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define SCOPED </span>v<span class="op">::</span>x</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>println<span class="op">(</span>t<span class="st">&quot;{SCOPED}&quot;</span><span class="op">)</span>;  <span class="co">// 2, not [a, 14, 1e]</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<h2 data-number="2.3" id="lexing-trailing-equals"><span class="header-section-number">2.3</span> Lexing Trailing Equals<a href="#lexing-trailing-equals" class="self-link"></a></h2>
<p>One nice debugging feature that Python’s f-strings (and template
strings) have is the equals suffix:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="ss">f&quot;</span><span class="sc">{</span>x<span class="op">=</span><span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>y<span class="op">=</span><span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>z<span class="op">=</span><span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;x=5, y=7, z=&#39;hello world&#39;&quot;</span></span></code></pre></div>
</blockquote>
</div>
<p>Concretely, an expression that ends with an
<code class="sourceCode cpp"><span class="op">=</span></code>
(surrounded by any amount of whitespace) has that suffix appended to the
previous string literal piece. Occasionally, there are requests to
support <code class="sourceCode cpp">std<span class="op">::</span>print<span class="op">(</span>x, y, z<span class="op">)</span></code>
to just concatenate those three elements — but that’s not as useful as
it initially seems since you quickly forget what variables you’re
printing in what order. The ability to support this on the other hand is
<em>very</em> useful for debugging:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>println<span class="op">(</span>t<span class="st">&quot;{x=}, {y=}, {z=:?}&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>It is also quite easy to implement, since it’s just a matter of
checking if the last lexed token of the expression was an
<code class="sourceCode cpp"><span class="op">=</span></code>. And, if
so, dropping that from the expression (since no valid C++ expression
ends with <code class="sourceCode cpp"><span class="op">=</span></code>)
and instead adding the stringified expression to the previous string
part.</p>
<p>Concretely: <code class="sourceCode cpp">t<span class="st">&quot;Hello {name=}&quot;</span></code>
behaves exactly equivalently to <code class="sourceCode cpp">t<span class="st">&quot;Hello name={name}&quot;</span></code>.</p>
<p>Note that this isn’t <em>quite</em> what Python does — as you might
notice from the Python example. In Python, it behaves like <code class="sourceCode cpp">t<span class="st">&quot;Hello name={name!r}</span></code>,
which is basically calling <code class="sourceCode cpp">repr<span class="op">(</span>name<span class="op">)</span></code>
instead of <code class="sourceCode cpp">str<span class="op">(</span>name<span class="op">)</span></code>.
It would be really nice if we actually had a real answer for debug
formatting — but neither
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
nor
<code class="sourceCode cpp">fmt<span class="op">::</span>format</code>
really have one. There is a
<code class="sourceCode cpp"><span class="op">?</span></code> specifier
which is used to help ensure that range formatting properly works (<span class="citation" data-cites="P2286R8"><a href="https://wg21.link/p2286r8" role="doc-biblioref">[P2286R8]</a></span>), but it’s not valid across
all types, and there’s no special handling for it. So we can’t really
make <code class="sourceCode cpp">t<span class="st">&quot;{name=}&quot;</span></code>
evaluate as <code class="sourceCode cpp">t<span class="st">&quot;name={name:?}&quot;</span></code>,
since that would only work for a small set of types. Instead, this paper
proposes not to add any format specifier here.</p>
<h2 data-number="2.4" id="lexing-nested-expressions"><span class="header-section-number">2.4</span> Lexing Nested Expressions<a href="#lexing-nested-expressions" class="self-link"></a></h2>
<p>Consider the template string:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>t<span class="st">&quot;{name:&gt;{width}}&quot;</span></span></code></pre></div>
</blockquote>
</div>
<p>There are two expressions here:
<code class="sourceCode cpp">name</code> and
<code class="sourceCode cpp">width</code>. Or rather, we know
<code class="sourceCode cpp">name</code> is an expression, but how do we
know that <code class="sourceCode cpp">width</code> is? In the format
model, the format specifiers can be <em>anything</em>. There really are
no rules — as long as the type’s formatter can handle it. Having nested
braces in a format specifier commonly refers to another argument, but it
need not actually mean that.</p>
<p>In my CppCon 2022 talk <a href="https://youtu.be/EQELdyecZlU?t=2397">The Surprising Complexity of
Formatting Ranges</a>, I work through an example of how one might add
underlying specifiers to
<code class="sourceCode cpp">std<span class="op">::</span>pair</code>
and
<code class="sourceCode cpp">std<span class="op">::</span>tuple</code>,
<a href="https://godbolt.org/z/vPfE7er3M">where</a>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> elems <span class="op">=</span> std<span class="op">::</span>tuple<span class="op">(</span><span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span><span class="op">)</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}</span><span class="sc">\n</span><span class="st">&quot;</span>, elems<span class="op">)</span>;                  <span class="co">// (10, 20, 30)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{:{x}{#x}{-^4}}</span><span class="sc">\n</span><span class="st">&quot;</span>, elems<span class="op">)</span>;     <span class="co">// (a, 0x14, -30-)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{:{x}{}{x}}</span><span class="sc">\n</span><span class="st">&quot;</span>, elems<span class="op">)</span>;         <span class="co">// (a, 20, 1e)</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>There, <code class="sourceCode cpp"><span class="op">{</span>x<span class="op">}</span></code>
doesn’t refer to the expression <code class="sourceCode cpp">x</code>,
it was just chosen as notational convenience. So how can we get this to
work?</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span>t<span class="st">&quot;{elems:{x}{}{x}}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>The short answer is: we cannot. We need to make sense of the template
string literal separate from type information, and even if we had type
information, it’s not like we have a way for the
<code class="sourceCode cpp">formatter</code> API to signal when it’s
expecting an expression. We just have to make a choice up front for what
to do here. I think we have three options:</p>
<ol type="1">
<li>We could explicitly opt <em>in</em> to a nested expression. That is,
maybe something like <code class="sourceCode cpp">t<span class="st">&quot;{elems:{x}{}${x}}&quot;</span></code>
signals that the first <code class="sourceCode cpp"><span class="op">{</span>x<span class="op">}</span></code>
is just a string but the second <code class="sourceCode cpp"><span class="op">{</span>x<span class="op">}</span></code>
is actually the expression <code class="sourceCode cpp">x</code>. So in
the above example, we simply wouldn’t use the
<code><span class="op">$</span></code>.</li>
<li>We could explicitly opt <em>out</em> of being a nested expression
with added escaping. Which in this case would be <code class="sourceCode cpp">t<span class="st">&quot;{elems:{{x}}{{}}{{x}}}&quot;</span></code>.</li>
<li>We could say that in a format specifier, encountering a
<code class="sourceCode cpp"><span class="op">{</span></code>
<em>always</em> begins an expression that ends at
<code class="sourceCode cpp"><span class="op">:</span></code> or
<code class="sourceCode cpp"><span class="op">}</span></code> (same as
top-level) and that there is neither opt-in nor opt-out. Meaning that
the approach to format specifiers that I demonstrated in that talk
wouldn’t work, and would instead have to be <code class="sourceCode cpp">t<span class="st">&quot;{elems:{:x}{}{:x}}&quot;</span></code>.</li>
</ol>
<p>I think the third option here is the best. It is at most a minor
burden on users as I doubt this approach is in widespread use, and
allows for a design that is as simple as possible.</p>
<p>Getting back to our original example:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>t<span class="st">&quot;{name:&gt;{width}}&quot;</span></span></code></pre></div>
</blockquote>
</div>
<p>This would lex as:</p>
<table>
<tr>
<td>
String Literal
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot;&quot;</span></code>
</td>
</tr>
<tr>
<td>
Interpolation
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot;{:&gt;{}}&quot;</span></code>
with two expressions: <code class="sourceCode cpp">name</code> and
<code class="sourceCode cpp">width</code>
</td>
</tr>
<tr>
<td>
String Literal
</td>
<td>
<code class="sourceCode cpp"><span class="st">&quot;&quot;</span></code>
</td>
</tr>
</table>
<p>And <a href="https://godbolt.org/z/r7rKdWMhb">this works</a> because
we recognize <code class="sourceCode cpp"><span class="op">{:</span>x<span class="op">}</span></code>
as not being a nested expression:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span>t<span class="st">&quot;as template: {elems:{:x}{}{:x}}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span>; <span class="co">// as template: (a, 20, 1e)</span></span></code></pre></div>
</blockquote>
</div>
<p>If we simply stored the expressions and the format string, that would
be straightforward: we just have two <a href="#data-members">data
members</a>. But we can do better than that. But before we get into the
<a href="#interpolation-information">interpolation information</a>, I’ll
talk about the data members.</p>
<h2 data-number="2.5" id="concatenating-consecutive-string-literals"><span class="header-section-number">2.5</span> Concatenating Consecutive
String Literals<a href="#concatenating-consecutive-string-literals" class="self-link"></a></h2>
<p>Consecutive string literals are concatenated during preprocessing.
The same should hold true for template string literals — which can be
concatenated with each other and also with regular string literals, in
any order. In the table below, imagine we are initializing a variable
<code class="sourceCode cpp">s</code> to the token sequence shown in the
first column and examining the resulting <code class="sourceCode cpp">s<span class="op">.</span>fmt<span class="op">()</span></code>
and the expressions being lexed:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Tokens</strong>
</div></th>
<th><div style="text-align:center">
<strong><code class="sourceCode cpp">s<span class="op">.</span>fmt<span class="op">()</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong>expressions</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="st">&quot;Hello, &quot;</span> <span class="st">&quot;World&quot;</span></code></td>
<td>n/a</td>
<td>n/a</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="st">&quot;Hello, &quot;</span> t<span class="st">&quot;{name}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;Hello, {}&quot;</span></code></td>
<td>1: <code class="sourceCode cpp">name</code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">t<span class="st">&quot;{greeting}, &quot;</span> t<span class="st">&quot;{name}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}, {}&quot;</span></code></td>
<td>2: <code class="sourceCode cpp">greeting</code>,
<code class="sourceCode cpp">name</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">t<span class="st">&quot;{greeting}, &quot;</span> <span class="st">&quot;World&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}, World&quot;</span></code></td>
<td>1: <code class="sourceCode cpp">greeting</code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">t<span class="st">&quot;{greeting}, &quot;</span> <span class="st">&quot;{}&quot;</span></code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;{}, {}&quot;</span></code></td>
<td>1: <code class="sourceCode cpp">greeting</code> ❌</td>
</tr>
</tbody>
</table>
<p>Note the last line. We’re concatenating a template string literal and
a regular string literal — that simply concatenates the contents of the
2nd string literal onto the last string piece of the 1st — there is no
implicit escaping of the braces, so the resulting format string would be
incomplete — it has 2 replacement fields but only one expression.</p>
<p>We could consider implicitly escaping the braces for regular string
literals that are concatenated to template string literals. I don’t know
if that’s a good idea though.</p>
<h2 data-number="2.6" id="data-members"><span class="header-section-number">2.6</span> Data Members<a href="#data-members" class="self-link"></a></h2>
<p>For any expression, <code class="sourceCode cpp"><em>E</em></code>
(including nested expressions — so there may be more expressions than
interpolations), a non-static data member will be generated (and then
initialized from <code class="sourceCode cpp"><em>E</em></code>) having
type <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">((</span><em>E</em><span class="op">))</span></code>.
This ensures that we get the right type, but also that we’re not copying
anything unnecessarily. For instance:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> verb<span class="op">()</span> <span class="op">-&gt;</span> std<span class="op">::</span>string;</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> example<span class="op">(</span>std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;</span> name, std<span class="op">::</span>string relation<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> tmpl <span class="op">=</span> t<span class="st">&quot;Hello, my name is {name:?}. You killed my {relation}. Prepare to {verb()}.&quot;</span>;</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>The object <code class="sourceCode cpp">tmpl</code> will have three
members:</p>
<ul>
<li>the first, corresponding to
<code class="sourceCode cpp">name</code>, has type <code class="sourceCode cpp">std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;</span></code></li>
<li>the second, corresponding to
<code class="sourceCode cpp">relation</code>, has type <code class="sourceCode cpp">std<span class="op">::</span>string<span class="op">&amp;</span></code></li>
<li>the third, corresponding to
<code class="sourceCode cpp">verb<span class="op">()</span></code>, has
type
<code class="sourceCode cpp">std<span class="op">::</span>string</code></li>
</ul>
<p>These are all public, non-static data members. If we want to copy all
of the members (e.g. because we want to serialize them), we can easily
do so. It’s just that there is no need for the template string itself to
do so directly. Note that the call to
<code class="sourceCode cpp">verb<span class="op">()</span></code>
happens immediately and the result is stored in
<code class="sourceCode cpp">tmpl</code>. We are not lazily holding onto
the expression
<code class="sourceCode cpp">verb<span class="op">()</span></code>.</p>
<p>This <em>does</em> open up the opportunity for dangling if you write
something like this:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> oops<span class="op">(</span><span class="dt">int</span> value<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> t<span class="st">&quot;{value}&quot;</span>; <span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>That template string object will have an <code class="sourceCode cpp"><span class="dt">int</span><span class="op">&amp;</span></code>
member, refer to the parameter that will be destroyed when we return
from the function. I don’t think this is a huge use-case of template
strings, but it’s something to keep in mind. The <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">((</span><em>E</em><span class="op">))</span></code>
logic is essential for ensuring no overhead for template strings in the
expected use-cases. We could consider something like a <em>leading</em>
<code class="sourceCode cpp"><span class="op">=</span></code> to capture
by value instead of by reference, but users can already write <code class="sourceCode cpp"><span class="st">&quot;t{auto(value)}&quot;</span></code>
there too.</p>
<h2 data-number="2.7" id="interpolation-information"><span class="header-section-number">2.7</span> Interpolation Information<a href="#interpolation-information" class="self-link"></a></h2>
<p>A template string will have a <code class="sourceCode cpp"><span class="kw">static</span> <span class="kw">consteval</span></code>
member function which returns objects of type <code class="sourceCode cpp">std<span class="op">::</span>interpolation</code>,
which is a simple aggregate with four members:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> interpolation <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> expression;</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt;</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> index;</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> count;</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p><code class="sourceCode cpp">expression</code> is a string literal
that is the stringified version of the expression (before macro
expansion). <code class="sourceCode cpp">fmt</code> is the full format
specifier with the expression removed, that you would need in order to
format this specific expression. Then, we need both
<code class="sourceCode cpp">index</code> and
<code class="sourceCode cpp">count</code> in order to support nested
replacement expressions, as we just went through. That gives us both the
first non-static data member and the amount of non-static data members
this interpolation is associated with.</p>
<p>The template string literal <code class="sourceCode cpp">t<span class="st">&quot;{name=:&gt;{width}}&quot;</span></code>
would generate the object</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <em>Template</em> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> fmt<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;name={:&gt;{}}&quot;</span>; <span class="op">}</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> num_interpolations<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">size_t</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span>; <span class="op">}</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> string<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> <span class="op">{</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> data<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;name=&quot;</span>, <span class="st">&quot;&quot;</span><span class="op">}</span>;</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> data<span class="op">[</span>n<span class="op">]</span>;</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> interpolation<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>interpolation <span class="op">{</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">consteval</span> std<span class="op">::</span>interpolation data<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>expression <span class="op">=</span> <span class="st">&quot;name&quot;</span>,  <span class="co">// note that &quot;name&quot; is preserved</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>fmt <span class="op">=</span> <span class="st">&quot;{:&gt;{}}&quot;</span>,       <span class="co">// but &quot;width&quot; is not</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>index <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>count <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}}</span>;</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> data<span class="op">[</span>n<span class="op">]</span>;</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;</span> <em>_0</em>;</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span> <em>_1</em>;</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>Why do we go through the trouble of proving <code class="sourceCode cpp">string<span class="op">(</span>n<span class="op">)</span></code>
and <code class="sourceCode cpp">interpolation<span class="op">(</span>n<span class="op">)</span></code>?
Let’s look at some examples…</p>
<h2 data-number="2.8" id="examples"><span class="header-section-number">2.8</span> Examples<a href="#examples" class="self-link"></a></h2>
<p>Consider again our example from earlier:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> tmpl <span class="op">=</span> t<span class="st">&quot;Hello, my name is {name}. You killed my {relation}. Prepare to {verb():*^{width}}.&quot;</span>;</span></code></pre></div>
</blockquote>
</div>
<p>I already showed how we could print this normally, which didn’t use
either of those two arrays:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> print<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>fmt<span class="op">()</span>, exprs<span class="op">...)</span>;</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>But we could do a lot more with this object other than just print it.
We could write a function to automatically highlight the interpolations
green and bold, which is supported by the
<code class="sourceCode cpp">fmt</code> library but not the standard.
That’s straightforward, since we’re not tied into any particular
library, and we have all the information we need:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> highlight_print<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> N <span class="op">=</span> s<span class="op">.</span>num_interpolations<span class="op">()</span>;</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="dt">int</span> I <span class="op">:</span> std<span class="op">::</span>views<span class="op">::</span>indices<span class="op">(</span>N<span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>string<span class="op">(</span>I<span class="op">))</span>;</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> interp <span class="op">=</span> s<span class="op">.</span>interpolation<span class="op">(</span>I<span class="op">)</span>;</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="op">[...</span>J<span class="op">]</span> <span class="op">=</span> std<span class="op">::</span>make_index_sequence<span class="op">&lt;</span>interp<span class="op">.</span>count<span class="op">&gt;()</span>;</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>fmt<span class="op">::</span>emphasis<span class="op">::</span>bold <span class="op">|</span> fg<span class="op">(</span>fmt<span class="op">::</span>color<span class="op">::</span>green<span class="op">)</span>,</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>                   interp<span class="op">.</span>fmt,</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>                   exprs<span class="op">...[</span>interp<span class="op">.</span>index <span class="op">+</span> J<span class="op">]...)</span>;</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>string<span class="op">(</span>N<span class="op">))</span>;</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Or we could turn it into the JSON object <code class="sourceCode cpp"><span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;Inigo Montoya&quot;</span>, <span class="st">&quot;relation&quot;</span><span class="op">:</span> <span class="st">&quot;father&quot;</span>, <span class="st">&quot;verb()&quot;</span><span class="op">:</span> <span class="st">&quot;die&quot;</span><span class="op">}</span></code>
for use as structured logging:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> into_json<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> boost<span class="op">::</span>json<span class="op">::</span>object <span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    boost<span class="op">::</span>json<span class="op">::</span>object o;</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="dt">int</span> I <span class="op">:</span> std<span class="op">::</span>views<span class="op">::</span>indices<span class="op">(</span>N<span class="op">))</span> <span class="op">{</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> interp <span class="op">=</span> s<span class="op">.</span>interpolation<span class="op">(</span>I<span class="op">)</span>;</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        o<span class="op">[</span>interp<span class="op">.</span>expression<span class="op">]</span> <span class="op">=</span> exprs<span class="op">...[</span>interp<span class="op">.</span>index<span class="op">]</span>;</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> o;</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Or we could use entirely different formatting mechanisms. We could
make this work with <code class="sourceCode cpp">printf</code> too! This
isn’t a complete implementation, but should give a sense of what’s
possible:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> with_printf<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt_string <span class="op">=</span> <span class="op">[&amp;]()</span> <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>string fmt <span class="op">=</span> s<span class="op">.</span>string<span class="op">(</span><span class="dv">0</span><span class="op">)</span>;</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> nsdms <span class="op">=</span> nonstatic_data_members_of<span class="op">(</span>remove_cvref<span class="op">(^^</span>S<span class="op">)</span>, std<span class="op">::</span>meta<span class="op">::</span>access_context<span class="op">::</span>current<span class="op">())</span>;</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span>; i <span class="op">&lt;</span> s<span class="op">.</span>num_interpolations<span class="op">()</span>; <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// in theory, this logic would be more interesting</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> interp <span class="op">=</span> s<span class="op">.</span>interpolation<span class="op">(</span>i<span class="op">)</span>;</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> type <span class="op">=</span> remove_cvref<span class="op">(</span>type_of<span class="op">(</span>nsdms<span class="op">[</span>interp<span class="op">.</span>index<span class="op">]))</span>;</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>type <span class="op">==</span> <span class="op">^^</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>                fmt <span class="op">+=</span> <span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>;</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>interp<span class="op">.</span>fmt <span class="op">==</span> std<span class="op">::</span>string_view<span class="op">(</span><span class="st">&quot;{:?}&quot;</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>                    fmt <span class="op">+=</span> <span class="st">&quot;</span><span class="sc">\&quot;%s\&quot;</span><span class="st">&quot;</span>;</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>                    fmt <span class="op">+=</span> <span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>;</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>            fmt <span class="op">+=</span> s<span class="op">.</span>string<span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> std<span class="op">::</span>define_static_string<span class="op">(</span>fmt<span class="op">)</span>;</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}()</span>;</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> adjust <span class="op">=</span> <span class="op">[]&lt;</span><span class="kw">class</span> T<span class="op">&gt;(</span>T <span class="kw">const</span><span class="op">&amp;</span> arg<span class="op">){</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>same_as<span class="op">&lt;</span>T, std<span class="op">::</span>string<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> arg<span class="op">.</span>c_str<span class="op">()</span>;</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> arg;</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="op">[...</span>Is<span class="op">]</span> <span class="op">=</span> std<span class="op">::</span>make_index_seequence<span class="op">&lt;</span>s<span class="op">.</span>num_interpolations<span class="op">()&gt;()</span>;</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>printf<span class="op">(</span>fmt_string, adjust<span class="op">(</span>exprs<span class="op">...[</span>s<span class="op">.</span>interpolation<span class="op">(</span>Is<span class="op">).</span>index<span class="op">])...)</span>;</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>The important thing is to expose all the relevant information to
users to let them do whatever they want with it. Note that
<code class="sourceCode cpp">highlighted_print</code> uses the
<code class="sourceCode cpp">fmt</code>,
<code class="sourceCode cpp">index</code>, and
<code class="sourceCode cpp">count</code> fields of the interpolation,
since it is formatting all of them, but not the
<code class="sourceCode cpp">expression</code> field. Meanwhile,
<code class="sourceCode cpp">into_json</code> uses only
<code class="sourceCode cpp">expression</code> and
<code class="sourceCode cpp">index</code> — it doesn’t need any of the
format specifier logic, since it isn’t actually doing formatting. The
<code class="sourceCode cpp">printf</code> example uses
<code class="sourceCode cpp">string</code> to build up its own format
specifier.</p>
<p>And of course, <em>all</em> of these operations can be performed on
the same object:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> verb<span class="op">()</span> <span class="op">-&gt;</span> std<span class="op">::</span>string <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;die&quot;</span>; <span class="op">}</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>string name <span class="op">=</span> <span class="st">&quot;Inigo Montoya&quot;</span>;</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> width <span class="op">=</span> <span class="dv">5</span>;</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> msg <span class="op">=</span> t<span class="st">&quot;Hello, my name is {name:?}. You killed my {relation}. Prepare to {verb():*^{width}}.</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>msg<span class="op">)</span>;</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    highlighted_print<span class="op">(</span>msg<span class="op">)</span>;</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;{}&quot;</span>, into_json<span class="op">(</span>msg<span class="op">))</span>;</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    with_printf<span class="op">(</span>msg<span class="op">)</span>;</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>will print (note that
<code class="sourceCode cpp">highlighted_print</code> uses the format
specifiers, so the name is quoted):</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb32"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>Hello, my name is &quot;Inigo Montoya&quot;. You killed my father. Prepare to *die*.</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>Hello, my name is <span style="color:green;font-weight:bold">“Inigo Montoya”</span>. You killed my <span style="color:green;font-weight:bold">father</span>. Prepare to <span style="color:green;font-weight:bold">*die*</span>.</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>{&quot;name&quot;:&quot;Inigo Montoya&quot;,&quot;relation&quot;:&quot;father&quot;,&quot;verb()&quot;:&quot;die&quot;}</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>Hello, my name is &quot;Inigo Montoya&quot;. You killed my father. Prepare to die.</span></code></pre></div>
</blockquote>
</div>
<p>Having both
<code class="sourceCode cpp">interp<span class="op">.</span>index</code>
and
<code class="sourceCode cpp">interp<span class="op">.</span>count</code>
is a little clunky, especially since
<code class="sourceCode cpp">interp<span class="op">.</span>count</code>
will almost always be
<code class="sourceCode cpp"><span class="dv">1</span></code>. But I
think it’s better to put the clunkiness there and maintain the trivial
formatting implementations (where you can just unpack the template
string object).</p>
<p>You can see this example on <a href="https://compiler-explorer.com/z/hKer7vE9r">compiler explorer</a>.
Note that the implementations there are slightly different, since Clang
doesn’t yet implement
<code class="sourceCode cpp"><span class="kw">constexpr</span></code>
structured bindings and the implementations of pack indexing and
expansion statements had a few bugs so I came up with workarounds.</p>
<h2 data-number="2.9" id="the-templatestring-concept"><span class="header-section-number">2.9</span> The
<code class="sourceCode cpp">TemplateString</code> Concept<a href="#the-templatestring-concept" class="self-link"></a></h2>
<p>In these examples, I’ve been using this
<code class="sourceCode cpp">TemplateString</code> concept to identify a
template string object. The question is, what does that concept look
like? This one I’m not sure about yet. It can’t be a built-in, since
users might need to create one of these objects. Consider a logger:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>log<span class="op">::</span>info<span class="op">(</span>t<span class="st">&quot;Got a trade for in {symbol}: {side} {qty} @ {price}&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>The expressions here are all cheap to copy, but formatting is
expensive — so I might want to serialize all of the data into a
background thread to do my formatting there. I don’t want to just copy
the template string object, since it might have references. With
reflection, I can create a new type that has only value members, and
then keep the same <code class="sourceCode cpp">fmt</code>,
<code class="sourceCode cpp">strings</code>, and
<code class="sourceCode cpp">interpolations</code>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S, <span class="kw">class</span> F<span class="op">&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> map<span class="op">(</span>S s, F f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Base;</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>meta<span class="op">::</span>info<span class="op">&gt;</span> specs;</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>meta<span class="op">::</span>info m <span class="op">:</span> nonstatic_data_members_of<span class="op">(^^</span>S<span class="op">))</span> <span class="op">{</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>            specs<span class="op">.</span>push_back<span class="op">(</span>data_member_spec<span class="op">({</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>type<span class="op">=</span>invoke_result<span class="op">(^^</span>F, <span class="op">{</span>type_of<span class="op">(</span>m<span class="op">)})</span>,</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>name<span class="op">=</span>identifier_of<span class="op">(</span>m<span class="op">)</span>,</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}))</span>;</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>        define_aggregate<span class="op">(^^</span>Base, specs<span class="op">)</span>;</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> R <span class="op">:</span> Base <span class="op">{</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> fmt <span class="op">=</span> S<span class="op">::</span>fmt;</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> string <span class="op">=</span> S<span class="op">::</span>string;</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> interpolation <span class="op">=</span> S<span class="op">::</span>interpolation;</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> num_interpolations <span class="op">=</span> S<span class="op">::</span>num_interpolations;</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>pieces<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> R<span class="op">{{</span>f<span class="op">(</span>FWD<span class="op">(</span>pieces<span class="op">))...}}</span>;</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Which allows the implementation of all of the logging functions to
<code class="sourceCode cpp">map</code> their provided template string
object to decay or otherwise transform every member into something that
won’t dangle.</p>
<p>I’d want to make sure this <code class="sourceCode cpp">R</code> here
is also considered a template string for all of these purposes. There
are a few options here, not really sure which would be best:</p>
<ul>
<li>an attribute</li>
<li>an annotation</li>
<li>structural conformance: simply check for the presence of
<code class="sourceCode cpp">fmt</code>,
<code class="sourceCode cpp">string</code>,
<code class="sourceCode cpp">num_interpolations</code>, and
<code class="sourceCode cpp">interpolation</code>?</li>
</ul>
<h2 data-number="2.10" id="implementation-experience"><span class="header-section-number">2.10</span> Implementation Experience<a href="#implementation-experience" class="self-link"></a></h2>
<p>I implemented this in Clang, on top of the p2996 reflection branch.
Code can be found in my fork in the
<code><span class="op">template-strings</span></code> branch <a href="https://github.com/brevzin/llvm-project/tree/template-strings">here</a>
(you can see the diff against p2996 <a href="https://github.com/bloomberg/clang-p2996/compare/p2996...brevzin:llvm-project:template-strings">here</a>)
I’m sure there are better ways to do some of what I did. It can also be
used on <a href="https://compiler-explorer.com/z/hKer7vE9r">compiler
explorer</a>.</p>
<p>The only difference between this paper and the implementation is that
instead of introducing the type <code class="sourceCode cpp">std<span class="op">::</span>interpolation</code>,
I just made <code class="sourceCode cpp">_Interpolation</code>
implicitly defined at global scope for convenience.</p>
<p>This does raise the question of how <code class="sourceCode cpp">std<span class="op">::</span>interpolation</code>
should be defined. Should this facility really require a new header?
Maybe it’s a sufficiently trivial type (an aggregate with no member
functions and just four data members, each of scalar type) that the
compiler can just generate it? Maybe we don’t care about additional
headers because
<code class="sourceCode cpp"><span class="kw">import</span> std;</code>
anyway?</p>
<p>The same question goes for if we want to implement the <a href="#the-templatestring-concept">concept</a> by way of annotation.
That annotation would be an empty type, could the compiler just create
it?</p>
<h2 data-number="2.11" id="more-formal-lexing-specification"><span class="header-section-number">2.11</span> More Formal Lexing
Specification<a href="#more-formal-lexing-specification" class="self-link"></a></h2>
<p>In Clang, preprocessing happens during lexing — and so the way I
implemented it was that a template string lexes as a new kind of token —
really a meta-token that itself contains a bunch of other tokens. That’s
fine as far as Clang goes (or maybe not, there might be a more preferred
approach), but the standard defines the phases of translation (<span>5.2
<a href="https://wg21.link/lex.phases">[lex.phases]</a></span>) in a
strict order. Specifically:</p>
<ul>
<li>Phase 3: Source file decomposed into preprocessing tokens</li>
<li>Phase 4: Preprocessing directives and macro expansion occurs</li>
<li>Phase 5: String-literal encoding and concatenation</li>
<li>Phase 6: Tokens</li>
<li>Phase 7: The rest of the owl</li>
</ul>
<p>The wording needs to fit this specification. Which we can do by
defining a new set of preprocessing tokens. For example, the template
string</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>t<span class="st">&quot;My name is {name():&gt;{width}}.</span><span class="sc">\n</span><span class="st">&quot;</span></span></code></pre></div>
</blockquote>
</div>
<p>can lex into the tokens (indentation for clarity):</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><em>template-string-begin</em></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;My name is &quot;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-begin</em></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;{:&gt;{}}&quot;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    ,</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;name()&quot;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-begin</em></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;name&quot;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-end</em></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-begin</em></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;width&quot;</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-end</em></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-end</em></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a><em>template-string-end</em></span></code></pre></div>
</blockquote>
</div>
<p>That is, we have a bunch of meta-tokens that don’t lead to any output
and are just there to guide parsing. A template string literal lexes
into this alternating sequence of
<code class="sourceCode cpp"><em>string-literal</em></code>s and
interpolations. An interpolation is bounded by <code class="sourceCode cpp"><em>template-string-interpolation-begin</em></code>
and
<code class="sourceCode cpp"><em>template-string-interpolation-end</em></code>,
starts with two
<code class="sourceCode cpp"><em>string-literal</em></code>s for the
format string and expression (with a separator token just to avoid
string concatenation from kicking in — I used
<code class="sourceCode cpp">,</code> above but the actual separator
doesn’t matter), and then continues with at least one expression. An
expression is bounded by
<code class="sourceCode cpp"><em>template-string-expression-begin</em></code>
and
<code class="sourceCode cpp"><em>template-string-expression-end</em></code>.</p>
<p>To handle <a href="#lexing-trailing-equals">trailing
<code class="sourceCode cpp"><span class="op">=</span></code></a>, we
could go one of two ways. Consider just <code class="sourceCode cpp">t<span class="st">&quot;Got {x = }.&quot;</span></code>.
That could be either:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Pre-emptively append</strong>
</div></th>
<th><div style="text-align:center">
<strong>Delayed concat</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><em>template-string-begin</em></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;Got x = &quot;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-begin</em></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;{}&quot;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    ,</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;x&quot;</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-begin</em></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;name&quot;</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-end</em></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-end</em></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;.&quot;</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><em>template-string-end</em></span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><em>template-string-begin</em></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;Got &quot;</span> <span class="co">// the initial string</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;x = &quot;</span> <span class="co">// expression with trailing =</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-begin</em></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;{}&quot;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    ,</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;x&quot;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-begin</em></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;name&quot;</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-end</em></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-end</em></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;.&quot;</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><em>template-string-end</em></span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>It works either way. With delayed concatenation, we rely on phase 5
to concatenate the string literals before parsing anyway.</p>
<p>We could conceivably also just introduce a single token and use
braces for everything else. Though probably better to ues something
other than braces to make it easier to diagnose poorly formatted
expressions? Whatever people prefer:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Several tokens for clarity</strong>
</div></th>
<th><div style="text-align:center">
<strong>Just one token</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><em>template-string-begin</em></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;My name is &quot;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-begin</em></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;{:&gt;{}}&quot;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    ,</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;name()&quot;</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-begin</em></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;name&quot;</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-end</em></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-begin</em></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;width&quot;</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    <em>template-string-expression-end</em></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>  <em>template-string-interpolation-end</em></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><em>template-string-end</em></span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><em>template-string</em></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;My name is &quot;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;{:&gt;{}}&quot;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    ,</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <em>string-literal</em> <span class="st">&quot;name()&quot;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;name&quot;</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>      <em>identifier</em> <span class="st">&quot;width&quot;</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>  <em>string-literal</em> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="alternate-approaches"><span class="header-section-number">3</span>
Alternate Approaches<a href="#alternate-approaches" class="self-link"></a></h1>
<p>This proposal is definitely not the only way to do string
interpolation in C++. I’ve <a href="#prior-work">already discussed</a>
two previous proposals in this space and why I think what I’m proposing
is a better design. But it’s worth talking about other approaches as
well.</p>
<h2 data-number="3.1" id="f-strings"><span class="header-section-number">3.1</span>
<code class="sourceCode cpp">f</code>-strings<a href="#f-strings" class="self-link"></a></h2>
<p>This paper <em>only</em> proposes template strings, it does
<em>not</em> propose a convenient shorthand for creating a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>.
If a
<code class="sourceCode cpp">std<span class="op">::</span>string</code>
is desired, the user will have to write:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a <span class="op">=</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;My name is {} and my age next year is {}&quot;</span>, name, age<span class="op">+</span><span class="dv">1</span><span class="op">)</span>; <span class="co">// status quo</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> b <span class="op">=</span> std<span class="op">::</span>format<span class="op">(</span>t<span class="st">&quot;My name is {name} and my age next year is {age+1}&quot;</span><span class="op">)</span>;    <span class="co">// proposed</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> c <span class="op">=</span> f<span class="st">&quot;My name is {name} and my age next year is {age+1}&quot;</span>;                 <span class="co">// not proposed</span></span></code></pre></div>
</blockquote>
</div>
<p>The reasoning here is that moving from
<code class="sourceCode cpp">a</code> to
<code class="sourceCode cpp">b</code> is a significant gain in
readability (as well as other functionality, as illustrated in previous
examples), but the gain from <code class="sourceCode cpp">b</code> to
<code class="sourceCode cpp">c</code> is simply saving a few characters.
It’s <em>nice</em>, but it comes at a heavy cost that I’m simply not
sure is actually worth it. Is
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
specifically the most common formatting facility? I think small programs
will have more calls to
<code class="sourceCode cpp">std<span class="op">::</span>print</code>
or
<code class="sourceCode cpp">std<span class="op">::</span>println</code>
while larger programs will have more calls to <code class="sourceCode cpp">std<span class="op">::</span>format_to</code> as
well as use logging. I just don’t think the trade-off is there.</p>
<h2 data-number="3.2" id="reduced-representation"><span class="header-section-number">3.2</span> Reduced Representation<a href="#reduced-representation" class="self-link"></a></h2>
<p>What should this template string literal evaluate to?</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>t<span class="st">&quot;New connection on {ip:#x}:{port}&quot;</span></span></code></pre></div>
</blockquote>
</div>
<p>This paper proposes the one on the left, but we could just do the one
on the right:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Proposed</strong>
</div></th>
<th><div style="text-align:center">
<strong>Simpler</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> fmt<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> num_interpolations<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">size_t</span>;</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> string<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> interpolation<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> interpolation;</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  u32 _0;</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  u16 _1;</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> fmt<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>  u32 _0;</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>  u16 _1;</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>But the main motivation (and likely the most common use-case) is some
version of formatting, for which all we need is <code class="sourceCode cpp">S<span class="op">::</span>fmt<span class="op">()</span></code>.
We wouldn’t need <code class="sourceCode cpp">S<span class="op">::</span>interpolation<span class="op">(</span>n<span class="op">)</span></code>
or <code class="sourceCode cpp">S<span class="op">::</span>string<span class="op">(</span>n<span class="op">)</span></code>.
Should we still generate the extra functions?</p>
<p>I would argue that we should. The implementation has to do all the
work to get those pieces anyway (with the exception of the
<code class="sourceCode cpp">index</code> and
<code class="sourceCode cpp">count</code> members for each
<code class="sourceCode cpp">interpolation</code>, which really isn’t
much work), so it’s not like we’re saving much in the way of computation
by stripping the interface. The simpler interface is only simple in that
it reduces the available functionality. Doesn’t seem like a good
idea.</p>
<h2 data-number="3.3" id="redundant-information"><span class="header-section-number">3.3</span> Redundant Information<a href="#redundant-information" class="self-link"></a></h2>
<p>Continuing with the previous example, what if instead of removing
<code class="sourceCode cpp">S<span class="op">::</span>string</code>
and <code class="sourceCode cpp">S<span class="op">::</span>interpolation</code>,
we instead removed
<code class="sourceCode cpp">S<span class="op">::</span>fmt</code>?</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Proposed</strong>
</div></th>
<th><div style="text-align:center">
<strong>Minimal</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> fmt<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> num_interpolations<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">size_t</span>;</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> string<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> interpolation<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> interpolation;</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>  u32 _0;</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>  u16 _1;</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> num_interpolations<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">size_t</span>;</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> string<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> interpolation<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> interpolation;</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>  u32 _0;</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>  u16 _1;</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>Note that <code class="sourceCode cpp">S<span class="op">::</span>fmt<span class="op">()</span></code>
is exactly the result of concatenating <code class="sourceCode cpp">S<span class="op">::</span>string<span class="op">(</span><span class="dv">0</span><span class="op">)</span></code>,
<code class="sourceCode cpp">S<span class="op">::</span>interpolation<span class="op">(</span><span class="dv">0</span><span class="op">).</span>fmt</code>,
<code class="sourceCode cpp">S<span class="op">:::</span>string<span class="op">(</span><span class="dv">1</span><span class="op">)</span></code>,
<code class="sourceCode cpp">S<span class="op">::</span>interpolation<span class="op">(</span><span class="dv">1</span><span class="op">).</span>fmt</code>,
and <code class="sourceCode cpp">S<span class="op">::</span>string<span class="op">(</span><span class="dv">2</span><span class="op">)</span></code>.
This is true by construction for all template strings, and is precisely
how it is implemented as well. Given that <code class="sourceCode cpp">S<span class="op">::</span>string<span class="op">(</span>n<span class="op">)</span></code>
and <code class="sourceCode cpp">S<span class="op">::</span>interpolation<span class="op">(</span>n<span class="op">)</span></code>
will both exist (as being more fundamental), do we need to also provide
<code class="sourceCode cpp">S<span class="op">::</span>fmt<span class="op">()</span></code>
— which can simply be derived from both arrays?</p>
<p>One advantage of removing <code class="sourceCode cpp">S<span class="op">::</span>fmt<span class="op">()</span></code>
is to avoid having that string spill into the binary even if unused, if
the implementation simply fails to detect its lack of use. However, I
think we should. While formatting will not be the <em>only</em> usage of
these objects, it is both the main motivating and primary one, so it
will both be more convenient for users and more efficient if the
compiler simply does that little bit of extra work to produce the full
format string as well.</p>
<p>And regardless, the opposite problem would still exist anyway — if
only <code class="sourceCode cpp">S<span class="op">::</span>fmt<span class="op">()</span></code>
were used, there is the potential that the string literals in <code class="sourceCode cpp">S<span class="op">::</span>string<span class="op">(</span>n<span class="op">)</span></code>
and <code class="sourceCode cpp">S<span class="op">::</span>interpolation<span class="op">(</span>n<span class="op">)</span></code>
spill into the binary unnecessary as well.</p>
<h2 data-number="3.4" id="static-data-members-or-static-member-functions"><span class="header-section-number">3.4</span> Static Data Members or Static
Member Functions<a href="#static-data-members-or-static-member-functions" class="self-link"></a></h2>
<p>The proposal right now has 4 static member functions. But a simple
alternative would be to instead provide three, with
<code class="sourceCode cpp">strings<span class="op">()</span></code>
and <code class="sourceCode cpp">interpolations<span class="op">()</span></code>
returning
<code class="sourceCode cpp">std<span class="op">::</span>span</code>s
instead of having a <code class="sourceCode cpp">string<span class="op">(</span>n<span class="op">)</span></code>
and <code class="sourceCode cpp">interpolation<span class="op">(</span>n<span class="op">)</span></code>
and <code class="sourceCode cpp">num_interpolations<span class="op">()</span></code>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> fmt<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> strings<span class="op">()</span> <span class="op">-&gt;</span> std<span class="op">::</span>span<span class="op">&lt;</span><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> <span class="kw">const</span><span class="op">&gt;</span>;</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> interpolations<span class="op">()</span> <span class="op">-&gt;</span> std<span class="op">::</span>span<span class="op">&lt;</span>std<span class="op">::</span>interpolation <span class="kw">const</span><span class="op">&gt;</span>;</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>The advantage of approach is that it allows directly looping over the
interpolations via:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> interp <span class="op">:</span> s<span class="op">.</span>interpolations<span class="op">())</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Which instead some of the <a href="#examples">examples</a> work
around via:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> I <span class="op">:</span> std<span class="op">::</span>views<span class="op">::</span>indices<span class="op">(</span>s<span class="op">.</span>num_interpolations<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> interp <span class="op">=</span> s<span class="op">.</span>interpolation<span class="op">(</span>I<span class="op">)</span>;</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>The disadvantage is that it brings in the
<code class="sourceCode cpp">std<span class="op">::</span>span</code>
dependency. But if we’re declaring <code class="sourceCode cpp">std<span class="op">::</span>interpolation</code>
anyway, that’s probably not that big a deal.</p>
<p>A very different shape might instead be to have static <em>data
members</em> instead of static functions, where:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt <span class="op">=</span> <span class="co">/* ... */</span>;</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> strings<span class="op">[]</span> <span class="op">=</span> <span class="co">/* ... */</span>;</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> std<span class="op">::</span>interpolation interpolations<span class="op">[]</span> <span class="op">=</span> <span class="co">/* ... */</span>;</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>This would avoid the <code class="sourceCode cpp">span</code>
dependency and avoid a bunch of parentheses that you would have to
write, as compared to the other function version. However, it has two
problems. First, a template string can have no interpolations, and we
still don’t have zero-sized arrays in C++. We ran into this problem with
specifying <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>reflect_constant_array</code>,
and it’s very annoying that it doesn’t just work (even as gcc and clang
happily support them with expected semantics with no warnings). Neither
the version where <code class="sourceCode cpp">interpolations<span class="op">()</span></code>
returns a
<code class="sourceCode cpp">std<span class="op">::</span>span</code>
nor the version where we have <code class="sourceCode cpp">interpolation<span class="op">(</span>n<span class="op">)</span></code>
which returns the <code class="sourceCode cpp">n</code>th interpolation
have this problem.</p>
<p>The second problem is that these types may have to be local types in
some contexts, and local types cannot have static data members in C++. I
do not know why local types have this restriction, given that local
types are allowed to have static member functions and those member
functions are allowed to have static local variables. But the
restriction does currently exist.</p>
<h2 data-number="3.5" id="wait-for-reflection"><span class="header-section-number">3.5</span> Wait for Reflection<a href="#wait-for-reflection" class="self-link"></a></h2>
<p>The evergreen question with proposals like this is to wonder if we
should wait for reflection. There even is a proposal, <span class="title"><span class="citation" data-cites="P3294R2"><a href="https://wg21.link/p3294r2" role="doc-biblioref">[P3294R2] (Code
Injection with Token Sequences)</a></span></span>, that has walks
through how a future macro could solve this problem. Concretely, we
would need:</p>
<ul>
<li>macros that can inject token sequences,</li>
<li>the ability to invoke such a macro with a string literal (or
<code class="sourceCode cpp">string_view</code>), and</li>
<li>the ability to turn a
<code class="sourceCode cpp">string_view</code> into a token
sequence</li>
</ul>
<p>Given those pieces, the implementation of something like Rust’s
<code class="sourceCode cpp">format_args<span class="op">!</span></code>
is basically the same as how you would implement it in a compiler. And
the benefit of being able to do this in a library is pretty clear: it is
much easier to experiment with different functionality. Plus, this would
just be a very small taste of what code injections could do.</p>
<p>So should we wait? It seems incredibly unlikely that we will land
something as expansive as token sequence injection in C++29 (if ever?),
and a dedicated language feature for template string objects is pretty
small and self-contained.</p>
<h2 data-number="3.6" id="object-vs-expression-list"><span class="header-section-number">3.6</span> Object vs Expression-List<a href="#object-vs-expression-list" class="self-link"></a></h2>
<p>As I mentioned earlier, P3412 is really two language features: a
string interpolation feature whose intermediate representation is an
expression-list, and a feature which just calls
<code class="sourceCode cpp">std<span class="op">::</span>format</code>
on that expression-list. In contrast, this paper is a string
interpolation feature whose intermediate representation is an object.
How do those two intermediate representations compare?</p>
<p>When it comes to formatting specifically — when the sink algorithm is
<code class="sourceCode cpp">std<span class="op">::</span>print</code>
or <code class="sourceCode cpp">std<span class="op">::</span>format_to</code> or
<code class="sourceCode cpp">spdlog<span class="op">::</span>info</code>
or anything like that — the object approach is pure overhead. Being able
to write <code class="sourceCode cpp">spdlog<span class="op">::</span>info<span class="op">(</span>f<span class="st">&quot;x={x}&quot;</span><span class="op">)</span></code>
and have that evaluate exactly as <code class="sourceCode cpp">spdlog<span class="op">::</span>info<span class="op">(</span><span class="st">&quot;x={}&quot;</span>, x<span class="op">)</span></code>
means that no library change is necessary whatsoever in order for
libraries to “adopt” string interpolation. You can’t beat zero work.
With this paper, there would have to be library opt-in. Those opt-ins
are going to be very simple — mostly two liners as you can see from the
<code class="sourceCode cpp">print</code> implementation <a href="#examples">earlier</a> — but they still have to exist.</p>
<p>So is it worth the added complexity of the object model to justify
the added cost of the interpolation opt-in? We have to talk about the
added functionality.</p>
<p>Because the object approach preserves all the information in the
original format string, you can do things like structured logging (as in
the JSON example from earlier). The expression-list approach simply
doesn’t have the “names” of the expressions anymore, so they’re not
available for further use.</p>
<p>But almost anything else you might want to do with the interpolated
string that isn’t precisely formatting is much easier when you have an
object. It’s actually still surprising to me that some of these things
are even possible, but let’s walk through some examples. For logging, I
might want to also include the file/line number as part of the message.
I have this information available at compile-time along with the format
string, so it’d be nice to concatenate those together. That’s
possible:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression-list (P3412)</strong>
</div></th>
<th><div style="text-align:center">
<strong>Object (this paper)</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> fmt_string_sloc <span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt;</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> S<span class="op">&gt;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">requires</span> std<span class="op">::</span>convertible_to<span class="op">&lt;</span>S, std<span class="op">::</span>string_view<span class="op">&gt;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> fmt_string_sloc<span class="op">(</span>S s,</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>                              std<span class="op">::</span>source_location sloc <span class="op">=</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>                                std<span class="op">::</span>source_location<span class="op">::</span>current<span class="op">())</span> <span class="op">{</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// have to do type-checking here</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span> <span class="kw">auto</span> _ <span class="op">=</span> std<span class="op">::</span>format_string<span class="op">&lt;</span>Args<span class="op">...&gt;(</span>s<span class="op">)</span>;</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>fmt <span class="op">=</span> std<span class="op">::</span>define_static_string<span class="op">(</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>          std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;[{}:{}] {}&quot;</span>,</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>                      sloc<span class="op">.</span>file_name<span class="op">()</span>,</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>                      sloc<span class="op">.</span>line<span class="op">()</span>,</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>                      std<span class="op">::</span>string_view<span class="op">(</span>s<span class="op">)))</span>;</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> print_sloc1<span class="op">(</span>fmt_string_sloc<span class="op">&lt;</span>std<span class="op">::</span>type_identity_t<span class="op">&lt;</span>Args<span class="op">&gt;...&gt;</span> fmt,</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>                Args<span class="op">&amp;&amp;...</span> args<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>std<span class="op">::</span>runtime_format<span class="op">(</span>fmt<span class="op">.</span>fmt<span class="op">)</span>, args<span class="op">...)</span>;</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>template_string S<span class="op">&gt;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> print_sloc2<span class="op">(</span>S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> fmt <span class="op">=</span> <span class="op">[]{</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> T <span class="op">=</span> std<span class="op">::</span>remove_cvref_t<span class="op">&lt;</span>S<span class="op">&gt;</span>;</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sloc <span class="op">=</span> source_location_of<span class="op">(^^</span>T<span class="op">)</span>;</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> std<span class="op">::</span>define_static_string<span class="op">(</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>          std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;[{}:{}] {}&quot;</span>,</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>                      sloc<span class="op">.</span>file_name<span class="op">()</span>,</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>                      sloc<span class="op">.</span>line<span class="op">()</span>,</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>                      T<span class="op">::</span>fmt<span class="op">()))</span>;</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}()</span>;</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type-checking happens out here as usual</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// since fmt is a constant</span></span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span>fmt, exprs<span class="op">...)</span>;</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>We cannot provide the source location as a parameter to
<code class="sourceCode cpp">print_sloc1</code>, because it’s a variadic
function template. And even if we could, it couldn’t be a constant.
However, we can be clever and provide it as a defaulted parameter to to
the consteval constructor of the non-deduced
<code class="sourceCode cpp">fmt_string_sloc</code>. With the object, we
can just directly get the source location of the string interpolation
type.</p>
<p>This difference in complexity goes up really fast once you start
doing more interesting things. Consider the
<code class="sourceCode cpp">highlight_print</code> example from
earlier. This is actually <a href="https://compiler-explorer.com/z/b6jdavTW1">implementable</a> in
the expression-list model, but not easily:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression-list (P3412)</strong>
</div></th>
<th><div style="text-align:center">
<strong>Object (this paper)</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Interpolation <span class="op">{</span> <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> fmt; <span class="dt">int</span> index; <span class="dt">int</span> count; <span class="op">}</span>;</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Information <span class="op">{</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> num_interpolations;</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> <span class="kw">const</span><span class="op">*</span> strings;</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    Interpolation <span class="kw">const</span><span class="op">*</span> interpolations;</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>Information Info, <span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> highlight_print_impl<span class="op">(</span>fmt<span class="op">::</span>text_style style, Args<span class="op">&amp;&amp;...</span> exprs<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> N <span class="op">=</span> Info<span class="op">.</span>num_interpolations;</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="dt">int</span> I <span class="op">:</span> std<span class="op">::</span>views<span class="op">::</span>indices<span class="op">(</span>N<span class="op">))</span> <span class="op">{</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>Info<span class="op">.</span>strings<span class="op">[</span>I<span class="op">])</span>;</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> interp <span class="op">=</span> Info<span class="op">.</span>interpolations<span class="op">[</span>I<span class="op">]</span>;</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="op">[...</span>J<span class="op">]</span> <span class="op">=</span> std<span class="op">::</span>make_index_sequence<span class="op">&lt;</span>interp<span class="op">.</span>count<span class="op">&gt;()</span>;</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>style,</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>                   interp<span class="op">.</span>fmt,</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>                   exprs<span class="op">...[</span>interp<span class="op">.</span>index <span class="op">+</span> J<span class="op">]...)</span>;</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span>Info<span class="op">.</span>strings<span class="op">[</span>N<span class="op">])</span>;</span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> parse_next_impl<span class="op">(</span>fmt<span class="op">::</span>parse_context<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&amp;</span> ctx<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>formatter<span class="op">&lt;</span>T<span class="op">&gt;</span> f;</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> cur <span class="op">=</span> ctx<span class="op">.</span>begin<span class="op">()</span>;</span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>cur <span class="op">==</span> <span class="ch">&#39;:&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>cur;</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>    ctx<span class="op">.</span>advance_to<span class="op">(</span>cur<span class="op">)</span>;</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>ctx<span class="op">.</span>next_arg_id<span class="op">()</span>;</span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>    cur <span class="op">=</span> f<span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>cur <span class="op">!=</span> ctx<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>cur;</span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-39"><a href="#cb53-39" aria-hidden="true" tabindex="-1"></a>    ctx<span class="op">.</span>advance_to<span class="op">(</span>cur<span class="op">)</span>;</span>
<span id="cb53-40"><a href="#cb53-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-41"><a href="#cb53-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-42"><a href="#cb53-42" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb53-43"><a href="#cb53-43" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="kw">auto</span> into_interpolation_info<span class="op">(</span>std<span class="op">::</span>string_view sv<span class="op">)</span></span>
<span id="cb53-44"><a href="#cb53-44" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> std<span class="op">::</span>meta<span class="op">::</span>info</span>
<span id="cb53-45"><a href="#cb53-45" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb53-46"><a href="#cb53-46" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>detail<span class="op">::</span>type types<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb53-47"><a href="#cb53-47" aria-hidden="true" tabindex="-1"></a>      fmt<span class="op">::</span>detail<span class="op">::</span>mapped_type_constant<span class="op">&lt;</span>Ts, <span class="dt">char</span><span class="op">&gt;::</span>value<span class="op">...}</span>;</span>
<span id="cb53-48"><a href="#cb53-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ctx <span class="op">=</span> fmt<span class="op">::</span>detail<span class="op">::</span>compile_parse_context<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;(</span></span>
<span id="cb53-49"><a href="#cb53-49" aria-hidden="true" tabindex="-1"></a>      sv, <span class="kw">sizeof</span><span class="op">...(</span>Ts<span class="op">)</span>, types, <span class="dv">0</span><span class="op">)</span>;</span>
<span id="cb53-50"><a href="#cb53-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-51"><a href="#cb53-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> arg_id <span class="op">=</span> nonstatic_data_members_of<span class="op">(</span></span>
<span id="cb53-52"><a href="#cb53-52" aria-hidden="true" tabindex="-1"></a>        <span class="op">^^</span>fmt<span class="op">::</span>parse_context<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span>,</span>
<span id="cb53-53"><a href="#cb53-53" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>meta<span class="op">::</span>access_context<span class="op">::</span>unchecked<span class="op">())[</span><span class="dv">1</span><span class="op">]</span>;</span>
<span id="cb53-54"><a href="#cb53-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-55"><a href="#cb53-55" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">char</span> <span class="kw">const</span><span class="op">*&gt;</span> strings;</span>
<span id="cb53-56"><a href="#cb53-56" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span>Interpolation<span class="op">&gt;</span> interpolations;</span>
<span id="cb53-57"><a href="#cb53-57" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info<span class="op">&gt;</span> args <span class="op">=</span> <span class="op">{^^</span>Ts<span class="op">...}</span>;</span>
<span id="cb53-58"><a href="#cb53-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-59"><a href="#cb53-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-60"><a href="#cb53-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">// next string</span></span>
<span id="cb53-61"><a href="#cb53-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> next <span class="op">=</span> std<span class="op">::</span>find<span class="op">(</span>ctx<span class="op">.</span>begin<span class="op">()</span>, ctx<span class="op">.</span>end<span class="op">()</span>, <span class="ch">&#39;{&#39;</span><span class="op">)</span>;</span>
<span id="cb53-62"><a href="#cb53-62" aria-hidden="true" tabindex="-1"></a>        strings<span class="op">.</span>push_back<span class="op">(</span></span>
<span id="cb53-63"><a href="#cb53-63" aria-hidden="true" tabindex="-1"></a>          std<span class="op">::</span>define_static_string<span class="op">(</span>std<span class="op">::</span>string_view<span class="op">(</span>ctx<span class="op">.</span>begin<span class="op">()</span>, next<span class="op">)))</span>;</span>
<span id="cb53-64"><a href="#cb53-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>next <span class="op">==</span> ctx<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb53-65"><a href="#cb53-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span>;</span>
<span id="cb53-66"><a href="#cb53-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-67"><a href="#cb53-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-68"><a href="#cb53-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">// next interpolation</span></span>
<span id="cb53-69"><a href="#cb53-69" aria-hidden="true" tabindex="-1"></a>        ctx<span class="op">.</span>advance_to<span class="op">(</span>next <span class="op">+</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb53-70"><a href="#cb53-70" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="kw">const</span> index <span class="op">=</span> ctx<span class="op">.[:</span>arg_id<span class="op">:]</span>;</span>
<span id="cb53-71"><a href="#cb53-71" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> parse_fn <span class="op">=</span> substitute<span class="op">(^^</span>parse_next_impl, <span class="op">{</span>args<span class="op">[</span>index<span class="op">]})</span>;</span>
<span id="cb53-72"><a href="#cb53-72" aria-hidden="true" tabindex="-1"></a>        extract<span class="op">&lt;</span><span class="kw">auto</span><span class="op">(*)(</span>fmt<span class="op">::</span>parse_context<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&amp;)-&gt;</span><span class="dt">void</span><span class="op">&gt;(</span>parse_fn<span class="op">)(</span>ctx<span class="op">)</span>;</span>
<span id="cb53-73"><a href="#cb53-73" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="kw">const</span> count <span class="op">=</span> ctx<span class="op">.[:</span>arg_id<span class="op">:]</span> <span class="op">-</span> index;</span>
<span id="cb53-74"><a href="#cb53-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-75"><a href="#cb53-75" aria-hidden="true" tabindex="-1"></a>        interpolations<span class="op">.</span>push_back<span class="op">({</span></span>
<span id="cb53-76"><a href="#cb53-76" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>fmt <span class="op">=</span> std<span class="op">::</span>define_static_string<span class="op">(</span></span>
<span id="cb53-77"><a href="#cb53-77" aria-hidden="true" tabindex="-1"></a>              std<span class="op">::</span>string_view<span class="op">(</span>next, ctx<span class="op">.</span>begin<span class="op">()))</span>,</span>
<span id="cb53-78"><a href="#cb53-78" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>index<span class="op">=</span>index,</span>
<span id="cb53-79"><a href="#cb53-79" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>count<span class="op">=</span>count</span>
<span id="cb53-80"><a href="#cb53-80" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span>;</span>
<span id="cb53-81"><a href="#cb53-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-82"><a href="#cb53-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-83"><a href="#cb53-83" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> info <span class="op">=</span> Information<span class="op">{</span></span>
<span id="cb53-84"><a href="#cb53-84" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>num_interpolations <span class="op">=</span> interpolations<span class="op">.</span>size<span class="op">()</span>,</span>
<span id="cb53-85"><a href="#cb53-85" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>strings <span class="op">=</span> std<span class="op">::</span>define_static_array<span class="op">(</span>strings<span class="op">).</span>data<span class="op">()</span>,</span>
<span id="cb53-86"><a href="#cb53-86" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>interpolations <span class="op">=</span> std<span class="op">::</span>define_static_array<span class="op">(</span>interpolations<span class="op">).</span>data<span class="op">()</span>,</span>
<span id="cb53-87"><a href="#cb53-87" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb53-88"><a href="#cb53-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-89"><a href="#cb53-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> std<span class="op">::</span>meta<span class="op">::</span>reflect_constant<span class="op">(</span>info<span class="op">)</span>;</span>
<span id="cb53-90"><a href="#cb53-90" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-91"><a href="#cb53-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-92"><a href="#cb53-92" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb53-93"><a href="#cb53-93" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> highlight_format_string <span class="op">{</span></span>
<span id="cb53-94"><a href="#cb53-94" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">(*</span>impl<span class="op">)(</span>fmt<span class="op">::</span>text_style, Ts<span class="op">&amp;&amp;...)</span> <span class="op">-&gt;</span> <span class="dt">void</span>;</span>
<span id="cb53-95"><a href="#cb53-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-96"><a href="#cb53-96" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> S<span class="op">&gt;</span> <span class="kw">requires</span> std<span class="op">::</span>convertible_to<span class="op">&lt;</span>S, std<span class="op">::</span>string_view<span class="op">&gt;</span></span>
<span id="cb53-97"><a href="#cb53-97" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> highlight_format_string<span class="op">(</span>S str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-98"><a href="#cb53-98" aria-hidden="true" tabindex="-1"></a>        <span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span> <span class="kw">auto</span> check <span class="op">=</span> fmt<span class="op">::</span>format_string<span class="op">&lt;</span>Ts<span class="op">...&gt;(</span>str<span class="op">)</span>;</span>
<span id="cb53-99"><a href="#cb53-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-100"><a href="#cb53-100" aria-hidden="true" tabindex="-1"></a>        impl <span class="op">=</span> extract<span class="op">&lt;</span><span class="kw">auto</span><span class="op">(*)(</span>fmt<span class="op">::</span>text_style, Ts<span class="op">&amp;&amp;...)-&gt;</span><span class="dt">void</span><span class="op">&gt;(</span></span>
<span id="cb53-101"><a href="#cb53-101" aria-hidden="true" tabindex="-1"></a>            substitute<span class="op">(^^</span>highlight_print_impl, <span class="op">{</span></span>
<span id="cb53-102"><a href="#cb53-102" aria-hidden="true" tabindex="-1"></a>                into_interpolation_info<span class="op">&lt;</span>std<span class="op">::</span>remove_cvref_t<span class="op">&lt;</span>Ts<span class="op">&gt;...&gt;(</span></span>
<span id="cb53-103"><a href="#cb53-103" aria-hidden="true" tabindex="-1"></a>                  std<span class="op">::</span>string_view<span class="op">(</span>str<span class="op">))</span>,</span>
<span id="cb53-104"><a href="#cb53-104" aria-hidden="true" tabindex="-1"></a>                <span class="op">^^</span>Ts<span class="op">...</span></span>
<span id="cb53-105"><a href="#cb53-105" aria-hidden="true" tabindex="-1"></a>            <span class="op">}))</span>;</span>
<span id="cb53-106"><a href="#cb53-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-107"><a href="#cb53-107" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb53-108"><a href="#cb53-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-109"><a href="#cb53-109" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb53-110"><a href="#cb53-110" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> highlight_print<span class="op">(</span>fmt<span class="op">::</span>text_style style,</span>
<span id="cb53-111"><a href="#cb53-111" aria-hidden="true" tabindex="-1"></a>                     std<span class="op">::</span>type_identity_t<span class="op">&lt;</span>highlight_format_string<span class="op">&lt;</span>Ts<span class="op">...&gt;&gt;</span> fmt,</span>
<span id="cb53-112"><a href="#cb53-112" aria-hidden="true" tabindex="-1"></a>                     Ts<span class="op">&amp;&amp;...</span> args<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb53-113"><a href="#cb53-113" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>impl<span class="op">(</span>style, <span class="op">(</span>Ts<span class="op">&amp;&amp;)</span>args<span class="op">...)</span>;</span>
<span id="cb53-114"><a href="#cb53-114" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>TemplateString S<span class="op">&gt;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> highlight_print<span class="op">(</span>fmt<span class="op">::</span>text_style style, S<span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> N <span class="op">=</span> s<span class="op">.</span>num_interpolations<span class="op">()</span>;</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[...</span>exprs<span class="op">]</span> <span class="op">=</span> s;</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="dt">int</span> I <span class="op">:</span> std<span class="op">::</span>views<span class="op">::</span>indices<span class="op">(</span>N<span class="op">))</span> <span class="op">{</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>string<span class="op">(</span>I<span class="op">))</span>;</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> interp <span class="op">=</span> s<span class="op">.</span>interpolation<span class="op">(</span>I<span class="op">)</span>;</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="op">[...</span>J<span class="op">]</span> <span class="op">=</span> std<span class="op">::</span>make_index_sequence<span class="op">&lt;</span>interp<span class="op">.</span>count<span class="op">&gt;()</span>;</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">::</span>print<span class="op">(</span>style,</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>                   interp<span class="op">.</span>fmt,</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>                   exprs<span class="op">...[</span>interp<span class="op">.</span>index <span class="op">+</span> J<span class="op">]...)</span>;</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>print<span class="op">(</span>s<span class="op">.</span>string<span class="op">(</span>N<span class="op">))</span>;</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>The implementation on the left reuses <code class="sourceCode cpp"><span class="op">{</span>fmt<span class="op">}</span></code>
implementation details, to avoid having to re-implement parsing on my
own — that’s just to save some effort, it’s not strictly necessary. The
fact that it’s implementable at all is kind of incredible (thanks to
Reflection), but the difference in complexity here is pretty vast. But
this is because we have to basically re-implement interpolation in
user-space and then come up with a clever way have that still work
during constant evaluation time. Once we actually do all that work, we
can produce the same representation, so the actual interesting part
(<code class="sourceCode cpp">highlight_print_impl</code> on the left)
looks the same as it does on the right. But you have to do all that work
first.</p>
<p>So the comparison boils down to this:</p>
<ul>
<li>for vanilla formatting examples, the expression-list approach
requires no library changes at all, so is a clear win over the object
approach</li>
<li>as the examples drift further away from straightforward formatting,
the object approach gets steadily more advantageous — since you already
have all the information as constants in a single location, you don’t
need to come up with a clever solution to make this work</li>
<li>any structured logging use-cases that might require the names of the
expressions is impossible in the expression-list approach.</li>
</ul>
<p>It depends on how interested we are in all of those other use-cases.
I can’t promise that none of them will ever be useful, so it seems like
a good forward-looking trade-off to me.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">4</span>
References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="1" role="doc-bibliography">
<div id="ref-P1819R0" class="csl-entry" role="doc-biblioentry">
[P1819R0] Vittorio Romeo. 2019-07-20. Interpolated Literals. <a href="https://wg21.link/p1819r0"><div class="csl-block">https://wg21.link/p1819r0</div></a>
</div>
<div id="ref-P2286R8" class="csl-entry" role="doc-biblioentry">
[P2286R8] Barry Revzin. 2022-05-16. Formatting Ranges. <a href="https://wg21.link/p2286r8"><div class="csl-block">https://wg21.link/p2286r8</div></a>
</div>
<div id="ref-P3294R2" class="csl-entry" role="doc-biblioentry">
[P3294R2] Barry Revzin, Andrei Alexandrescu, Daveed Vandevoorde.
2024-10-15. Code Injection with Token Sequences. <a href="https://wg21.link/p3294r2"><div class="csl-block">https://wg21.link/p3294r2</div></a>
</div>
<div id="ref-P3412R1" class="csl-entry" role="doc-biblioentry">
[P3412R1] Bengt Gustafsson, Victor Zverovich. 2025-01-12. String
interpolation. <a href="https://wg21.link/p3412r1"><div class="csl-block">https://wg21.link/p3412r1</div></a>
</div>
<div id="ref-P3412R3" class="csl-entry" role="doc-biblioentry">
[P3412R3] Bengt Gustafsson, Victor Zverovich. 2025-12-14. String
Interpolation. <a href="https://wg21.link/p3412r3"><div class="csl-block">https://wg21.link/p3412r3</div></a>
</div>
<div id="ref-PEP-498" class="csl-entry" role="doc-biblioentry">
[PEP-498] Eric V. Smith. 2015-08-01. Literal String Interpolation. <a href="https://peps.python.org/pep-0498/"><div class="csl-block">https://peps.python.org/pep-0498/</div></a>
</div>
<div id="ref-PEP-750" class="csl-entry" role="doc-biblioentry">
[PEP-750] Jim Baker, Guido van Rossum, Paul Everitt, Koudai Aono,
Lysandros Nikolaou, and Dave Peck. 2024-07-08. Template Strings. <a href="https://peps.python.org/pep-0750/"><div class="csl-block">https://peps.python.org/pep-0750/</div></a>
</div>
</div>
</div>
</div>
</body>
</html>
