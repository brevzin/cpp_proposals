<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-02-08" />
  <title>Injected Declarations for C++26</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.csl-block{margin-left: 1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
text-align: justify;
}
@media screen and (max-width: 30em) {
body {
margin: 1.5em;
}
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
td > div > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #C9FBC9;
--diff-strongins: #acf2bd;
--diff-del: #FFC8EB;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
div.std blockquote { color: #000000; background-color: #F1F1F1;
border: 1px solid #D1D1D1;
padding-left: 0.5em; padding-right: 0.5em; }
div.std.ins blockquote {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.ins > div.example {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.std div.sourceCode { background-color: inherit; margin-left: 1em; }
div.std blockquote del { text-decoration: line-through;
color: #000000; background-color: var(--diff-del);
border: none; }
code del { border: 1px solid #ECB3C7; }
span.orange {
background-color: #ffa500;
}
span.yellow {
background-color: #ffff00;
}</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Injected Declarations for
C++26</h1>
<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P3617R0 <a href="https://wg21.link/P3617">[Latest]</a> <a href="https://wg21.link/P3617/status">[Status]</a></td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2025-02-08</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG, CWG, LWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Wyatt Childers<br>&lt;<a href="mailto:wcc@edg.com" class="email">wcc@edg.com</a>&gt;<br>
      Dan Katz<br>&lt;<a href="mailto:dkatz85@bloomberg.net" class="email">dkatz85@bloomberg.net</a>&gt;<br>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
      Daveed Vandevoorde<br>&lt;<a href="mailto:daveed@edg.com" class="email">daveed@edg.com</a>&gt;<br>
    </td>
  </tr>
</table>
</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction<span></span></a></li>
<li><a href="#examples" id="toc-examples"><span class="toc-section-number">2</span> Examples<span></span></a>
<ul>
<li><a href="#a-simple-tuple-type" id="toc-a-simple-tuple-type"><span class="toc-section-number">2.1</span> A Simple Tuple
Type<span></span></a></li>
<li><a href="#a-simple-variant-type" id="toc-a-simple-variant-type"><span class="toc-section-number">2.2</span> A Simple Variant
Type<span></span></a></li>
<li><a href="#struct-to-struct-of-arrays" id="toc-struct-to-struct-of-arrays"><span class="toc-section-number">2.3</span> Struct to Struct of
Arrays<span></span></a></li>
<li><a href="#parsing-command-line-options-ii" id="toc-parsing-command-line-options-ii"><span class="toc-section-number">2.4</span> Parsing Command-Line Options
II<span></span></a></li>
<li><a href="#named-tuple" id="toc-named-tuple"><span class="toc-section-number">2.5</span> Named Tuple<span></span></a></li>
<li><a href="#compile-time-ticket-counter" id="toc-compile-time-ticket-counter"><span class="toc-section-number">2.6</span> Compile-Time Ticket
Counter<span></span></a></li>
</ul></li>
<li><a href="#proposal-details" id="toc-proposal-details"><span class="toc-section-number">3</span> Proposal Details<span></span></a>
<ul>
<li><a href="#constant-evaluation-order" id="toc-constant-evaluation-order"><span class="toc-section-number">3.1</span> Constant evaluation
order<span></span></a></li>
<li><a href="#reachability-and-injected-declarations" id="toc-reachability-and-injected-declarations"><span class="toc-section-number">3.2</span> Reachability and injected
declarations<span></span></a></li>
<li><a href="#restrictions-on-injected-declarations" id="toc-restrictions-on-injected-declarations"><span class="toc-section-number">3.3</span> Restrictions on injected
declarations<span></span></a></li>
<li><a href="#data_member_spec-and-define_aggregate" id="toc-data_member_spec-and-define_aggregate"><span class="toc-section-number">3.4</span>
<code class="sourceCode cpp">data_member_spec</code> and
<code class="sourceCode cpp">define_aggregate</code><span></span></a></li>
</ul></li>
<li><a href="#wording" id="toc-wording"><span class="toc-section-number">4</span> Wording<span></span></a>
<ul>
<li><a href="#language" id="toc-language"><span class="toc-section-number">4.1</span> Language<span></span></a>
<ul>
<li><a href="#lex.phases-phases-of-translation" id="toc-lex.phases-phases-of-translation"><span>5.2
<span>[lex.phases]</span></span> Phases of
translation<span></span></a></li>
<li><a href="#basic.def-declarations-and-definitions" id="toc-basic.def-declarations-and-definitions"><span>6.2
<span>[basic.def]</span></span> Declarations and
definitions<span></span></a></li>
<li><a href="#basic.def.odr-one-definition-rule" id="toc-basic.def.odr-one-definition-rule"><span>6.3
<span>[basic.def.odr]</span></span> One-definition
rule<span></span></a></li>
<li><a href="#basic.scope.consteval-consteval-block-scope" id="toc-basic.scope.consteval-consteval-block-scope">6.4.5+
[basic.scope.consteval] Consteval block scope<span></span></a></li>
<li><a href="#intro.execution-sequential-execution" id="toc-intro.execution-sequential-execution"><span>6.9.1
<span>[intro.execution]</span></span> Sequential
execution<span></span></a></li>
<li><a href="#expr.const-constant-expressions" id="toc-expr.const-constant-expressions"><span>7.7
<span>[expr.const]</span></span> Constant
Expressions<span></span></a></li>
<li><a href="#dcl.pre-preamble" id="toc-dcl.pre-preamble"><span>9.1
<span>[dcl.pre]</span></span> Preamble<span></span></a></li>
<li><a href="#class.mem.general-general" id="toc-class.mem.general-general"><span>11.4.1
<span>[class.mem.general]</span></span> General<span></span></a></li>
<li><a href="#class.union.anon-anonymous-unions" id="toc-class.union.anon-anonymous-unions"><span>11.5.2
<span>[class.union.anon]</span></span> Anonymous
unions<span></span></a></li>
</ul></li>
<li><a href="#library" id="toc-library"><span class="toc-section-number">4.2</span> Library<span></span></a>
<ul>
<li><a href="#meta.reflection.synop-header-meta-synopsis" id="toc-meta.reflection.synop-header-meta-synopsis">[meta.reflection.synop]
Header <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code>
synopsis<span></span></a></li>
<li><a href="#meta.reflection.names-reflection-names-and-locations" id="toc-meta.reflection.names-reflection-names-and-locations">[meta.reflection.names]
Reflection names and locations<span></span></a></li>
<li><a href="#meta.reflection.queries-reflection-queries" id="toc-meta.reflection.queries-reflection-queries">[meta.reflection.queries]
Reflection queries<span></span></a></li>
<li><a href="#meta.reflection.layout-reflection-layout-queries" id="toc-meta.reflection.layout-reflection-layout-queries">[meta.reflection.layout]
Reflection layout queries<span></span></a></li>
<li><a href="#meta.reflection.define.aggregate-reflection-class-definition-generation" id="toc-meta.reflection.define.aggregate-reflection-class-definition-generation">[meta.reflection.define.aggregate]
Reflection class definition generation<span></span></a></li>
<li><a href="#meta.reflection.annotation-annotation-reflection" id="toc-meta.reflection.annotation-annotation-reflection">[meta.reflection.annotation]
Annotation reflection<span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#bibliography" id="toc-bibliography"><span class="toc-section-number">5</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">1</span>
Introduction<a href="#introduction" class="self-link"></a></h1>
<p>This paper is exists as a response to <span class="title"><span class="citation" data-cites="P3569R0"><a href="https://wg21.link/p3569r0" role="doc-biblioref">[P3569R0] (Split
define_aggregate from Reflection)</a></span></span>, and exists to take
portions of three different papers:</p>
<ul>
<li>from <span class="title"><span class="citation" data-cites="P2996R9"><a href="https://wg21.link/p2996r9" role="doc-biblioref">[P2996R9] (Reflection for C++26)</a></span></span>,
the language rules around injected declarations and the <code class="sourceCode cpp">define_aggregate<span class="op">()</span></code>
facility,</li>
<li>from <span class="title"><span class="citation" data-cites="P3289R1"><a href="https://wg21.link/p3289r1" role="doc-biblioref">[P3289R1] (Consteval blocks)</a></span></span>,
<code class="sourceCode cpp"><span class="kw">consteval</span></code>
blocks (which are the only place where we want to allow injection to
happen from), and</li>
<li>from <span class="title"><span class="citation" data-cites="P3394R1"><a href="https://wg21.link/p3394r1" role="doc-biblioref">[P3394R1] (Annotations for
Reflection)</a></span></span>, the
<code class="sourceCode cpp">annotate<span class="op">()</span></code>
function (which is the only part of that paper that does
injection).</li>
</ul>
<p>The goal of this paper is to, basically, streamline the process of
getting reflection into C++26. The parts of P2996, without injection,
are fairly well understood at this point and the wording is in good
shape (both on the language and library side) to be able to make it to
plenary in Hagenberg. This would be a massive achievement.</p>
<p>The injection part of reflection, even the minimal part being
proposed as part of these papers, is still very valuable. But the rules
we are trying to construct around it — to ensure that you can only
inject declarations in sensible places and not allow you to observe
aspects of compilation that there is no value to allow you to observe —
are subtle, require thought, and have taken time to get right.</p>
<p>It’s possible that we have those rules right already, and we can get
both the reduced versions of p2996 and p3394 and also this paper into
plenary and Hagenberg. But that’s not strictly necessary from a timeline
perspective. We would rather not delay p2996 and p3394 any further —
let’s try to get those into plenary and work on injection
separately.</p>
<p>The rest of this paper will take examples, prose, and wording pulled
from the other papers listed above.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="examples"><span class="header-section-number">2</span> Examples<a href="#examples" class="self-link"></a></h1>
<h2 data-number="2.1" id="a-simple-tuple-type"><span class="header-section-number">2.1</span> A Simple Tuple Type<a href="#a-simple-tuple-type" class="self-link"></a></h2>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> Tuple <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> storage;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(^^</span>storage, <span class="op">{</span>data_member_spec<span class="op">(^^</span>Ts<span class="op">)...})</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  storage data;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  Tuple<span class="op">():</span> data<span class="op">{}</span> <span class="op">{}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  Tuple<span class="op">(</span>Ts <span class="kw">const</span><span class="op">&amp;</span> <span class="op">...</span>vs<span class="op">):</span> data<span class="op">{</span> vs<span class="op">...</span> <span class="op">}</span> <span class="op">{}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> std<span class="op">::</span>tuple_size<span class="op">&lt;</span>Tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&gt;:</span> <span class="kw">public</span> integral_constant<span class="op">&lt;</span><span class="dt">size_t</span>, <span class="kw">sizeof</span><span class="op">...(</span>Ts<span class="op">)&gt;</span> <span class="op">{}</span>;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>std<span class="op">::</span><span class="dt">size_t</span> I, <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> std<span class="op">::</span>tuple_element<span class="op">&lt;</span>I, Tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> std<span class="op">::</span>array types <span class="op">=</span> <span class="op">{^^</span>Ts<span class="op">...}</span>;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> <span class="op">[:</span> types<span class="op">[</span>I<span class="op">]</span> <span class="op">:]</span>;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> std<span class="op">::</span>meta<span class="op">::</span>info get_nth_field<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info r, std<span class="op">::</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> nonstatic_data_members_of<span class="op">(</span>r<span class="op">)[</span>n<span class="op">]</span>;</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>std<span class="op">::</span><span class="dt">size_t</span> I, <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> get<span class="op">(</span>Tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;</span> <span class="op">&amp;</span>t<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> std<span class="op">::</span>tuple_element_t<span class="op">&lt;</span>I, Tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&gt;&amp;</span> <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t<span class="op">.</span>data<span class="op">.[:</span>get_nth_field<span class="op">(^^</span><span class="kw">decltype</span><span class="op">(</span>t<span class="op">.</span>data<span class="op">)</span>, I<span class="op">):]</span>;</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co">// Similarly for other value categories...</span></span></code></pre></div>
</blockquote>
</div>
<p>This example uses a “magic” <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>define_aggregate</code>
template along with member reflection through the
<code class="sourceCode cpp">nonstatic_data_members_of</code>
metafunction to implement a
<code class="sourceCode cpp">std<span class="op">::</span>tuple</code>-like
type without the usual complex and costly template metaprogramming
tricks that that involves when these facilities are not available.
<code class="sourceCode cpp">define_aggregate</code> takes a reflection
for an incomplete class or union plus a vector of non-static data member
descriptions, and completes the give class or union type to have the
described members.</p>
<p>On Compiler Explorer: <a href="https://godbolt.org/z/76EojjcEe">EDG</a>, <a href="https://godbolt.org/z/cx8cr53q7">Clang</a>.</p>
<h2 data-number="2.2" id="a-simple-variant-type"><span class="header-section-number">2.2</span> A Simple Variant Type<a href="#a-simple-variant-type" class="self-link"></a></h2>
<p>Similarly to how we can implement a tuple using
<code class="sourceCode cpp">define_aggregate</code> to create on the
fly a type with one member for each
<code class="sourceCode cpp">Ts<span class="op">...</span></code>, we
can implement a variant that simply defines a
<code class="sourceCode cpp"><span class="kw">union</span></code>
instead of a
<code class="sourceCode cpp"><span class="kw">struct</span></code>. One
difference here is how the destructor of a
<code class="sourceCode cpp"><span class="kw">union</span></code> is
currently defined:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> U1 <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> c;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> U2 <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>string s;</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p><code class="sourceCode cpp">U1</code> has a trivial destructor, but
<code class="sourceCode cpp">U2</code>’s destructor is defined as
deleted (because
<code class="sourceCode cpp">std<span class="op">::</span>string</code>
has a non-trivial destructor). This is a problem because we need to
define this thing… somehow. However, for the purposes of
<code class="sourceCode cpp">define_aggregate</code>, there really is
only one reasonable option to choose here:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> U <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// all of our members</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  Ts<span class="op">...</span> members;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// a defaulted destructor if all of the types are trivially destructible</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="op">~</span>U<span class="op">()</span> <span class="kw">requires</span> <span class="op">(</span>std<span class="op">::</span>is_trivially_destructible_v<span class="op">&lt;</span>Ts<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">...)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ... otherwise a destructor that does nothing</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="op">~</span>U<span class="op">()</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>If we make <a href="#data_member_spec-define_aggregate"><code class="sourceCode cpp">define_aggregate</code></a>
for a <code class="sourceCode cpp"><span class="kw">union</span></code>
have this behavior, then we can implement a
<code class="sourceCode cpp">variant</code> in a much more
straightforward way than in current implementations. This is not a
complete implementation of
<code class="sourceCode cpp">std<span class="op">::</span>variant</code>
(and cheats using libstdc++ internals, and also uses Boost.Mp11’s
<code class="sourceCode cpp">mp_with_index</code>) but should
demonstrate the idea:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Variant <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> Storage;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Empty <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      define_aggregate<span class="op">(^^</span>Storage, <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>          data_member_spec<span class="op">(^^</span>Empty, <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;empty&quot;</span><span class="op">})</span>,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>          data_member_spec<span class="op">(^^</span>Ts<span class="op">)...</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">})</span>;</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">consteval</span> std<span class="op">::</span>meta<span class="op">::</span>info get_nth_field<span class="op">(</span>std<span class="op">::</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nonstatic_data_members_of<span class="op">(^^</span>Storage<span class="op">)[</span>n<span class="op">+</span><span class="dv">1</span><span class="op">]</span>;</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    Storage storage_;</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> index_ <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>;</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// cheat: use libstdc++&#39;s implementation</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> accepted_index <span class="op">=</span> std<span class="op">::</span>__detail<span class="op">::</span>__variant<span class="op">::</span>__accepted_index<span class="op">&lt;</span>T, std<span class="op">::</span>variant<span class="op">&lt;</span>Ts<span class="op">...&gt;&gt;</span>;</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> F<span class="op">&gt;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> with_index<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mp_with_index<span class="op">&lt;</span><span class="kw">sizeof</span><span class="op">...(</span>Ts<span class="op">)&gt;(</span>index_, <span class="op">(</span>F<span class="op">&amp;&amp;)</span>f<span class="op">)</span>;</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> Variant<span class="op">()</span> <span class="kw">requires</span> std<span class="op">::</span>is_default_constructible_v<span class="op">&lt;</span>Ts<span class="op">...[</span><span class="dv">0</span><span class="op">]&gt;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// should this work: storage_{. [: get_nth_field(0) :]{} }</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> storage_<span class="op">{.</span>empty<span class="op">={}}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        , index_<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>construct_at<span class="op">(&amp;</span>storage_<span class="op">.[:</span> get_nth_field<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">:])</span>;</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="op">~</span>Variant<span class="op">()</span> <span class="kw">requires</span> <span class="op">(</span>std<span class="op">::</span>is_trivially_destructible_v<span class="op">&lt;</span>Ts<span class="op">&gt;</span> <span class="kw">and</span> <span class="op">...)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="op">~</span>Variant<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>index_ <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>            with_index<span class="op">([&amp;](</span><span class="kw">auto</span> I<span class="op">){</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>                std<span class="op">::</span>destroy_at<span class="op">(&amp;</span>storage_<span class="op">.[:</span> get_nth_field<span class="op">(</span>I<span class="op">)</span> <span class="op">:])</span>;</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">})</span>;</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="dt">size_t</span> I <span class="op">=</span> accepted_index<span class="op">&lt;</span>T<span class="op">&amp;&amp;&gt;&gt;</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>        <span class="kw">requires</span> <span class="op">(!</span>std<span class="op">::</span>is_base_of_v<span class="op">&lt;</span>Variant, std<span class="op">::</span>decay_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;)</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> Variant<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> storage_<span class="op">{.</span>empty<span class="op">={}}</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>        , index_<span class="op">(-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>construct_at<span class="op">(&amp;</span>storage_<span class="op">.[:</span> get_nth_field<span class="op">(</span>I<span class="op">)</span> <span class="op">:]</span>, <span class="op">(</span>T<span class="op">&amp;&amp;)</span>t<span class="op">)</span>;</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>        index_ <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>I;</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// you can&#39;t actually express this constraint nicely until P2963</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> Variant<span class="op">(</span>Variant <span class="kw">const</span><span class="op">&amp;)</span> <span class="kw">requires</span> <span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span>Ts<span class="op">&gt;</span> <span class="kw">and</span> <span class="op">...)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> Variant<span class="op">(</span>Variant <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>            <span class="kw">requires</span> <span class="op">((</span>std<span class="op">::</span>is_copy_constructible_v<span class="op">&lt;</span>Ts<span class="op">&gt;</span> <span class="kw">and</span> <span class="op">...)</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>                <span class="kw">and</span> <span class="kw">not</span> <span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span>Ts<span class="op">&gt;</span> <span class="kw">and</span> <span class="op">...))</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> storage_<span class="op">{.</span>empty<span class="op">={}}</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>        , index_<span class="op">(-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>        rhs<span class="op">.</span>with_index<span class="op">([&amp;](</span><span class="kw">auto</span> I<span class="op">){</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>            <span class="kw">constexpr</span> <span class="kw">auto</span> field <span class="op">=</span> get_nth_field<span class="op">(</span>I<span class="op">)</span>;</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>            std<span class="op">::</span>construct_at<span class="op">(&amp;</span>storage_<span class="op">.[:</span> field <span class="op">:]</span>, rhs<span class="op">.</span>storage_<span class="op">.[:</span> field <span class="op">:])</span>;</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>            index_ <span class="op">=</span> I;</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span>;</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> index<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> index_; <span class="op">}</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> F<span class="op">&gt;</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> visit<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>index_ <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> std<span class="op">::</span>bad_variant_access<span class="op">()</span>;</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mp_with_index<span class="op">&lt;</span><span class="kw">sizeof</span><span class="op">...(</span>Ts<span class="op">)&gt;(</span>index_, <span class="op">[&amp;](</span><span class="kw">auto</span> I<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> std<span class="op">::</span>invoke<span class="op">((</span>F<span class="op">&amp;&amp;)</span>f,  storage_<span class="op">.[:</span> get_nth_field<span class="op">(</span>I<span class="op">)</span> <span class="op">:])</span>;</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span>;</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>Effectively, <code class="sourceCode cpp">Variant<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code>
synthesizes a union type <code class="sourceCode cpp">Storage</code>
which looks like this:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> Storage <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Empty empty;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    T <em>unnamed<sub>0</sub></em>;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    U <em>unnamed<sub>1</sub></em>;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Storage<span class="op">()</span> <span class="kw">requires</span> std<span class="op">::</span>is_trivially_destructible_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> std<span class="op">::</span>is_trivially_destructible_v<span class="op">&lt;</span>U<span class="op">&gt;</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Storage<span class="op">()</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>The question here is whether we should be should be able to directly
initialize members of a defined union using a splicer, as in:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span> storage<span class="op">{.[:</span> get_nth_field<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">:]={}}</span></span></code></pre></div>
</blockquote>
</div>
<p>Arguably, the answer should be yes - this would be consistent with
how other accesses work. This is instead proposed in <span class="citation" data-cites="P3293R1"><a href="https://wg21.link/p3293r1" role="doc-biblioref">[P3293R1]</a></span>.</p>
<p>On Compiler Explorer: <a href="https://godbolt.org/z/W74qxqnhf">EDG</a>, <a href="https://godbolt.org/z/h13oh4s6e">Clang</a>.</p>
<h2 data-number="2.3" id="struct-to-struct-of-arrays"><span class="header-section-number">2.3</span> Struct to Struct of Arrays<a href="#struct-to-struct-of-arrays" class="self-link"></a></h2>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> struct_of_arrays_impl <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> impl;</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info<span class="op">&gt;</span> old_members <span class="op">=</span> nonstatic_data_members_of<span class="op">(^^</span>T<span class="op">)</span>;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info<span class="op">&gt;</span> new_members <span class="op">=</span> <span class="op">{}</span>;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info member <span class="op">:</span> old_members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> array_type <span class="op">=</span> substitute<span class="op">(^^</span>std<span class="op">::</span>array, <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            type_of<span class="op">(</span>member<span class="op">)</span>,</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            std<span class="op">::</span>meta<span class="op">::</span>reflect_value<span class="op">(</span>N<span class="op">)</span>,</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span>;</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> mem_descr <span class="op">=</span> data_member_spec<span class="op">(</span>array_type, <span class="op">{.</span>name <span class="op">=</span> identifier_of<span class="op">(</span>member<span class="op">)})</span>;</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        new_members<span class="op">.</span>push_back<span class="op">(</span>mem_descr<span class="op">)</span>;</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(^^</span>impl, new_members<span class="op">)</span>;</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> struct_of_arrays <span class="op">=</span> struct_of_arrays_impl<span class="op">&lt;</span>T, N<span class="op">&gt;::</span>impl;</span></code></pre></div>
</blockquote>
</div>
<p>Example:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> x;</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> y;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> z;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> points <span class="op">=</span> struct_of_arrays<span class="op">&lt;</span>point, <span class="dv">30</span><span class="op">&gt;</span>;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">// equivalent to:</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">// struct points {</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">//   std::array&lt;float, 30&gt; x;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">//   std::array&lt;float, 30&gt; y;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">//   std::array&lt;float, 30&gt; z;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">// };</span></span></code></pre></div>
</blockquote>
</div>
<p>Again, the combination of
<code class="sourceCode cpp">nonstatic_data_members_of</code> and
<code class="sourceCode cpp">define_aggregate</code> is put to good
use.</p>
<p>This example also illustrates some requirements that we have on
<code class="sourceCode cpp">define_aggregate</code>. In particular,
that function is said to produce an “injected declaration” and the
target scope of the declaration must be within the same “cone of
instantiation” as the evaluation that produced it. Which means that the
following similar structure is ill-formed:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> struct_of_arrays_impl;</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> struct_of_arrays <span class="op">=</span> <span class="op">[:</span> <span class="op">[]{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ... same logic ..</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// error: the target scope of this declaration is a</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// different instantiation from the one we are currently in.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  define_aggregate<span class="op">(^^</span>struct_of_arrays_impl<span class="op">&lt;</span>T, N<span class="op">&gt;</span>, new_members<span class="op">)</span>;</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span> <span class="op">:]</span>;</span></code></pre></div>
</blockquote>
</div>
<p>That could be fixed if we reorganize it like this:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> struct_of_arrays <span class="op">=</span> <span class="op">[:</span> <span class="op">[]{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ... same logic ..</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OK, same instantiation</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> impl;</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  define_aggregate<span class="op">(^^</span>impl, new_members<span class="op">)</span>;</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span> <span class="op">:]</span>;</span></code></pre></div>
</blockquote>
</div>
<p>But now <code class="sourceCode cpp">struct_of_arrays<span class="op">&lt;</span>point, <span class="dv">30</span><span class="op">&gt;</span></code>
has no linkage, whereas we wanted it to have external linkage. Hence the
structure in the example above where we are instead defining a nested
class in a class template — so that we have a type with external linkage
but don’t run afoul of the “cone of instantiation” rule.</p>
<p>On Compiler Explorer: <a href="https://godbolt.org/z/jWrPGhn5s">EDG</a>, <a href="https://godbolt.org/z/a1sTxnW4o">Clang</a>.</p>
<h2 data-number="2.4" id="parsing-command-line-options-ii"><span class="header-section-number">2.4</span> Parsing Command-Line Options
II<a href="#parsing-command-line-options-ii" class="self-link"></a></h2>
<p>Now that we’ve seen a couple examples of using <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>define_aggregate</code>
to create a type, we can create a more sophisticated command-line parser
example.</p>
<p>This is the opening example for <a href="https://docs.rs/clap/latest/clap/">clap</a> (Rust’s
<strong>C</strong>ommand <strong>L</strong>ine <strong>A</strong>rgument
<strong>P</strong>arser):</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Args <span class="op">:</span> Clap <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  Option<span class="op">&lt;</span>std<span class="op">::</span>string, <span class="op">{.</span>use_short<span class="op">=</span><span class="kw">true</span>, <span class="op">.</span>use_long<span class="op">=</span><span class="kw">true</span><span class="op">}&gt;</span> name;</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  Option<span class="op">&lt;</span><span class="dt">int</span>, <span class="op">{.</span>use_short<span class="op">=</span><span class="kw">true</span>, <span class="op">.</span>use_long<span class="op">=</span><span class="kw">true</span><span class="op">}&gt;</span> count <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc, <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> opts <span class="op">=</span> Args<span class="op">{}.</span>parse<span class="op">(</span>argc, argv<span class="op">)</span>;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span>; i <span class="op">&lt;</span> opts<span class="op">.</span>count; <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span>  <span class="co">// opts.count has type int</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Hello {}!&quot;</span>, opts<span class="op">.</span>name<span class="op">)</span>;   <span class="co">// opts.name has type std::string</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Which we can implement like this:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Flags <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> use_short;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> use_long;</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, Flags flags<span class="op">&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Option <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>optional<span class="op">&lt;</span>T<span class="op">&gt;</span> initializer <span class="op">=</span> <span class="op">{}</span>;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// some suitable constructors and accessors for flags</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">// convert a type (all of whose non-static data members are specializations of Option)</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">// to a type that is just the appropriate members.</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">// For example, if type is a reflection of the Args presented above, then this</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">// function would evaluate to a reflection of the type</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">// struct {</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">//   std::string name;</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co">//   int count;</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="kw">auto</span> spec_to_opts<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info opts,</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                            std<span class="op">::</span>meta<span class="op">::</span>info spec<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>meta<span class="op">::</span>info <span class="op">{</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info<span class="op">&gt;</span> new_members;</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info member <span class="op">:</span> nonstatic_data_members_of<span class="op">(</span>spec<span class="op">))</span> <span class="op">{</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> type_new <span class="op">=</span> template_arguments_of<span class="op">(</span>type_of<span class="op">(</span>member<span class="op">))[</span><span class="dv">0</span><span class="op">]</span>;</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    new_members<span class="op">.</span>push_back<span class="op">(</span>data_member_spec<span class="op">(</span>type_new, <span class="op">{.</span>name<span class="op">=</span>identifier_of<span class="op">(</span>member<span class="op">)}))</span>;</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> define_aggregate<span class="op">(</span>opts, new_members<span class="op">)</span>;</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Clap <span class="op">{</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Spec<span class="op">&gt;</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> parse<span class="op">(</span><span class="kw">this</span> Spec <span class="kw">const</span><span class="op">&amp;</span> spec, <span class="dt">int</span> argc, <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>string_view<span class="op">&gt;</span> cmdline<span class="op">(</span>argv<span class="op">+</span><span class="dv">1</span>, argv<span class="op">+</span>argc<span class="op">)</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// check if cmdline contains --help, etc.</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Opts;</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>      spec_to_opts<span class="op">(^^</span>Opts, <span class="op">^^</span>Spec<span class="op">)</span>;</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="op">[</span>sm, om<span class="op">]</span> <span class="op">:</span> std<span class="op">::</span>views<span class="op">::</span>zip<span class="op">(</span>nonstatic_data_members_of<span class="op">(^^</span>Spec<span class="op">)</span>,</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>                                                            nonstatic_data_members_of<span class="op">(^^</span>Opts<span class="op">)))</span> <span class="op">{</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> cur <span class="op">=</span> spec<span class="op">.[:</span>sm<span class="op">:]</span>;</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> type <span class="op">=</span> type_of<span class="op">(</span>om<span class="op">)</span>;</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>      <span class="co">// find the argument associated with this option</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> it <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>find_if<span class="op">(</span>cmdline,</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">[&amp;](</span>std<span class="op">::</span>string_view arg<span class="op">){</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span> <span class="op">(</span>cur<span class="op">.</span>use_short <span class="op">&amp;&amp;</span> arg<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> arg<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;-&#39;</span> <span class="op">&amp;&amp;</span> arg<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> identifier_of<span class="op">(</span>sm<span class="op">)[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>              <span class="op">||</span> <span class="op">(</span>cur<span class="op">.</span>use_long <span class="op">&amp;&amp;</span> arg<span class="op">.</span>starts_with<span class="op">(</span><span class="st">&quot;--&quot;</span><span class="op">)</span> <span class="op">&amp;&amp;</span> arg<span class="op">.</span>substr<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">==</span> identifier_of<span class="op">(</span>sm<span class="op">))</span>;</span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span>;</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>      <span class="co">// no such argument</span></span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>it <span class="op">==</span> cmdline<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>has_template_arguments<span class="op">(</span>type<span class="op">)</span> <span class="kw">and</span> template_of<span class="op">(</span>type<span class="op">)</span> <span class="op">==</span> <span class="op">^^</span>std<span class="op">::</span>optional<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>          <span class="co">// the type is optional, so the argument is too</span></span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>          <span class="cf">continue</span>;</span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>cur<span class="op">.</span>initializer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>          <span class="co">// the type isn&#39;t optional, but an initializer is provided, use that</span></span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a>          opts<span class="op">.[:</span>om<span class="op">:]</span> <span class="op">=</span> <span class="op">*</span>cur<span class="op">.</span>initializer;</span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>          <span class="cf">continue</span>;</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>          std<span class="op">::</span>print<span class="op">(</span>stderr, <span class="st">&quot;Missing required option {}</span><span class="sc">\n</span><span class="st">&quot;</span>, display_string_of<span class="op">(</span>sm<span class="op">))</span>;</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>          std<span class="op">::</span>exit<span class="op">(</span>EXIT_FAILURE<span class="op">)</span>;</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>it <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> cmdline<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>print<span class="op">(</span>stderr, <span class="st">&quot;Option {} for {} is missing a value</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="op">*</span>it, display_string_of<span class="op">(</span>sm<span class="op">))</span>;</span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>exit<span class="op">(</span>EXIT_FAILURE<span class="op">)</span>;</span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a>      <span class="co">// found our argument, try to parse it</span></span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> iss <span class="op">=</span> ispanstream<span class="op">(</span>it<span class="op">[</span><span class="dv">1</span><span class="op">])</span>;</span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>iss <span class="op">&gt;&gt;</span> opts<span class="op">.[:</span>om<span class="op">:]</span>; <span class="op">!</span>iss<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>print<span class="op">(</span>stderr, <span class="st">&quot;Failed to parse {:?} into option {} of type {}</span><span class="sc">\n</span><span class="st">&quot;</span>,</span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a>          it<span class="op">[</span><span class="dv">1</span><span class="op">]</span>, display_string_of<span class="op">(</span>sm<span class="op">)</span>, display_string_of<span class="op">(</span>type<span class="op">))</span>;</span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a>        std<span class="op">::</span>exit<span class="op">(</span>EXIT_FAILURE<span class="op">)</span>;</span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> opts;</span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>On Compiler Explorer: <a href="https://godbolt.org/z/4aseo5eGq">EDG</a>, <a href="https://godbolt.org/z/3qG5roer4">Clang</a>.</p>
<h2 data-number="2.5" id="named-tuple"><span class="header-section-number">2.5</span> Named Tuple<a href="#named-tuple" class="self-link"></a></h2>
<p>The tricky thing with implementing a named tuple is actually strings
as non-type template parameters. Because you cannot just pass <code class="sourceCode cpp"><span class="st">&quot;x&quot;</span></code> into
a non-type template parameter of the form
<code class="sourceCode cpp"><span class="kw">auto</span> V</code>, that
leaves us with two ways of specifying the constituents:</p>
<ol type="1">
<li>Can introduce a <code class="sourceCode cpp">pair</code> type so
that we can write <code class="sourceCode cpp">make_named_tuple<span class="op">&lt;</span>pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="st">&quot;x&quot;</span><span class="op">&gt;</span>, pair<span class="op">&lt;</span><span class="dt">double</span>, <span class="st">&quot;y&quot;</span><span class="op">&gt;&gt;()</span></code>,
or</li>
<li>Can just do reflections all the way down so that we can write</li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>make_named_tuple<span class="op">&lt;^^</span><span class="dt">int</span>, std<span class="op">::</span>meta<span class="op">::</span>reflect_value<span class="op">(</span><span class="st">&quot;x&quot;</span><span class="op">)</span>,</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                 <span class="op">^^</span><span class="dt">double</span>, std<span class="op">::</span>meta<span class="op">::</span>reflect_value<span class="op">(</span><span class="st">&quot;y&quot;</span><span class="op">)&gt;()</span></span></code></pre></div>
<p>We do not currently support splicing string literals, and the
<code class="sourceCode cpp">pair</code> approach follows the similar
pattern already shown with
<code class="sourceCode cpp">define_aggregate</code> (given a suitable
<code class="sourceCode cpp">fixed_string</code> type):</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T, fixed_string Name<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> pair <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> name<span class="op">()</span> <span class="op">-&gt;</span> std<span class="op">::</span>string_view <span class="op">{</span> <span class="cf">return</span> Name<span class="op">.</span>view<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> T;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Tags<span class="op">&gt;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="kw">auto</span> make_named_tuple<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info type, Tags<span class="op">...</span> tags<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info<span class="op">&gt;</span> nsdms;</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f <span class="op">=</span> <span class="op">[&amp;]&lt;</span><span class="kw">class</span> Tag<span class="op">&gt;(</span>Tag tag<span class="op">){</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        nsdms<span class="op">.</span>push_back<span class="op">(</span>data_member_spec<span class="op">(</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>            dealias<span class="op">(^^</span><span class="kw">typename</span> Tag<span class="op">::</span>type<span class="op">)</span>,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">{.</span>name<span class="op">=</span>Tag<span class="op">::</span>name<span class="op">()}))</span>;</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>f<span class="op">(</span>tags<span class="op">)</span>, <span class="op">...)</span>;</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> define_aggregate<span class="op">(</span>type, nsdms<span class="op">)</span>;</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> R;</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>  make_named_tuple<span class="op">(^^</span>R, pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="st">&quot;x&quot;</span><span class="op">&gt;{}</span>, pair<span class="op">&lt;</span><span class="dt">double</span>, <span class="st">&quot;y&quot;</span><span class="op">&gt;{})</span>;</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>type_of<span class="op">(</span>nonstatic_data_members_of<span class="op">(^^</span>R<span class="op">)[</span><span class="dv">0</span><span class="op">])</span> <span class="op">==</span> <span class="op">^^</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>type_of<span class="op">(</span>nonstatic_data_members_of<span class="op">(^^</span>R<span class="op">)[</span><span class="dv">1</span><span class="op">])</span> <span class="op">==</span> <span class="op">^^</span><span class="dt">double</span><span class="op">)</span>;</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span> <span class="kw">auto</span> r <span class="op">=</span> R<span class="op">{.</span>x<span class="op">=</span><span class="dv">1</span>, <span class="op">.</span>y<span class="op">=</span><span class="fl">2.0</span><span class="op">}</span>;</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>On Compiler Explorer: <a href="https://godbolt.org/z/64qTe4KG1">EDG</a>, <a href="https://godbolt.org/z/76qM1xqvn">Clang</a>.</p>
<p>Alternatively, can side-step the question of non-type template
parameters entirely by keeping everything in the value domain:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="kw">auto</span> make_named_tuple<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info type,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                                std<span class="op">::</span>initializer_list<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info, std<span class="op">::</span>string_view<span class="op">&gt;&gt;</span> members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>data_member_spec<span class="op">&gt;</span> nsdms;</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">[</span>type, name<span class="op">]</span> <span class="op">:</span> members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        nsdms<span class="op">.</span>push_back<span class="op">(</span>data_member_spec<span class="op">(</span>type, <span class="op">{.</span>name<span class="op">=</span>name<span class="op">}))</span>;</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> define_aggregate<span class="op">(</span>type, nsdms<span class="op">)</span>;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> R;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  make_named_tuple<span class="op">(^^</span>R, <span class="op">{{^^</span><span class="dt">int</span>, <span class="st">&quot;x&quot;</span><span class="op">}</span>, <span class="op">{^^</span><span class="dt">double</span>, <span class="st">&quot;y&quot;</span><span class="op">}})</span>;</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>type_of<span class="op">(</span>nonstatic_data_members_of<span class="op">(^^</span>R<span class="op">)[</span><span class="dv">0</span><span class="op">])</span> <span class="op">==</span> <span class="op">^^</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>type_of<span class="op">(</span>nonstatic_data_members_of<span class="op">(^^</span>R<span class="op">)[</span><span class="dv">1</span><span class="op">])</span> <span class="op">==</span> <span class="op">^^</span><span class="dt">double</span><span class="op">)</span>;</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span> <span class="kw">auto</span> r <span class="op">=</span> R<span class="op">{.</span>x<span class="op">=</span><span class="dv">1</span>, <span class="op">.</span>y<span class="op">=</span><span class="fl">2.0</span><span class="op">}</span>;</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>On Compiler Explorer: <a href="https://godbolt.org/z/oY6ETbv9x">EDG
and Clang</a> (the EDG and Clang implementations differ only in Clang
having the updated <code class="sourceCode cpp">data_member_spec</code>
API that returns an <code class="sourceCode cpp">info</code>, and the
updated name <code class="sourceCode cpp">define_aggregate</code>).</p>
<h2 data-number="2.6" id="compile-time-ticket-counter"><span class="header-section-number">2.6</span> Compile-Time Ticket Counter<a href="#compile-time-ticket-counter" class="self-link"></a></h2>
<p>The features proposed here make it a little easier to update a ticket
counter at compile time. This is not an ideal implementation (we’d
prefer direct support for compile-time —– i.e.,
<code class="sourceCode cpp"><span class="kw">consteval</span></code> —
variables), but it shows how compile-time mutable state surfaces in new
ways.</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span> <span class="kw">struct</span> Helper;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TU_Ticket <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="dt">int</span> latest<span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>is_complete_type<span class="op">(</span>substitute<span class="op">(^^</span>Helper,</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>                                       <span class="op">{</span> std<span class="op">::</span>meta<span class="op">::</span>reflect_value<span class="op">(</span>k<span class="op">)</span> <span class="op">})))</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span>k;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> k;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="dt">void</span> increment<span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(</span>substitute<span class="op">(^^</span>Helper,</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>                                <span class="op">{</span> std<span class="op">::</span>meta<span class="op">::</span>reflect_value<span class="op">(</span>latest<span class="op">())})</span>,</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>                     <span class="op">{})</span>;</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> x <span class="op">=</span> TU_Ticket<span class="op">::</span>latest<span class="op">()</span>;  <span class="co">// x initialized to 0.</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span> TU_Ticket<span class="op">::</span>increment<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> y <span class="op">=</span> TU_Ticket<span class="op">::</span>latest<span class="op">()</span>;  <span class="co">// y initialized to 1.</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span> TU_Ticket<span class="op">::</span>increment<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> z <span class="op">=</span> TU_Ticket<span class="op">::</span>latest<span class="op">()</span>;  <span class="co">// z initialized to 2.</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>x <span class="op">==</span> <span class="dv">0</span><span class="op">)</span>;</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>y <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>z <span class="op">==</span> <span class="dv">2</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>On Compiler Explorer: <a href="https://godbolt.org/z/e1r8q3sWv">EDG</a>, <a href="https://godbolt.org/z/z4KKe5e57">Clang</a>.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="proposal-details"><span class="header-section-number">3</span>
Proposal Details<a href="#proposal-details" class="self-link"></a></h1>
<h2 data-number="3.1" id="constant-evaluation-order"><span class="header-section-number">3.1</span> Constant evaluation order<a href="#constant-evaluation-order" class="self-link"></a></h2>
<p>In C++23, “constant evaluation” produces pure values without
observable side-effects and thus the order in which constant-evaluation
occurs is immaterial. In fact, while the language is designed to permit
constant evaluation to happen at compile time, an implementation is not
strictly required to take advantage of that possibility.</p>
<p>Some of the proposed metafunctions, however, have side-effects that
have an effect on the remainder of the program. For example, we provide
a <code class="sourceCode cpp">define_aggregate</code> metafunction that
provides a definition for a given class. Clearly, we want the effect of
calling that metafunction to be “prompt” in a lexical-order sense. For
example:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(^^</span>S, <span class="op">{})</span>;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  S s;  <span class="co">// S should be defined at this point.</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>Hence this proposal also introduces constraints on constant
evaluation as follows…</p>
<p>First, consteval blocks (from <span class="citation" data-cites="P3289R1"><a href="https://wg21.link/p3289r1" role="doc-biblioref">[P3289R1]</a></span>) have the property that their
evaluation must occur and must succeed in a valid C++ program. We
require that a programmer can count on those evaluations occurring
exactly once and completing at translation time.</p>
<p>Second, we sequence consteval blocks within the lexical order.
Specifically, we require that the evaluation of a non-dependent
consteval block occurs before the implementation checks the validity of
source constructs lexically following them.</p>
<p>Those constraints are mostly intuitive, but they are a significant
change to the underlying principles of the current standard in this
respect.</p>
<p><span class="title"><span class="citation" data-cites="P2758R4"><a href="https://wg21.link/p2758r4" role="doc-biblioref">[P2758R4]
(Emitting messages at compile time)</a></span></span> also has to deal
with side effects during constant evaluation. However, those effects
(“output”) are of a slightly different nature in the sense that they can
be buffered until a manifestly constant-evaluated expression/conversion
has completed. “Buffering” a class type completion is not practical
(e.g., because other metafunctions may well depend on the completed
class type). Still, we are not aware of incompatibilities between our
proposal and P2758.</p>
<h2 data-number="3.2" id="reachability-and-injected-declarations"><span class="header-section-number">3.2</span> Reachability and injected
declarations<a href="#reachability-and-injected-declarations" class="self-link"></a></h2>
<p>Certain metafunctions (e.g.,
<code class="sourceCode cpp">members_of</code>) return reflections that
represent entities without ever naming those entities in source code
(i.e., eliding lookup). Although it is often clear which entities should
be returned from the perspective of a reader, or even the perspective of
an implementation, core wording has no notion that directly corresponds
to “compilation state”.</p>
<p>Lookup is rather defined in terms of “reachability”, which is roughly
a mapping from a “program point” to the set of declarations
<em>reachable</em> from that point. Lookup frequently occurs from a
single point, but template instantiation (and a few other niche
circumstances) can lead to lookup taking place from multiple points
(i.e., the point in a template from which a name is specified, and the
point from which the template was instantiated). The set of points from
which lookup takes place is the <em>instantiation context</em>
([module.context]).</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="dt">int</span> fn<span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="co">/*P1*/</span> T<span class="op">::</span>value;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span> <span class="kw">static</span> <span class="kw">const</span> <span class="dt">int</span> value <span class="op">=</span> <span class="dv">42</span>; <span class="op">}</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="co">/*P2*/</span> fn<span class="op">&lt;</span>S<span class="op">&gt;()</span>;</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">// The instantiation context when looking up &#39;S::value&#39; in &#39;fn&lt;T&gt;&#39; is {P1, P2}.</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Even though &#39;S&#39; is not found from P1, it is found from P2; lookup succeeds.</span></span></code></pre></div>
</blockquote>
</div>
<p>This works because the notion of template instantiation is baked into
the definition of “instantiation context”, which is thereafter used to
define lookup. But we have no such benefit in the case of metafunctions
like <code class="sourceCode cpp">members_of</code>, which do not
utilize template instantiation.</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">size_t</span> count_fields<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info Ty<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="co">/*P1*/</span> nonstatic_data_members_of<span class="op">(</span>Ty<span class="op">).</span>size<span class="op">()</span>;</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span> <span class="dt">int</span> i, j, k; <span class="op">}</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span><span class="co">/*P2*/</span> count_fields<span class="op">(^^</span>S<span class="op">)</span> <span class="op">==</span> <span class="dv">3</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>If we naively define
<code class="sourceCode cpp">nonstatic_data_members_of</code> to return
members reachable from the “point of call”, then the above code would
fail: after all, <code class="sourceCode cpp">S</code> is not reachable
from <code class="sourceCode cpp"><em>P1</em></code>. We instead must
define the declarations to be those reachable from where constant
evaluation begins (i.e.,
<code class="sourceCode cpp"><em>P2</em></code>). We encode this idea in
our definition of the <em>evaluation context</em>:</p>
<div class="std">
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_1" id="pnum_1">22</a></span>
During the evaluation of a manifestly constant-evaluated expression
<code class="sourceCode cpp"><em>M</em></code>, the evaluation context
of an expression <code class="sourceCode cpp"><em>E</em></code>
comprises […] the instantiation context of
<code class="sourceCode cpp"><em>M</em></code> ([module.context]), […]
.</p>
</div>
</blockquote>
</div>
<p>This gives the tool needed to define the declarations returned by
<code class="sourceCode cpp">members_of</code> to be (roughly) those
reachable from the <em>evaluation context</em>. However, a second
problem related to reachability is posed by
<code class="sourceCode cpp">define_aggregate</code>.</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> std<span class="op">::</span>meta<span class="op">::</span>info make_defn<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info Cls, std<span class="op">::</span>meta<span class="op">::</span>info Mem<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Synthesizes:</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   struct Mem {};</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   struct Cls { Mem m; };</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="co">/*P1*/</span> define_aggregate<span class="op">(</span>Cls, <span class="op">{</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    data_member_spec<span class="op">(</span><span class="co">/*P2*/</span> define_aggregate<span class="op">(</span>Mem, <span class="op">{})</span>, <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;m&quot;</span><span class="op">})</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">})</span>;</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">/* P3*/</span> <span class="kw">struct</span> C;</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">/* P4*/</span> <span class="kw">struct</span> M;</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span><span class="co">/*P5*/</span> is_type<span class="op">(</span>make_defn<span class="op">(^^</span>C, <span class="op">^^</span>M<span class="op">))</span> <span class="co">/*P6*/</span><span class="op">)</span>;</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co">/*P7*/</span> C obj;</span></code></pre></div>
</blockquote>
</div>
<p>Although we want this code to be valid, we have several obstacles to
navigate.</p>
<ol type="1">
<li>How can definitions for <code class="sourceCode cpp">C</code> and
<code class="sourceCode cpp">M</code> be defined from
<code class="sourceCode cpp"><em>P1</em></code> and
<code class="sourceCode cpp"><em>P2</em></code> when no declarations of
those classes are reachable from those program points?</li>
<li>Where are the points of declaration for the generated definitions of
<code class="sourceCode cpp">C</code> and
<code class="sourceCode cpp">M</code> (i.e., from what program points
will the generated definitions be reachable)?</li>
<li>How can we ensure that the definition of
<code class="sourceCode cpp">M</code> is reachable during the evaluation
of <code class="sourceCode cpp">define_aggregate</code> on
<code class="sourceCode cpp">C</code>?</li>
</ol>
<p>The prior discourse regarding
<code class="sourceCode cpp">members_of</code> gives a straightforward
answer to (1); the <code class="sourceCode cpp">define_aggregate</code>
function is defined in terms of the <em>evaluation context</em>, which
makes available all declarations reachable from
<code class="sourceCode cpp"><em>P5</em></code>.</p>
<p>An answer to (2) can be seen by considering the declarations at
<code class="sourceCode cpp"><em>P3</em></code>,
<code class="sourceCode cpp"><em>P4</em></code>, and
<code class="sourceCode cpp"><em>P7</em></code>: Since we want the
declaration of <code class="sourceCode cpp">obj</code> to be
well-formed, the generated definition of
<code class="sourceCode cpp">C</code> must precede
<code class="sourceCode cpp"><em>P7</em></code>. On the other hand,
placing the definition of <code class="sourceCode cpp"><em>C</em></code>
prior to <code class="sourceCode cpp"><em>P4</em></code> would weirdly
place the definition of the class <code class="sourceCode cpp">C</code>,
which contains a data member of type
<code class="sourceCode cpp">M</code>, prior to the declaration of
<code class="sourceCode cpp">M</code> itself. We propose that the point
of declaration for all definitions generated by
<code class="sourceCode cpp">define_aggregate</code> immediately follows
the end of the manifestly constant-evaluated expression that produces
the definition: In this case, just prior to
<code class="sourceCode cpp"><em>P6</em></code>.</p>
<p>This leaves one gap, and it is the question posed by (3): If the
definition of <code class="sourceCode cpp">M</code>, generated by
evaluation of <code class="sourceCode cpp">define_aggregate<span class="op">(</span>Mem, <span class="op">{})</span></code>,
is located just prior to
<code class="sourceCode cpp"><em>P6</em></code>, then the definition is
still not reachable from the evaluation context (such as we have defined
it) during evaluation of <code class="sourceCode cpp">define_aggregate<span class="op">(</span>Cls, <span class="op">...)</span></code>.</p>
<p>Circling back to “reachability” as a mapping from program points to
declarations, there are two clear paths forward: Either modify which
declarations are reachable from a program point, or modify the set of
program points in the evaluation context. We choose the later approach,
and attempt to provide some machinery that can be reused for future
“generative reflection” proposals.</p>
<p>We begin by specially indicating that the generated definitions of
<code class="sourceCode cpp">C</code> and
<code class="sourceCode cpp">M</code> are not just declarations, but
<em>injected declarations</em>, and that such injected declarations are
<em>produced</em> by an evaluation of an expression. The reachability of
these declarations is evidently different from other declarations: It
depends not only on a program point, but also on which compile-time
evaluations of expressions (which have no relation to lexical ordering)
are <em>sequenced after</em> the production of the injected
declarations.</p>
<p>To bridge the world of program points to the world of sequenced
evaluations, we introduce a notion dual to “injected declarations”: For
every injected declaration, there is a corresponding <em>synthesized
point</em>. Injected points have a special property: the <em>only</em>
declaration reachable from a synthesized point is its corresponding
injected declaration. Jumping back to our above example, joining the
synthesized point of the injected declaration of
<code class="sourceCode cpp">M</code> to our evaluation context gives
exactly what is needed for <code class="sourceCode cpp">M</code> to be
usable during the definition of <code class="sourceCode cpp">C</code>.
More precisely: <code class="sourceCode cpp">M</code> is reachable
during the definition of <code class="sourceCode cpp">C</code> because
the evaluation of the expression that produces the definition of
<code class="sourceCode cpp">M</code> is <em>sequenced before</em> the
evalauation of the expression that produces
<code class="sourceCode cpp">C</code>. This is captured by our full and
final definition of the evaluation context:</p>
<div class="std">
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_2" id="pnum_2">22</a></span>
The <em>evaluation context</em> is a set of points within the program
that determines which declarations are found by certain expressions used
for reflection. During the evaluation of a manifestly constant-evaluated
expression <code class="sourceCode cpp"><em>M</em></code>, the
evaluation context of an expression
<code class="sourceCode cpp"><em>E</em></code> comprises the union
of</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_3" id="pnum_3">(22.1)</a></span>
the instantiation context of
<code class="sourceCode cpp"><em>M</em></code> ([module.context]),
and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_4" id="pnum_4">(22.2)</a></span>
the synthesized points corresponding to any injected declarations
([expr.const]) produced by evaluations sequenced before the next
evaluation of <code class="sourceCode cpp"><em>E</em></code>.</li>
</ul>
</div>
</blockquote>
</div>
<p>Lastly, we clarify that during the definition of an <em>injected
declaration</em>, the instantiation context consists of the
<em>evaluation context</em> of the expression that is producing the
declaration. In our example above, this ensures that the definition of
<code class="sourceCode cpp"><em>M</em></code> is reachable not just
from the invocation of
<code class="sourceCode cpp">define_aggregate</code> for
<code class="sourceCode cpp">C</code>, but from within the actual
generated definition of
<code class="sourceCode cpp"><em>C</em></code>.</p>
<p>This machinery is “off in the weeds” of technicalities related to
modules, lookup, etc., but we believe (hope?) that it provides a sound
basis upon which to build generative reflection within the framework
provided by core language wording: not only for P2996, but for future
papers as well.</p>
<h2 data-number="3.3" id="restrictions-on-injected-declarations"><span class="header-section-number">3.3</span> Restrictions on injected
declarations<a href="#restrictions-on-injected-declarations" class="self-link"></a></h2>
<p>The advancement of this proposal through WG21 has naturally led to
increased scrutiny of the mechanisms here proposed. One such area is the
possibility of leveraging injected declarations to observe failed
template substitutions. Consider the following example:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S;</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">struct</span> TCls <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="dt">bool</span> sfn<span class="op">()</span>  <span class="co">// #1</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">requires</span> <span class="op">([]</span> <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>          define_aggregate<span class="op">(^^</span>S, <span class="op">{})</span>;</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">}()</span>, <span class="kw">false</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span>;  <span class="co">// never selected</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="dt">bool</span> sfn<span class="op">()</span>  <span class="co">// #2</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">requires</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span>;   <span class="co">// always selected</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>TCls<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>sfn<span class="op">())</span>;</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>is_complete_type<span class="op">(^^</span>S<span class="op">))</span>;</span></code></pre></div>
</blockquote>
</div>
<p>The above example observes the effects of the failed substitution of
<code class="sourceCode cpp"><span class="pp">#1</span></code> by way of
the completeness of <code class="sourceCode cpp">S</code>. Such tricks
can be used to observe implementation details, like the order in which
overloads are checked, that may be unportable (and which implementations
might desire to change over time).</p>
<p>Our proposed solution, specified in [expr.const]/23.2, is to make it
ill-formed to produce an injected declaration from a manifestly
constant-evaluated expression <em>inside of</em> an instantiation to
<em>outside of</em> that instantiation, or visa versa. Because that
expression in the example above (<code class="sourceCode cpp">define_aggregate<span class="op">(^^</span>S, <span class="op">{})</span></code>)
is within the instantiation of the requires clause of <code class="sourceCode cpp">TCls<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>sfn</code>,
and the target scope of the injected declaration is outside of that same
instantiaton, the example becomes ill-formed (diagnostic required). Note
that this does not prevent writing
<code class="sourceCode cpp"><span class="kw">consteval</span></code>
function templates that wrap
<code class="sourceCode cpp">define_aggregate</code>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info R<span class="op">&gt;</span> <span class="kw">consteval</span> <span class="dt">bool</span> tfn<span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  define_aggregate<span class="op">(</span>R, <span class="op">{})</span>;</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S;</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> b <span class="op">=</span> tfn<span class="op">&lt;^^</span>S<span class="op">&gt;()</span>;</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OK, both manifestly constant-evaluated expression tfn&lt;^^S&gt;() and target scope of</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// injected declaration for &#39;S&#39; are in the global namespace</span></span></code></pre></div>
</blockquote>
</div>
<p>Nor does this rule prevent a class template from producing a
declaration whose target scope is the same specialization.</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">struct</span> TCls1 <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> Incomplete;</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(^^</span>Incomplete, <span class="op">{})</span>;</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">// OK, Incomplete is in the same instantiation as the define_aggregate call</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> b <span class="op">=</span> <span class="kw">false</span>;</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> TCls2 <span class="op">{</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="dt">bool</span> sfn<span class="op">()</span>  <span class="co">// #1</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">requires</span> <span class="op">(</span>TCls1<span class="op">&lt;</span>T<span class="op">&gt;::</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span>;  <span class="co">// never selected</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="dt">bool</span> sfn<span class="op">()</span>  <span class="co">// #2</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">requires</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span>;   <span class="co">// always selected</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>TCls<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>sfn<span class="op">())</span>;</span></code></pre></div>
</blockquote>
</div>
<p>Athough the instantiation of <code class="sourceCode cpp">TCls1<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span></code>
in the requires-clause of
<code class="sourceCode cpp"><span class="pp">#1</span></code> causes an
injected declaration to be produced, it is not discernibly a side-effect
of the failed substitution: Observing the side effect will first require
one to write (some moral equivalent of) <code class="sourceCode cpp">TCLs1<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>Incomplete</code>,
the act of which would otherwise itself trigger the same
side-effect.</p>
<p>Although this rule constrains the manner with which
<code class="sourceCode cpp">define_aggregate</code> can be used, we are
not aware of any motivating use cases for P2996 that are harmed. Worth
mentioning, however: the rule has more dire implications for other code
injection papers being considered by WG21, most notably <span class="citation" data-cites="P3294R2"><a href="https://wg21.link/p3294r2" role="doc-biblioref">[P3294R2]</a></span> (“<em>Code Injection With
Token Sequences</em>”). With this rule as it is, it becomes impossible
for e.g., the instantiation of a class template specialization <code class="sourceCode cpp">TCls<span class="op">&lt;</span>Foo<span class="op">&gt;</span></code>
to produce an injected declaration of <code class="sourceCode cpp">std<span class="op">::</span>formatter<span class="op">&lt;</span>TCls<span class="op">&lt;</span>Foo<span class="op">&gt;&gt;</span></code>
(since the target scope would be the global namespace).</p>
<p>In this context, we do believe that relaxations of the rule can be
considered: For instance, we ought to be able to say that the
instantiation of <code class="sourceCode cpp">std<span class="op">::</span>formatter<span class="op">&lt;</span>TCls<span class="op">&lt;</span>Foo<span class="op">&gt;&gt;</span></code>
is sequenced strictly after the instantiation of <code class="sourceCode cpp">TCls<span class="op">&lt;</span>Foo<span class="op">&gt;</span></code>,
and observations such as these might make it possible to permit such
injections without making it “discernible” whether they resulted from
failed substitutions. The key to such an approach would be to define a
partial order over the instantiations of a program, and to allow
constructs to be injected <em>across</em> instantiations when the
relative order of their respective instantiations is defined.</p>
<p>All of that said, these relaxations are not needed for the code
injection introduced by this proposal, and we do not seek to introduce
them at this time.</p>
<h2 data-number="3.4" id="data_member_spec-and-define_aggregate"><span class="header-section-number">3.4</span>
<code class="sourceCode cpp">data_member_spec</code> and
<code class="sourceCode cpp">define_aggregate</code><a href="#data_member_spec-and-define_aggregate" class="self-link"></a></h2>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> data_member_options <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> name_type <span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">requires</span> constructible_from<span class="op">&lt;</span>u8string, T<span class="op">&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">consteval</span> name_type<span class="op">(</span>T <span class="op">&amp;&amp;)</span>;</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">requires</span> constructible_from<span class="op">&lt;</span>string, T<span class="op">&gt;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">consteval</span> name_type<span class="op">(</span>T <span class="op">&amp;&amp;)</span>;</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">&lt;</span>name_type<span class="op">&gt;</span> name;</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> alignment;</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> bit_width;</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> no_unique_address <span class="op">=</span> <span class="kw">false</span>;</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> data_member_spec<span class="op">(</span>info type,</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>                                  data_member_options options<span class="op">)</span> <span class="op">-&gt;</span> info;</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> <span class="op">&lt;</span>reflection_range R <span class="op">=</span> initializer_list<span class="op">&lt;</span>info<span class="op">&gt;&gt;</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> define_aggregate<span class="op">(</span>info type_class, R<span class="op">&amp;&amp;)</span> <span class="op">-&gt;</span> info;</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p><code class="sourceCode cpp">data_member_spec</code> returns a
reflection of a data member description for a data member of given type.
Optional alignment, bit-field-width, and name can be provided as well.
An inner class <code class="sourceCode cpp">name_type</code>, which may
be implicitly constructed from any of several “string-like” types (e.g.,
<code class="sourceCode cpp">string_view</code>,
<code class="sourceCode cpp">u8string_view</code>, <code class="sourceCode cpp"><span class="dt">char8_t</span><span class="op">[]</span></code>,
<code class="sourceCode cpp">char_t<span class="op">[]</span></code>),
is used to represent the name. If a
<code class="sourceCode cpp">name</code> is provided, it must be a valid
identifier when interpreted as a sequence of code-units. Otherwise, the
name of the data member is unspecified.</p>
<p><code class="sourceCode cpp">define_aggregate</code> takes the
reflection of an incomplete class/struct/union type and a range of
reflections of data member descriptions and completes the given class
type with data members as described (in the given order). The given
reflection is returned. For now, only data member reflections are
supported (via <code class="sourceCode cpp">data_member_spec</code>) but
the API takes in a range of <code class="sourceCode cpp">info</code>
anticipating expanding this in the near future.</p>
<p>For example:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> U;</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  define_aggregate<span class="op">(^^</span>U, <span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  data_member_spec<span class="op">(^^</span><span class="dt">int</span><span class="op">)</span>,</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  data_member_spec<span class="op">(^^</span><span class="dt">char</span><span class="op">)</span>,</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  data_member_spec<span class="op">(^^</span><span class="dt">double</span><span class="op">)</span>,</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="op">})</span>;</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co">// U is now defined to the equivalent of</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="co">// union U {</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="co">//   int <em>_0</em>;</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co">//   char <em>_1</em>;</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="co">//   double <em>_2</em>;</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="co">// };</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> S;</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> s_int_refl <span class="op">=</span> define_aggregate<span class="op">(^^</span>S<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>, <span class="op">{</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>  data_member_spec<span class="op">(^^</span><span class="dt">int</span>, <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;i&quot;</span>, <span class="op">.</span>alignment<span class="op">=</span><span class="dv">64</span><span class="op">})</span>,</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>  data_member_spec<span class="op">(^^</span><span class="dt">int</span>, <span class="op">{.</span>name<span class="op">=</span><span class="st">u8&quot;こんにち&quot;</span><span class="op">})</span>,</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a><span class="op">})</span>;</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a><span class="co">// S&lt;int&gt; is now defined to the equivalent of</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a><span class="co">// template&lt;&gt; struct S&lt;int&gt; {</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="co">//   alignas(64) int i;</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="co">//               int こんにち;</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a><span class="co">// };</span></span></code></pre></div>
</blockquote>
</div>
<p>When defining a
<code class="sourceCode cpp"><span class="kw">union</span></code>, if
one of the alternatives has a non-trivial destructor, the defined union
will <em>still</em> have a destructor provided - that simply does
nothing. This allows implementing <a href="#a-simple-variant-type">variant</a> without having to further
extend support in <code class="sourceCode cpp">define_aggregate</code>
for member functions.</p>
<p>If <code class="sourceCode cpp">define_aggregate</code> is called
multiple times with the same arguments, all calls after the first will
have no effect. Calling
<code class="sourceCode cpp">define_aggregate</code> for a type that was
defined using other arguments, defined through other means, or is in the
process of being defined, is not a constant expression.</p>
<p>Revisions of this paper prior to P2996R8 named this function
<code class="sourceCode cpp">define_class</code>. We find
<code class="sourceCode cpp">define_aggregate</code> to be a better name
for a few reasons:</p>
<ol type="1">
<li>The capabilities of the function are quite limited, and are mostly
good for constructing aggregate types.</li>
<li>The new name provides good cause for forcing all data members to be
public. Private data members created through such an interface are of
very limited utility.</li>
<li>The name <code class="sourceCode cpp">define_class</code> is left
available for a future, more fully-featured API.</li>
</ol>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="wording"><span class="header-section-number">4</span> Wording<a href="#wording" class="self-link"></a></h1>
<p>The wording here is presented as a diff on top of <span class="title"><span class="citation" data-cites="P2996R10"><a href="https://wg21.link/p2996r10" role="doc-biblioref">[P2996R10]
(Reflection for C++26)</a></span></span>.</p>
<h2 data-number="4.1" id="language"><span class="header-section-number">4.1</span> Language<a href="#language" class="self-link"></a></h2>
<h3 class="unnumbered" id="lex.phases-phases-of-translation"><span>5.2
<a href="https://wg21.link/lex.phases">[lex.phases]</a></span> Phases of
translation<a href="#lex.phases-phases-of-translation" class="self-link"></a></h3>
<p>Modify the wording for phases 7-8 of <span>5.2 <a href="https://wg21.link/lex.phases">[lex.phases]</a></span> as
follows:</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_5" id="pnum_5">7-8</a></span>
[…]</p>
<p><span class="note"><span>[ <em>Note 1:</em> </span>The program is
ill-formed if any instantiation fails.<span> — <em>end
note</em> ]</span></span></p>
<p><span class="note"><span>[ <em>Note 2:</em> </span>Constructs that
are separately subject to instantiation are specified in
[temp.inst].<span> — <em>end note</em> ]</span></span></p>
<div class="addu">
<p>During the analysis and translation of tokens, certain expressions
are evaluated ([expr.const]). Constructs appearing at a program point
<code class="sourceCode cpp"><em>P</em></code> are analyzed in a context
where each side effect of evaluating an expression
<code class="sourceCode cpp"><em>E</em></code> as a full-expression is
complete if and only if</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_6" id="pnum_6">(7-8.1)</a></span>
<code class="sourceCode cpp"><em>E</em></code> is the evaluating
expression of a
<code class="sourceCode cpp"><em>consteval-block-declaration</em></code>
([dcl.pre]), and</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_7" id="pnum_7">(7-8.2)</a></span>
either that
<code class="sourceCode cpp"><em>consteval-block-declaration</em></code>
or the template definition from which it is instantiated is reachable
from</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_8" id="pnum_8">(7-8.2.1)</a></span>
<code class="sourceCode cpp"><em>P</em></code>, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_9" id="pnum_9">(7-8.2.2)</a></span>
a point immediately following the
<code class="sourceCode cpp"><em>class-specifier</em></code> of a class
for which <code class="sourceCode cpp"><em>P</em></code> is in a
complete-class context.</li>
</ul></li>
</ul>
<div class="example">
<span>[ <em>Example 1:</em> </span>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> S <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> Incomplete;</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> Inner <span class="op">{</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fn<span class="op">()</span> <span class="op">{</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">/* p1 */</span> Incomplete i; <span class="co">// OK, constructs at P1 are analyzed in a context where the side effect of</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                             <span class="co">// the call to define_aggregate is evaluated because:</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>                             <span class="co">// * E is the evaluating expression of a consteval block, and</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>                             <span class="co">// * P1 is in a complete-class context of S and the consteval block</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>                             <span class="co">//   is reachable from P3.</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>; <span class="co">/* p2 */</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(^^</span>Incomplete, <span class="op">{})</span>;</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>; <span class="co">/* p3 */</span></span></code></pre></div>
<span> — <em>end example</em> ]</span>
</div>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_10" id="pnum_10">8</a></span>
Translated translation units are combined and all external entity
references are resolved. Library components are linked to satisfy
external references to entities not defined in the current translation.
All such translator output is collected into a program image which
contains information needed for execution in its execution
environment.</p>
</blockquote>
</div>
<h3 class="unnumbered" id="basic.def-declarations-and-definitions"><span>6.2 <a href="https://wg21.link/basic.def">[basic.def]</a></span> Declarations
and definitions<a href="#basic.def-declarations-and-definitions" class="self-link"></a></h3>
<p>Replace
<code class="sourceCode cpp"><em>static_assert-declaration</em></code>
and <code class="sourceCode cpp"><em>empty-declaration</em></code> with
<code class="sourceCode cpp"><em>vacant-decalaration</em></code>, which
also encompasses consteval blocks:</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_11" id="pnum_11">2</a></span>
Each entity declared by a
<code class="sourceCode cpp"><em>declaration</em></code> is also
<em>defined</em> by that declaration unless:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_12" id="pnum_12">(2.1)</a></span>
it declares a function without specifying the function’s body
([dcl.fct.def]),</li>
</ul>
<p>[…]</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_13" id="pnum_13">(2.10)</a></span>
it is an <code class="sourceCode cpp"><em>alias-declaration</em></code>
([dcl.typedef]),</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_14" id="pnum_14">(2.11-)</a></span>
it is a
<code class="sourceCode cpp"><em>namespace-alias-definition</em></code>
([namespace.alias])</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_15" id="pnum_15">(2.11)</a></span>
it is a <code class="sourceCode cpp"><em>using-declaration</em></code>
([namespace.udecl]),</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_16" id="pnum_16">(2.12)</a></span>
it is a <code class="sourceCode cpp"><em>deduction-guide</em></code>
([temp.deduct.guide]),</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_17" id="pnum_17">(2.13)</a></span>
it is a <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode default"><em>static_assert-declaration</em></code></span></del></span>
<span class="addu"><code class="sourceCode cpp"><em>vacant-declaration</em></code></span>
([dcl.pre]),</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_18" id="pnum_18">(2.14)</a></span>
it is an
<code class="sourceCode cpp"><em>attribute-declaration</em></code>
([dcl.pre]),</li>
<li><span class="rm" style="color: #bf0303"><del><span class="marginalizedparent"><a class="marginalized" href="#pnum_19" id="pnum_19">(2.15)</a></span>
it is an
<span><code class="sourceCode default"><em>empty-declaration</em></code></span>
([dcl.pre])</del></span>,</li>
</ul>
</blockquote>
</div>
<h3 class="unnumbered" id="basic.def.odr-one-definition-rule"><span>6.3
<a href="https://wg21.link/basic.def.odr">[basic.def.odr]</a></span>
One-definition rule<a href="#basic.def.odr-one-definition-rule" class="self-link"></a></h3>
<p>Modify paragraph 10.1 to prevent <code class="sourceCode cpp"><span class="op">*</span><span class="kw">this</span></code>
from being <em>odr-usable</em> in a consteval block:</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_20" id="pnum_20">10</a></span>
A local entity ([basic.pre]) is <em>odr-usable</em> in a scope
([basic.scope.scope]) if</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_21" id="pnum_21">(10.1)</a></span>
either the local entity is not <code class="sourceCode cpp"><span class="op">*</span><span class="kw">this</span></code>,
or an enclosing class<span class="addu">, consteval block,</span> or
non-lambda function parameter scope exists and, if the innermost such
scope is a function parameter scope, it corresponds to a non-static
member function, and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_22" id="pnum_22">(10.2)</a></span>
for each intervening scope ([basic.scope.scope]) between the point at
which the entity is introduced and the scope (where <code class="sourceCode cpp"><span class="op">*</span><span class="kw">this</span></code>
is considered to be introduced within the innermost enclosing class or
non-lambda function defintion scope), either:
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_23" id="pnum_23">(10.2.1)</a></span>
the intervening scope is a block scope, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_24" id="pnum_24">(10.2.2)</a></span>
the intervening scope is the function parameter scope of a
<code class="sourceCode cpp"><em>lambda-expression</em></code> or
<code class="sourceCode cpp"><em>requires-expression</em></code>,
or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_25" id="pnum_25">(10.2.3)</a></span>
the intervening scope is the lambda scope of a
<code class="sourceCode cpp"><em>lambda-expression</em></code> that has
a <code class="sourceCode cpp"><em>simple-capture</em></code> naming the
entity or has a
<code class="sourceCode cpp"><em>capture-default</em></code>, and the
block scope of the
<code class="sourceCode cpp"><em>lambda-expression</em></code> is also
an intervening scope.</li>
</ul></li>
</ul>
<p>If a local entity is odr-used in a scope in which it is not
odr-usable, the program is ill-formed.</p>
</blockquote>
</div>
<p>Prepend before paragraph 15 of <span>6.3 <a href="https://wg21.link/basic.def.odr">[basic.def.odr]</a></span>:</p>
<div class="std">
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_26" id="pnum_26">15pre</a></span>
If a class <code class="sourceCode cpp">C</code> is defined in a
translation unit as a result of a call to a specialization of <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>define_aggregate</code>
and another translation unit contains a definition of
<code class="sourceCode cpp">C</code> that is not a result of calling
the same specialization with the same function arguments, the program is
ill-formed; a diagnostic is required only if
<code class="sourceCode cpp">C</code> is attached to a named module and
a prior definition is reachable at the point where a later definition
occurs.</p>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_27" id="pnum_27">15</a></span>
For any <span class="addu">other</span> definable item
<code class="sourceCode cpp">D</code> with definitions in multiple
translation units,</p>
<ul>
<li>if <code class="sourceCode cpp">D</code> is a non-inline
non-templated function or variable, or</li>
<li>if the definitions in different translation units do not satisfy the
following requirements,</li>
</ul>
<p>the program is ill-formed; a diagnostic is required only if the
definable item is attached to a named module and a prior definition is
reachable at the point where a later definition occurs. […]</p>
</blockquote>
</div>
<h3 class="unnumbered" id="basic.scope.consteval-consteval-block-scope">6.4.5+
[basic.scope.consteval] Consteval block scope<a href="#basic.scope.consteval-consteval-block-scope" class="self-link"></a></h3>
<p>Add a new section for consteval block scopes following <span>6.4.5 <a href="https://wg21.link/basic.scope.lambda">[basic.scope.lambda]</a></span>:</p>
<div class="std">
<blockquote>
<div class="addu">
<p><strong>Consteval block scope [basic.scope.consteval]</strong></p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_28" id="pnum_28">1</a></span>
A
<code class="sourceCode cpp"><em>consteval-block-declaration</em></code>
<code class="sourceCode cpp">C</code> introduces a <em>consteval block
scope</em> that includes the
<code class="sourceCode cpp"><em>compound-statement</em></code> of
<code class="sourceCode cpp">C</code>.</p>
<div class="example">
<span>[ <em>Example 1:</em> </span>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x;</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x; <span class="co">// #1</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x;  <span class="co">// OK, distinct variable from #1</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<span> — <em>end example</em> ]</span>
</div>
</div>
</blockquote>
</div>
<h3 class="unnumbered" id="intro.execution-sequential-execution"><span>6.9.1 <a href="https://wg21.link/intro.execution">[intro.execution]</a></span>
Sequential execution<a href="#intro.execution-sequential-execution" class="self-link"></a></h3>
<p>Introduce a new kind of side effect in paragraph 7 (i.e., injecting a
declaration).</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_29" id="pnum_29">7</a></span>
Reading an object designated by a
<code class="sourceCode cpp"><span class="kw">volatile</span></code>
glvalue ([basic.lval]), modifying an object, <span class="addu">producing an injected declaration ([expr.const]),</span>
calling a library I/O function, or calling a function that does any of
those operations are all <em>side effects</em>, which are changes in the
state of the execution <span class="addu">or translation</span>
environment. <em>Evaluation</em> of an expression (or a subexpression)
in general includes both value computations (including determining the
identity of an object for glvalue evaluation and fetching a value
previously assigned to an object for prvalue evaluation) and initiation
of side effects. When a call to a library I/O function returns or an
access through a volatile glvalue is evaluated, the side effect is
considered complete, even though some external actions implied by the
call (such as the I/O itself) or by the
<code class="sourceCode cpp"><span class="kw">volatile</span></code>
access may not have completed yet.</p>
</blockquote>
</div>
<h3 class="unnumbered" id="expr.const-constant-expressions"><span>7.7 <a href="https://wg21.link/expr.const">[expr.const]</a></span> Constant
Expressions<a href="#expr.const-constant-expressions" class="self-link"></a></h3>
<p>Modify paragraph 4 to account for local variables in consteval block
scopes:</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_30" id="pnum_30">4</a></span>
An object <code class="sourceCode cpp"><em>o</em></code> is
<em>constexpr-referenceable</em> from a point
<code class="sourceCode cpp"><em>P</em></code> if</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_31" id="pnum_31">(4.1)</a></span>
<code class="sourceCode cpp"><em>o</em></code> has static storage
duration, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_32" id="pnum_32">(4.2)</a></span>
<code class="sourceCode cpp"><em>o</em></code> has automatic storage
duration, and letting <code class="sourceCode cpp">v</code> denote
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_33" id="pnum_33">(4.2.1)</a></span>
the variable corresponding to
<code class="sourceCode cpp"><em>o</em></code>’s complete object or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_34" id="pnum_34">(4.2.2)</a></span>
the variable whose lifetime that of
<code class="sourceCode cpp"><em>o</em></code> is extended,</li>
</ul>
the smallest scope enclosing <code class="sourceCode cpp">v</code> and
the smallest scope enclosing
<code class="sourceCode cpp"><em>P</em></code> that are neither
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_35" id="pnum_35">(4.2.3)</a></span>
block scopes nor</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_36" id="pnum_36">(4.2.4)</a></span>
function parameter scopes associated with a
<code class="sourceCode cpp"><em>requirement-parameter-list</em></code></li>
</ul>
are the same function parameter <span class="addu">or consteval block
scope</span>.</li>
</ul>
</blockquote>
</div>
<p>Add a bullet to paragraph 10 between 10.27 and 10.28 to disallow the
production of injected declarations from any core constant expression
that isn’t a consteval block.</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_37" id="pnum_37">10</a></span>
An expression <code class="sourceCode cpp"><em>E</em></code> is a
<em>core constant expression</em> unless the evaluation of
<code class="sourceCode cpp"><em>E</em></code>, following the rules of
the abstract machine ([intro.execution]), would evaluate one of the
following:</p>
<p>[…]</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_38" id="pnum_38">(10.27)</a></span>
a
<code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>
([expr.dynamic.cast]) expression,
<code class="sourceCode cpp"><span class="kw">typeid</span></code>
([expr.typeid]) expression, or
<code class="sourceCode cpp"><em>new-expression</em></code> ([expr.new])
that would throw an exception where no definition of the exception type
is reachable;</li>
<li><span class="addu"><span class="marginalizedparent"><a class="marginalized" href="#pnum_39" id="pnum_39">(10.27+)</a></span>
an expression that would produce an injected declaration, unless
<code class="sourceCode cpp"><em>E</em></code> is the evaluating
expression of a
<code class="sourceCode cpp"><em>consteval-block-declaration</em></code>
([dcl.pre]);</span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_40" id="pnum_40">(10.28)</a></span>
an <code class="sourceCode cpp"><em>asm-declaration</em></code>
([dcl.asm]);</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_41" id="pnum_41">(10.29)</a></span>
[…]</li>
</ul>
</blockquote>
</div>
<p>Add consteval block scopes to the scopes that introduce an immediate
function context:</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_42" id="pnum_42">24</a></span>
An expression or conversion is in an <em>immediate function context</em>
if it is potentially evaluated and either:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_43" id="pnum_43">(24.1)</a></span>
its innermost enclosing non-block scope is <span class="addu">either</span> a function parameter scope of an immediate
function <span class="addu">or a consteval block scope</span>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_44" id="pnum_44">(24.2)</a></span>
[…]</li>
</ul>
</blockquote>
</div>
<p>After the example following the definition of <em>manifestly
constant-evaluated</em>, introduce new terminology and rules for
injecting declarations and renumber accordingly:</p>
<div class="std">
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_45" id="pnum_45">30</a></span>
The evaluation of an expression can introduce one or more <em>injected
declarations</em>. Each such declaration has an associated
<em>synthesized point</em> which follows the last non-synthesized
program point in the translation unit containing that declaration. The
evaluation is said to <em>produce</em> the declaration.</p>
<p><span class="note13"><span>[ <em>Note 13:</em> </span>Special rules
concerning reachability apply to synthesized points (<span>10.7 <a href="https://wg21.link/module.reach">[module.reach]</a></span>).<span>
— <em>end note</em> ]</span></span></p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_46" id="pnum_46">31</a></span>
Let <code class="sourceCode cpp"><em>C</em></code> be a
<code class="sourceCode cpp"><em>consteval-block-declaration</em></code>
whose evaluating expression produces an injected declaration
<code class="sourceCode cpp"><em>D</em></code> ([expr.const]). The
program is ill-formed if a scope encloses exactly one of
<code class="sourceCode cpp"><em>C</em></code> or
<code class="sourceCode cpp"><em>D</em></code> that is either</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_47" id="pnum_47">(31.1)</a></span>
a function parameter scope,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_48" id="pnum_48">(31.2)</a></span>
a class scope, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_49" id="pnum_49">(31.3)</a></span>
a consteval block scope.</li>
</ul>
<div class="example">
<span>[ <em>Example 1:</em> </span>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">void</span> complete_type<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>meta<span class="op">::</span>define_aggregate<span class="op">(</span>r, <span class="op">{})</span>;</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S1;</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span> complete_type<span class="op">(^^</span>S1<span class="op">)</span>; <span class="op">}</span>  <span class="co">// OK</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info R<span class="op">&gt;</span> <span class="kw">consteval</span> <span class="dt">void</span> tfn1<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  complete_type<span class="op">(</span>R<span class="op">)</span>;</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S2;</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span> tfn1<span class="op">&lt;^^</span>S2<span class="op">&gt;()</span>; <span class="op">}</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OK, tfn1&lt;^^S2&gt;() and S2 are enclosed by the same scope</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info R<span class="op">&gt;</span> <span class="kw">consteval</span> <span class="dt">void</span> tfn2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span> complete_type<span class="op">(</span>R<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> b;</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S3;</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span> tfn2<span class="op">&lt;^^</span>S3<span class="op">&gt;()</span>; <span class="op">}</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// error: complete_type(^^S3) is enclosed tfn2&lt;^^S3&gt;, but S3 is not</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">struct</span> TCls <span class="op">{</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> S4;</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="dt">void</span> sfn<span class="op">()</span> <span class="kw">requires</span> <span class="op">([]</span> <span class="op">{</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> <span class="op">{</span> complete_type<span class="op">(^^</span>S4<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">})</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span> TCls<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>sfn<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">// error: TCls&lt;void&gt;::S4 is not enclosed by requires-clause lambda</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S5;</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Cls <span class="op">{</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span> complete_type<span class="op">(^^</span>S5<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// error: S5 is not enclosed by class Cls</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S6;</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="op">{</span> <span class="co">// #1</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> S7;</span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> <span class="op">{</span> <span class="co">// #2</span></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(^^</span>S6, <span class="op">{})</span>;</span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>      <span class="co">// error: consteval block #1 encloses consteval block #2 but not S6</span></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>    define_aggregate<span class="op">(^^</span>S7, <span class="op">{})</span>;  <span class="co">// OK, consteval block #1 encloses both #2 and S7</span></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<span> — <em>end example</em> ]</span>
</div>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_50" id="pnum_50">32</a></span>
The <em>evaluation context</em> is a set of points within the program
that determines the behavior of certain functions used for reflection
([meta.reflection]). During the evaluation of an expression
<code class="sourceCode cpp"><em>C</em></code> as a core constant
expression, the evaluation context of an evaluation
<code class="sourceCode cpp"><em>E</em></code> comprises <span class="addu">the union of</span></p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_51" id="pnum_51">(32.1)</a></span>
the instantiation context of
<code class="sourceCode cpp"><em>C</em></code> (<span>10.6 <a href="https://wg21.link/module.context">[module.context]</a></span>)<span class="addu">, and</span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_52" id="pnum_52">(32.2)</a></span>
<span class="addu">the synthesized points corresponding to any injected
declarations produced by evaluations sequenced before
<code class="sourceCode cpp"><em>E</em></code> (<span>6.9.1 <a href="https://wg21.link/intro.execution">[intro.execution]</a></span>)</span>.</li>
</ul>
</blockquote>
</div>
<h3 class="unnumbered" id="dcl.pre-preamble"><span>9.1 <a href="https://wg21.link/dcl.pre">[dcl.pre]</a></span> Preamble<a href="#dcl.pre-preamble" class="self-link"></a></h3>
<p>Introduce the non-terminal
<code class="sourceCode cpp"><em>vacant-declaration</em></code> in
paragraph 9.1 to encompass static assertions, empty declarations, and
consteval blocks:</p>
<div class="std">
<blockquote>
<div>
<div class="sourceCode" id="cb29"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>  <em>name-declaration</em>:</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <em>block-declaration</em></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <em>nodeclspec-function-declaration</em></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <em>function-definition</em></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <em>friend-type-declaration</em></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <em>template-declaration</em></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <em>deduction-guide</em></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <em>linkage-specification</em></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <em>namespace-definition</em></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="st">-   <em>empty-declaration</em></span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <em>attribute-declaration</em></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <em>module-import-declaration</em></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>  <em>block-declaration</em>:</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    <em>simple-declaration</em></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    <em>asm-declaration</em></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <em>namespace-alias-definition</em></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <em>using-declaration</em></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    <em>using-enum-declaration</em></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    <em>using-directive</em></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="st">-   <em>static_assert-declaration</em></span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>    <em>alias-declaration</em></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    <em>opaque-enum-declaration</em></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a><span class="va">+   <em>vacant-declaration</em></span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a><span class="va">+ <em>vacant-declaration</em>:</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a><span class="va">+    <em>static_assert-declaration</em></span></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a><span class="va">+    <em>empty-declaration</em></span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a><span class="va">+    <em>consteval-block-declaration</em></span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>  <em>static_assert-declaration</em>:</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>    static_assert ( <em>constant-expression</em> ) ;</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>    static_assert ( <em>constant-expression</em> , <em>static_assert-message</em> ) ;</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a><span class="va">+ <em>consteval-block-declaration</em>:</span></span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a><span class="va">+   consteval <em>compound-statement</em></span></span></code></pre></div>
</div>
</blockquote>
</div>
<p>Insert the following after paragraph 13 in relation to consteval
blocks:</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_53" id="pnum_53">13</a></span>
<em>Recommended practice</em>: When a
<code class="sourceCode cpp"><em>static_assert-declaration</em></code>
fails, […]</p>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_54" id="pnum_54">*</a></span>
The <em>evaluating expression</em> of a
<code class="sourceCode cpp"><em>consteval-block-declaration</em></code>
is an expression whose evaluation has the same associated side effects
as the
<code class="sourceCode cpp"><em>postfix-expression</em></code></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">[]</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="kw">consteval</span> <em>compound-statement</em> <span class="op">()</span></span></code></pre></div>
<p>The evaluating expression shall be a constant expression
([expr.const]).</p>
<p><span class="note"><span>[ <em>Note 1:</em> </span>The evaluating
expression of a
<code class="sourceCode cpp"><em>consteval-block-declaration</em></code>
can produce injected declarations as side effects ([expr.const]).<span>
— <em>end note</em> ]</span></span></p>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_55" id="pnum_55">14</a></span>
An <code class="sourceCode cpp"><em>empty-declaration</em></code> has no
effect.</p>
</blockquote>
</div>
<h3 class="unnumbered" id="class.mem.general-general"><span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>
General<a href="#class.mem.general-general" class="self-link"></a></h3>
<p>Modify the grammar for
<code class="sourceCode cpp"><em>member-declaration</em></code> as
follows:</p>
<div class="std">
<blockquote>
<div>
<div class="sourceCode" id="cb31"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>  <em>member-declaration</em>:</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <em>attribute-specifier-seq</em><sub>opt</sub> <em>decl-specifier-seq</em><sub>opt</sub> <em>member-declarator-list</em><sub>opt</sub>;</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <em>function-definition</em></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <em>friend-type-declaration</em></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <em>using-declaration</em></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <em>using-enum-declaration</em></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="st">-   <em>static_assert-declaration</em></span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="va">+   <em>vacant-declaration</em></span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <em>template-declaration</em></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <em>explicit-specialization</em></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <em>deduction-guide</em></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <em>alias-declaration</em></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <em>opaque-enum-declaration</em></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="st">-   <em>empty-declaration</em></span></span></code></pre></div>
</div>
</blockquote>
</div>
<p>Update paragraph 3 accordingly:</p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_56" id="pnum_56">3</a></span>
A <code class="sourceCode cpp"><em>member-declaration</em></code> does
not declare new members of the class if it is</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_57" id="pnum_57">(3.1)</a></span>
a friend declaration ([class.friend]),</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_58" id="pnum_58">(3.2)</a></span>
a <code class="sourceCode cpp"><em>deduction-guide</em></code>
([temp.deduct.guide]),</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_59" id="pnum_59">(3.3)</a></span>
a <code class="sourceCode cpp"><em>template-declaration</em></code>
whose declaration is one of the above,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_60" id="pnum_60">(3.4)</a></span>
a <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode default"><em>static_assert-declaration</em></code></span>,</del></span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_61" id="pnum_61">(3.5)</a></span>
a <code class="sourceCode cpp"><em>using-declaration</em></code>
([namespace.udecl]) , or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_62" id="pnum_62">(3.6)</a></span>
<span class="rm" style="color: #bf0303"><del>an
<span><code class="sourceCode default"><em>empty-declaration</em></code></span>.</del></span>
<span class="addu">a
<code class="sourceCode cpp"><em>vacant-declaration</em></code>.</span></li>
</ul>
</blockquote>
</div>
<p>Add a new paragraph to the end of the section defining <em>data
member description</em>:</p>
<div class="std">
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_63" id="pnum_63">29+</a></span>
A <em>data member description</em> is a quintuple
(<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) describing the
potential declaration of a nonstatic data member where</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_64" id="pnum_64">(29+.1)</a></span>
<code class="sourceCode cpp"><em>T</em></code> is a type or type
alias,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_65" id="pnum_65">(29+.2)</a></span>
<code class="sourceCode cpp"><em>N</em></code> is an
<code class="sourceCode cpp"><em>identifier</em></code> or <code class="sourceCode cpp"><span class="op">-</span><span class="dv">1</span></code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_66" id="pnum_66">(29+.3)</a></span>
<code class="sourceCode cpp"><em>A</em></code> is an alignment or <code class="sourceCode cpp"><span class="op">-</span><span class="dv">1</span></code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_67" id="pnum_67">(29+.4)</a></span>
<code class="sourceCode cpp"><em>W</em></code> is a bit-field width or
<code class="sourceCode cpp"><span class="op">-</span><span class="dv">1</span></code>,
and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_68" id="pnum_68">(29+.5)</a></span>
<code class="sourceCode cpp"><em>NUA</em></code> is a boolean
value.</li>
</ul>
<p>Two data member descriptions are equal if each of their respective
components are same types, same identifiers, and equal values.</p>
<div class="note">
<p><span>[ <em>Note 1:</em> </span>The components of a data member
description describe a data member such that</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_69" id="pnum_69">(29+.6)</a></span>
its type is specified using the type or type alias given by
<code class="sourceCode cpp"><em>T</em></code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_70" id="pnum_70">(29+.7)</a></span>
it is declared with the name given by
<code class="sourceCode cpp"><em>N</em></code> if <code class="sourceCode cpp"><em>N</em> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span></code>
and is otherwise unnamed,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_71" id="pnum_71">(29+.8)</a></span>
it is declared with the
<code class="sourceCode cpp"><em>alignment-specifier</em></code>
(<span>9.12.2 <a href="https://wg21.link/dcl.align">[dcl.align]</a></span>) given by
<code class="sourceCode cpp"><span class="kw">alignas</span><span class="op">(</span><em>A</em><span class="op">)</span></code>
if <code class="sourceCode cpp"><em>A</em> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span></code>
and is otherwise declared without an
<code class="sourceCode cpp"><em>alignment-specifier</em></code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_72" id="pnum_72">(29+.9)</a></span>
it is a bit-field (<span>11.4.10 <a href="https://wg21.link/class.bit">[class.bit]</a></span>) with the
width given by <code class="sourceCode cpp"><em>W</em></code> if <code class="sourceCode cpp"><em>W</em> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span></code>
and is otherwise not a bit-field,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_73" id="pnum_73">(29+.10)</a></span>
it is declared with the attribute <code class="sourceCode cpp"><span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span></code>
(<span>9.12.12 <a href="https://wg21.link/dcl.attr.nouniqueaddr">[dcl.attr.nouniqueaddr]</a></span>)
if <code class="sourceCode cpp"><em>NUA</em></code> is
<code class="sourceCode cpp"><span class="kw">true</span></code> and is
otherwise declared without that attribute.</li>
</ul>
<p>Data member descriptions are represented by reflections (<span>6.8.2
<a href="https://wg21.link/basic.fundamental">[basic.fundamental]</a></span>)
returned by <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>data_member_spec</code>
([meta.reflection.define.aggregate]) and can be reified as data members
of a class using <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>define_aggregate</code>
([meta.reflection.define.aggregate]).<span> — <em>end
note</em> ]</span></p>
</div>
</div>
</blockquote>
</div>
<h3 class="unnumbered" id="class.union.anon-anonymous-unions"><span>11.5.2 <a href="https://wg21.link/class.union.anon">[class.union.anon]</a></span>
Anonymous unions<a href="#class.union.anon-anonymous-unions" class="self-link"></a></h3>
<p>Replace
<code class="sourceCode cpp"><em>static_assert-declaration</em></code>
with <code class="sourceCode cpp"><em>vacant-declaration</em></code> in
paragraph 1. <span class="ednote" style="color: #0000ff">[ Editor&#39;s
note: This refactor allows putting in an
<code class="sourceCode default"><em>empty-declaration</em></code> into
an anonymous union, which is kind of a consistency drive by with other
classes. ]</span></p>
<div class="std">
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_74" id="pnum_74">1</a></span>
[…] Each <code class="sourceCode cpp"><em>member-declaration</em></code>
in the <code class="sourceCode cpp"><em>member-specification</em></code>
of an anonymous union shall either define one or more public non-static
data members or be a <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode default"><em>static_assert-declaration</em></code></span></del></span>
<span class="addu"><code class="sourceCode cpp"><em>vacant-declaration</em></code></span>.
[…]</p>
</blockquote>
</div>
<h2 data-number="4.2" id="library"><span class="header-section-number">4.2</span> Library<a href="#library" class="self-link"></a></h2>
<h3 class="unnumbered" id="meta.reflection.synop-header-meta-synopsis">[meta.reflection.synop]
Header <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code>
synopsis<a href="#meta.reflection.synop-header-meta-synopsis" class="self-link"></a></h3>
<p>Add new functions to <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code></p>
<div class="std">
<blockquote>
<p><strong>Header <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code>
synopsis</strong></p>
<div>
<div class="sourceCode" id="cb32"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>namespace std::meta {</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  // ...</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  // [meta.reflection.result], expression result reflection</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  template&lt;class T&gt;</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    consteval info reflect_value(const T&amp; value);</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  template&lt;class T&gt;</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    consteval info reflect_object(T&amp; object);</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  template&lt;class T&gt;</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    consteval info reflect_function(T&amp; fn);</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="va">+ // [meta.reflection.define.aggregate], class definition generation</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="va">+ struct data_member_options;</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="va">+ consteval info data_member_spec(info type,</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="va">+                                 data_member_options options);</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="va">+ consteval bool is_data_member_spec(info r);</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="va">+ template &lt;reflection_range R = initializer_list&lt;info&gt;&gt;</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a><span class="va">+ consteval info define_aggregate(info type_class, R&amp;&amp;);</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>  // [meta.reflection.annotation], annotation reflection</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a> consteval vector&lt;info&gt; annotations_of(info item);</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a> consteval vector&lt;info&gt; annotations_of(info item, info type);</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a> template&lt;class T&gt;</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>   consteval optional&lt;T&gt; annotation_of(info item);</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a> template&lt;class T&gt;</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>   consteval bool has_annotation(info item);</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a> template&lt;class T&gt;</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>   consteval bool has_annotation(info item, T const&amp; value);</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="va">+ consteval info annotate(info item, info value, source_location loc = source_location::current());</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>  // [meta.reflection.unary.cat], primary type categories</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>  consteval bool is_void_type(info type);</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>  consteval bool is_null_pointer_type(info type);</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>  consteval bool is_integral_type(info type);</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>  // ...</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
</blockquote>
</div>
<h3 class="unnumbered" id="meta.reflection.names-reflection-names-and-locations">[meta.reflection.names]
Reflection names and locations<a href="#meta.reflection.names-reflection-names-and-locations" class="self-link"></a></h3>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">bool</span> has_identifier<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_75" id="pnum_75">1</a></span>
<em>Returns</em>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_76" id="pnum_76">(1.1)</a></span>
If <code class="sourceCode cpp">r</code> is an unnamed entity other than
a class that has a typedef name for linkage purposes (<span>9.2.4 <a href="https://wg21.link/dcl.typedef">[dcl.typedef]</a></span>), then
<code class="sourceCode cpp"><span class="kw">false</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_77" id="pnum_77">(1.2)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a class
type <code class="sourceCode cpp"><em>C</em></code>, then
<code class="sourceCode cpp"><span class="kw">true</span></code> when
either the <code class="sourceCode cpp"><em>class-name</em></code> of
<code class="sourceCode cpp"><em>C</em></code> is an identifier or
<code class="sourceCode cpp"><em>C</em></code> has a typedef name for
linkage purposes. Otherwise,
<code class="sourceCode cpp"><span class="kw">false</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_78" id="pnum_78">(1.3)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a
function, then
<code class="sourceCode cpp"><span class="kw">true</span></code> if the
function is not a function template specialization, constructor,
destructor, operator function, or conversion function. Otherwise,
<code class="sourceCode cpp"><span class="kw">false</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_79" id="pnum_79">(1.4)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a
function template, then
<code class="sourceCode cpp"><span class="kw">true</span></code> if
<code class="sourceCode cpp">r</code> does not represent a constructor
template, operator function template, or conversion function template.
Otherwise,
<code class="sourceCode cpp"><span class="kw">false</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_80" id="pnum_80">(1.5)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a
variable, then
<code class="sourceCode cpp"><span class="kw">false</span></code> if the
declaration of that variable was expanded from a function parameter
pack. Otherwise, <code class="sourceCode cpp"><span class="op">!</span>has_template_arguments<span class="op">(</span>r<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_81" id="pnum_81">(1.6)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a
structured binding, then
<code class="sourceCode cpp"><span class="kw">false</span></code> if the
declaration of that structured binding was expanded from a structured
binding pack. Otherwise,
<code class="sourceCode cpp"><span class="kw">true</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_82" id="pnum_82">(1.7)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a type
alias, then <code class="sourceCode cpp"><span class="op">!</span>has_template_arguments<span class="op">(</span>r<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_83" id="pnum_83">(1.8)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a
enumerator, non-static data member, template, namespace, or namespace
alias, then
<code class="sourceCode cpp"><span class="kw">true</span></code>.
Otherwise,
<code class="sourceCode cpp"><span class="kw">false</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_84" id="pnum_84">(1.9)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a direct
base class relationship, then <code class="sourceCode cpp">has_identifier<span class="op">(</span>type_of<span class="op">(</span>r<span class="op">))</span></code>.</li>
</ul>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_85" id="pnum_85">(1.10)</a></span>
Otherwise, <code class="sourceCode cpp">r</code> represents a data
member description (<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>);
<code class="sourceCode cpp"><em>N</em> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span></code>.</li>
</ul>
</div>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> string_view identifier_of<span class="op">(</span>info r<span class="op">)</span>;</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> u8string_view u8identifier_of<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_86" id="pnum_86">2</a></span>
Let <em>E</em> be UTF-8 if returning a
<code class="sourceCode cpp">u8string_view</code>, and otherwise the
ordinary literal encoding.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_87" id="pnum_87">3</a></span>
<em>Constant When</em>: <code class="sourceCode cpp">has_identifier<span class="op">(</span>r<span class="op">)</span></code>
is <code class="sourceCode cpp"><span class="kw">true</span></code> and
the identifier that would be returned (see below) is representable by
<code class="sourceCode cpp"><em>E</em></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_88" id="pnum_88">4</a></span>
<em>Returns</em>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_89" id="pnum_89">(4.1)</a></span>
If <code class="sourceCode cpp">r</code> represents a literal operator
or literal operator template, then the
<code class="sourceCode cpp"><em>ud-suffix</em></code> of the operator
or operator template.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_90" id="pnum_90">(4.2)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a class
type, then either the typedef name for linkage purposes or the
identifier introduced by the declaration of the represented type.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_91" id="pnum_91">(4.3)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents an
entity, then the identifier introduced by the declaration of that
entity.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_92" id="pnum_92">(4.4)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a direct
base class relationship, then <code class="sourceCode cpp">identifier_of<span class="op">(</span>type_of<span class="op">(</span>r<span class="op">))</span></code>
or <code class="sourceCode cpp">u8identifier_of<span class="op">(</span>type_of<span class="op">(</span>r<span class="op">))</span></code>,
respectively.</li>
</ul>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_93" id="pnum_93">(4.5)</a></span>
Otherwise, <code class="sourceCode cpp">r</code> represents a data
member description (<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>);
a <code class="sourceCode cpp">string</code> or
<code class="sourceCode cpp">u8string</code> respectively containing the
identifier <code class="sourceCode cpp"><em>N</em></code> encoded with
<code class="sourceCode cpp"><em>E</em></code>.</li>
</ul>
</div>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> source_location source_location_of<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_94" id="pnum_94">7</a></span>
<em>Returns</em>: If <code class="sourceCode cpp">r</code> represents a
value, a non-class type, <span class="rm" style="color: #bf0303"><del>or</del></span> the global namespace, <span class="addu">or a data member description,</span> then <code class="sourceCode cpp">source_location<span class="op">{}</span></code>.
Otherwise, an implementation-defined
<code class="sourceCode cpp">source_location</code> value.</p>
</blockquote>
</div>
<h3 class="unnumbered" id="meta.reflection.queries-reflection-queries">[meta.reflection.queries]
Reflection queries<a href="#meta.reflection.queries-reflection-queries" class="self-link"></a></h3>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">bool</span> is_bit_field<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_95" id="pnum_95">9</a></span>
<em>Returns</em>:
<code class="sourceCode cpp"><span class="kw">true</span></code> if
<code class="sourceCode cpp">r</code> represents a bit-field<span class="addu">, or if <code class="sourceCode cpp">r</code> represents a
data member description (<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>)
for which <code class="sourceCode cpp"><em>W</em></code> is not <code class="sourceCode cpp"><span class="op">-</span><span class="dv">1</span></code>.
Otherwise,
<code class="sourceCode cpp"><span class="kw">false</span></code></span>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> info type_of<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_96" id="pnum_96">33</a></span>
<em>Constant When</em>: <code class="sourceCode cpp">r</code> represents
a value, object, variable, function that is not a constructor or
destructor, enumerator, non-static data member, bit-field, <span class="rm" style="color: #bf0303"><del>or</del></span> direct base class
relationship<span class="addu">, or data member description</span>.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_97" id="pnum_97">34</a></span>
<em>Returns</em>: If <code class="sourceCode cpp">r</code> represents an
entity, object, or value, then a reflection of the type of what is
represented by <code class="sourceCode cpp">r</code>. Otherwise, if
<code class="sourceCode cpp">r</code> represents a direct base class
relationship, then a reflection of the type of the direct base class.
<span class="addu">Otherwise, for a data member description
(<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>),
a reflection of the type
<code class="sourceCode cpp"><em>T</em></code>.</span></p>
</blockquote>
</div>
<h3 class="unnumbered" id="meta.reflection.layout-reflection-layout-queries">[meta.reflection.layout]
Reflection layout queries<a href="#meta.reflection.layout-reflection-layout-queries" class="self-link"></a></h3>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">size_t</span> size_of<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_98" id="pnum_98">5</a></span>
<em>Constant When</em>: <code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
is a reflection of a type, object, value, variable of non-reference
type, non-static data member, <span class="rm" style="color: #bf0303"><del>or</del></span> direct base class
relationship, <span class="addu">or data member description</span>. If
<code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
represents a type <code class="sourceCode cpp"><em>T</em></code>, there
is a point within the evaluation context from which
<code class="sourceCode cpp"><em>T</em></code> is not incomplete.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_99" id="pnum_99">6</a></span>
<em>Returns</em>: If <code class="sourceCode cpp">r</code> represents a
non-static data member whose corresponding subobject has type
<code class="sourceCode cpp"><em>T</em></code>, <span class="addu">or a
data member description (<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>),</span>
then <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">(</span><em>T</em><span class="op">)</span></code>.
Otherwise, if <code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
represents a type <code class="sourceCode cpp">T</code>, then <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">)</span></code>.
Otherwise, <code class="sourceCode cpp">size_of<span class="op">(</span>type_of<span class="op">(</span>r<span class="op">))</span></code>.</p>
<p><span class="note"><span>[ <em>Note 1:</em> </span>The subobject
corresponding to a non-static data member of reference type has the same
size and alignment as the corresponding pointer type.<span> — <em>end
note</em> ]</span></span></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">size_t</span> alignment_of<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_100" id="pnum_100">7</a></span>
<em>Constant When</em>: <code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
is a reflection representing a type, object, variable, non-static data
member that is not a bit-field, <span class="rm" style="color: #bf0303"><del>or</del></span> direct base class
relationship, <span class="addu">or data member description</span>. If
<code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
represents a type <code class="sourceCode cpp"><em>T</em></code>, there
is a point within the evaluation context from which
<code class="sourceCode cpp"><em>T</em></code> is not incomplete.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_101" id="pnum_101">8</a></span>
<em>Returns</em>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_102" id="pnum_102">(8.1)</a></span>
If <code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
represents a type, variable, or object, then the alignment requirement
of the entity or object.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_103" id="pnum_103">(8.2)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a direct
base class relationship, then <code class="sourceCode cpp">alignment_of<span class="op">(</span>type_of<span class="op">(</span>r<span class="op">))</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_104" id="pnum_104">(8.3)</a></span>
Otherwise, if <code class="sourceCode cpp">r</code> represents a
non-static data member, then the alignment requirement of the subobject
associated with the represented entity within any object of type <code class="sourceCode cpp">parent_of<span class="op">(</span>r<span class="op">)</span></code>.</li>
</ul>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_105" id="pnum_105">(8.4)</a></span>
Otherwise, <code class="sourceCode cpp">r</code> represents a data
member description (<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>).
If <code class="sourceCode cpp"><em>A</em> <span class="op">!=</span> <span class="dv">1</span></code>,
then the value <code class="sourceCode cpp"><em>A</em></code>. Otherwise
<code class="sourceCode cpp"><span class="kw">alignof</span><span class="op">(</span><em>T</em><span class="op">)</span></code>.</li>
</ul>
</div>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">size_t</span> bit_size_of<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_106" id="pnum_106">9</a></span>
<em>Constant When</em>: <code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
is a reflection of a type, object, value, variable of non-reference
type, non-static data member, unnamed bit-field, <span class="rm" style="color: #bf0303"><del>or</del></span> direct base class
relationship<span class="addu">, or data member description</span>. If
<code class="sourceCode cpp">dealias<span class="op">(</span>r<span class="op">)</span></code>
represents a type <code class="sourceCode cpp"><em>T</em></code>, there
is a point within the evaluation context from which
<code class="sourceCode cpp"><em>T</em></code> is not incomplete.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_107" id="pnum_107">10</a></span>
<em>Returns</em>: If <code class="sourceCode cpp">r</code> represents a
non-static data member that is a bit-field or unnamed bit-field with
width <code class="sourceCode cpp"><em>W</em></code>, then
<code class="sourceCode cpp"><em>W</em></code>. <span class="addu">If
<code class="sourceCode cpp">r</code> represents a data member
description (<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>),
then <code class="sourceCode cpp"><em>W</em></code> if <code class="sourceCode cpp"><em>W</em> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span></code>,
otherwise <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">(</span><em>T</em><span class="op">)</span> <span class="op">*</span> CHAR_BIT</code>.</span>
Otherwise, <code class="sourceCode cpp">CHAR_BIT <span class="op">*</span> size_of<span class="op">(</span>r<span class="op">)</span></code>.</p>
</blockquote>
</div>
<h3 class="unnumbered" id="meta.reflection.define.aggregate-reflection-class-definition-generation">[meta.reflection.define.aggregate]
Reflection class definition generation<a href="#meta.reflection.define.aggregate-reflection-class-definition-generation" class="self-link"></a></h3>
<div class="std">
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_108" id="pnum_108">1</a></span>
The classes <code class="sourceCode cpp">data_member_options</code> and
<code class="sourceCode cpp">name_type</code> are consteval-only types
([basic.types.general]), and are not a structural types
([temp.param]).</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> data_member_options <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> name_type <span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">requires</span> constructible_from<span class="op">&lt;</span>u8string, T<span class="op">&gt;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">consteval</span> name_type<span class="op">(</span>T <span class="op">&amp;&amp;)</span>;</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">requires</span> constructible_from<span class="op">&lt;</span>string, T<span class="op">&gt;</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">consteval</span> name_type<span class="op">(</span>T <span class="op">&amp;&amp;)</span>;</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    variant<span class="op">&lt;</span>u8string, string<span class="op">&gt;</span> <em>contents</em>;    <span class="co">// <em>exposition only</em></span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>  optional<span class="op">&lt;</span>name_type<span class="op">&gt;</span> name;</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> alignment;</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> bit_width;</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> no_unique_address <span class="op">=</span> <span class="kw">false</span>;</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">requires</span> constructible_from<span class="op">&lt;</span>u8string, T<span class="op">&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> data_member_options<span class="op">::</span>name_type<span class="op">(</span>T<span class="op">&amp;&amp;</span> value<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_109" id="pnum_109">2</a></span>
<em>Effects</em>: Initializes
<code class="sourceCode cpp"><em>contents</em></code> with <code class="sourceCode cpp">u8string<span class="op">(</span>value<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">requires</span> constructible_from<span class="op">&lt;</span>string, T<span class="op">&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> data_member_options<span class="op">::</span>name_type<span class="op">(</span>T<span class="op">&amp;&amp;</span> value<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_110" id="pnum_110">3</a></span>
<em>Effects</em>: Initializes
<code class="sourceCode cpp"><em>contents</em></code> with <code class="sourceCode cpp">string<span class="op">(</span>value<span class="op">)</span></code>.</p>
<div class="note">
<p><span>[ <em>Note 1:</em>
</span><code class="sourceCode cpp">name_type</code> provides a simple
inner class that can be implicitly constructed from anything convertible
to <code class="sourceCode cpp">string</code> or
<code class="sourceCode cpp">u8string</code>. This allows a
<code class="sourceCode cpp">data_member_spec</code> to accept an
ordinary string literal (or
<code class="sourceCode cpp">string_view</code>,
<code class="sourceCode cpp">string</code>, etc) or a UTF-8 string
literal (or <code class="sourceCode cpp">u8string_view</code>,
<code class="sourceCode cpp">u8string</code>, etc) equally well.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> mem1 <span class="op">=</span> data_member_spec<span class="op">(^^</span><span class="dt">int</span>, <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;ordinary_literal_encoding&quot;</span><span class="op">})</span>;</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> mem2 <span class="op">=</span> data_member_spec<span class="op">(^^</span><span class="dt">int</span>, <span class="op">{.</span>name<span class="op">=</span><span class="st">u8&quot;utf8_encoding&quot;</span><span class="op">})</span>;</span></code></pre></div>
<span> — <em>end note</em> ]</span>
</div>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> info data_member_spec<span class="op">(</span>info type,</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>                                data_member_options options<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_111" id="pnum_111">4</a></span>
<em>Constant When</em>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_112" id="pnum_112">(4.1)</a></span>
<code class="sourceCode cpp">dealias<span class="op">(</span>type<span class="op">)</span></code>
represents a type <code class="sourceCode cpp">cv <em>T</em></code>
where <code class="sourceCode cpp"><em>T</em></code> is either an object
type or a reference type;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_113" id="pnum_113">(4.2)</a></span>
if
<code class="sourceCode cpp">options<span class="op">.</span>name</code>
contains a value, then:
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_114" id="pnum_114">(4.2.1)</a></span>
<code class="sourceCode cpp">holds_alternative<span class="op">&lt;</span>u8string<span class="op">&gt;(</span>options<span class="op">.</span>name<span class="op">-&gt;</span><em>contents</em><span class="op">)</span></code>
is <code class="sourceCode cpp"><span class="kw">true</span></code> and
<code class="sourceCode cpp">get<span class="op">&lt;</span>u8string<span class="op">&gt;(</span>options<span class="op">.</span>name<span class="op">-&gt;</span><em>contents</em><span class="op">)</span></code>
contains a valid identifier when interpreted with UTF-8, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_115" id="pnum_115">(4.2.2)</a></span>
<code class="sourceCode cpp">holds_alternative<span class="op">&lt;</span>string<span class="op">&gt;(</span>options<span class="op">.</span>name<span class="op">-&gt;</span><em>contents</em><span class="op">)</span></code>
is <code class="sourceCode cpp"><span class="kw">true</span></code> and
<code class="sourceCode cpp">get<span class="op">&lt;</span>string<span class="op">&gt;(</span>options<span class="op">.</span>name<span class="op">-&gt;</span><em>contents</em><span class="op">)</span></code>
contains a valid identifier when interpreted with the ordinary literal
encoding;</li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_116" id="pnum_116">(4.3)</a></span>
otherwise, if
<code class="sourceCode cpp">options<span class="op">.</span>name</code>
does not contain a value, then <code class="sourceCode cpp">options<span class="op">.</span>bit_width</code>
contains a value;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_117" id="pnum_117">(4.4)</a></span>
if <code class="sourceCode cpp">options<span class="op">.</span>alignment</code>
contains a value, it is an alignment value ([basic.align]) not less than
<code class="sourceCode cpp">alignment_of<span class="op">(</span>type<span class="op">)</span></code>;
and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_118" id="pnum_118">(4.5)</a></span>
if <code class="sourceCode cpp">options<span class="op">.</span>bit_width</code>
contains a value <code class="sourceCode cpp"><em>V</em></code>, then
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_119" id="pnum_119">(4.5.1)</a></span>
<code class="sourceCode cpp">is_integral_type<span class="op">(</span>type<span class="op">)</span> <span class="op">||</span> is_enumeration_type<span class="op">(</span>type<span class="op">)</span></code>
is
<code class="sourceCode cpp"><span class="kw">true</span></code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_120" id="pnum_120">(4.5.2)</a></span>
<code class="sourceCode cpp">options<span class="op">.</span>alignment</code>
does not contain a value,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_121" id="pnum_121">(4.5.3)</a></span>
<code class="sourceCode cpp">options<span class="op">.</span>no_unique_address</code>
is <code class="sourceCode cpp"><span class="kw">false</span></code>,
and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_122" id="pnum_122">(4.5.4)</a></span>
if <code class="sourceCode cpp"><em>V</em></code> equals
<code class="sourceCode cpp"><span class="dv">0</span></code> then
<code class="sourceCode cpp">options<span class="op">.</span>name</code>
does not contain a value.</li>
</ul></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_123" id="pnum_123">5</a></span>
<em>Returns</em>: A reflection of a data member description
(<code class="sourceCode cpp"><em>T</em></code>,
<code class="sourceCode cpp"><em>N</em></code>,
<code class="sourceCode cpp"><em>A</em></code>,
<code class="sourceCode cpp"><em>W</em></code>,
<code class="sourceCode cpp"><em>NUA</em></code>) (<span>11.4.1 <a href="https://wg21.link/class.mem.general">[class.mem.general]</a></span>)
where</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_124" id="pnum_124">(5.1)</a></span>
<code class="sourceCode cpp"><em>T</em></code> is the type or type alias
represented by <code class="sourceCode cpp">type</code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_125" id="pnum_125">(5.2)</a></span>
<code class="sourceCode cpp"><em>N</em></code> is either the identifier
encoded by
<code class="sourceCode cpp">options<span class="op">.</span>name</code>
or <code class="sourceCode cpp"><span class="op">-</span><span class="dv">1</span></code>
if
<code class="sourceCode cpp">options<span class="op">.</span>name</code>
is empty,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_126" id="pnum_126">(5.3)</a></span>
<code class="sourceCode cpp"><em>A</em></code> is either the alignment
value held by <code class="sourceCode cpp">options<span class="op">.</span>alignment</code>
or <code class="sourceCode cpp"><span class="op">-</span><span class="dv">1</span></code>
if <code class="sourceCode cpp">options<span class="op">.</span>alignment</code>
is empty,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_127" id="pnum_127">(5.4)</a></span>
<code class="sourceCode cpp"><em>W</em></code> is either the value held
by <code class="sourceCode cpp">options<span class="op">.</span>bit_width</code>
or <code class="sourceCode cpp"><span class="op">-</span><span class="dv">1</span></code>
if <code class="sourceCode cpp">options<span class="op">.</span>bit_width</code>
is empty, and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_128" id="pnum_128">(5.5)</a></span>
<code class="sourceCode cpp"><em>NUA</em></code> is the value held by
<code class="sourceCode cpp">options<span class="op">.</span>no_unique_address</code>.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_129" id="pnum_129">6</a></span>
<span class="note"><span>[ <em>Note 2:</em> </span>The returned
reflection value is primarily useful in conjunction with
<code class="sourceCode cpp">define_aggregate</code>. Certain other
functions in
<code class="sourceCode cpp">std<span class="op">::</span>meta</code>
(e.g., <code class="sourceCode cpp">type_of</code>,
<code class="sourceCode cpp">identifier_of</code>) can also be used to
query the characteristics indicated by the arguments provided to
<code class="sourceCode cpp">data_member_spec</code>.<span> — <em>end
note</em> ]</span></span></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> <span class="dt">bool</span> is_data_member_spec<span class="op">(</span>info r<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_130" id="pnum_130">7</a></span>
<em>Returns</em>:
<code class="sourceCode cpp"><span class="kw">true</span></code> if
<code class="sourceCode cpp">r</code> represents a data member
description. Otherwise,
<code class="sourceCode cpp"><span class="kw">false</span></code>.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> <span class="op">&lt;</span>reflection_range R <span class="op">=</span> initializer_list<span class="op">&lt;</span>info<span class="op">&gt;&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">consteval</span> info define_aggregate<span class="op">(</span>info class_type, R<span class="op">&amp;&amp;</span> mdescrs<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_131" id="pnum_131">8</a></span>
<em>Constant When</em>: Letting
<code class="sourceCode cpp"><em>C</em></code> be the class represented
by <code class="sourceCode cpp">class_type</code> and
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> be the
<code class="sourceCode cpp"><em>K</em></code><sup>th</sup> reflection
value in <code class="sourceCode cpp">mdescrs</code>,</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_132" id="pnum_132">(8.1)</a></span>
<code class="sourceCode cpp"><em>C</em></code> is incomplete from every
point in the evaluation context;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_133" id="pnum_133">(8.2)</a></span>
<code class="sourceCode cpp"><em>C</em></code> is not a class being
defined;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_134" id="pnum_134">(8.3)</a></span>
<code class="sourceCode cpp">is_data_member_spec<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">)</span></code>
is <code class="sourceCode cpp"><span class="kw">true</span></code> for
every
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> in
<code class="sourceCode cpp">mdescrs</code>;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_135" id="pnum_135">(8.4)</a></span>
the type represented by <code class="sourceCode cpp">type_of<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">)</span></code>
is a complete type for every
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> in
<code class="sourceCode cpp">mdescrs</code>; and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_136" id="pnum_136">(8.5)</a></span>
for every pair 0 ≤ <code class="sourceCode cpp"><em>K</em></code> &lt;
<code class="sourceCode cpp"><em>L</em></code> &lt; <code class="sourceCode cpp">mdescrs<span class="op">.</span>size<span class="op">()</span></code>,
if <code class="sourceCode cpp">has_identifier<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">)</span> <span class="op">&amp;&amp;</span> has_identifier<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>L</em></span></sub><span class="op">)</span></code>
is <code class="sourceCode cpp"><span class="kw">true</span></code>,
then either <code class="sourceCode cpp">u8identifier_of<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">)</span> <span class="op">!=</span> u8identifier_of<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>L</em></span></sub><span class="op">)</span></code>
is <code class="sourceCode cpp"><span class="kw">true</span></code> or
<code class="sourceCode cpp">u8identifier_of<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">)</span> <span class="op">==</span> <span class="st">u8&quot;_&quot;</span></code>
is <code class="sourceCode cpp"><span class="kw">true</span></code>.
<span class="note"><span>[ <em>Note 3:</em> </span>Every provided
identifier is unique or <code class="sourceCode cpp"><span class="st">&quot;_&quot;</span></code>.<span>
— <em>end note</em> ]</span></span></li>
</ul>
<p><span class="note"><span>[ <em>Note 4:</em>
</span><code class="sourceCode cpp"><em>C</em></code> could be a class
template specialization for which there is a reachable definition of the
primary class template. In this case, an explicit specialization is
injected.<span> — <em>end note</em> ]</span></span></p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_137" id="pnum_137">9</a></span>
Let
{<code class="sourceCode cpp"><span class="math inline"><em>t</em></span><sub>k</sub></code>}
be a sequence of reflections and
{<code class="sourceCode cpp"><span class="math inline"><em>o</em></span><sub>k</sub></code>}
be a sequence of <code class="sourceCode cpp">data_member_options</code>
values such that</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>data_member_spec(<span class="math inline"><em>t</em></span><sub><span class="math inline"><em>k</em></span></sub>, <span class="math inline"><em>o</em></span><sub><span class="math inline"><em>k</em></span></sub>) == <span class="math inline"><em>r</em></span><sub><span class="math inline"><em>k</em></span></sub></span></code></pre></div>
<p>for every
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>k</em></span></sub></code> in
<code class="sourceCode cpp">mdescrs</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_138" id="pnum_138">10</a></span>
<em>Effects</em>: Produces an injected declaration
<code class="sourceCode cpp"><em>D</em></code> ([expr.const]) that
provides a definition for <code class="sourceCode cpp"><em>C</em></code>
with properties as follows:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_139" id="pnum_139">(10.1)</a></span>
The target scope of <code class="sourceCode cpp"><em>D</em></code> is
the scope to which <code class="sourceCode cpp"><em>C</em></code>
belongs ([basic.scope.scope]).</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_140" id="pnum_140">(10.2)</a></span>
The locus of <code class="sourceCode cpp"><em>D</em></code> follows
immediately after the core constant expression currently under
evaluation.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_141" id="pnum_141">(10.3)</a></span>
If <code class="sourceCode cpp"><em>C</em></code> is a specialization,
that is not a local class, of templated class
<code class="sourceCode cpp"><em>T</em></code>; then
<code class="sourceCode cpp"><em>D</em></code> is is an explicit
specialization of <code class="sourceCode cpp"><em>T</em></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_142" id="pnum_142">(10.4)</a></span>
<code class="sourceCode cpp"><em>D</em></code> contains a public
non-static data member or unnamed bit-field corresponding to each
reflection value
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> in
<code class="sourceCode cpp">mdescrs</code>. For every other
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>L</em></span></sub></code> in
<code class="sourceCode cpp">mdescrs</code> such that
<code class="sourceCode cpp"><em>K</em> <span class="op">&lt;</span> <em>L</em></code>,
the declaration of
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> precedes the
declaration of
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>L</em></span></sub></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_143" id="pnum_143">(10.5)</a></span>
A non-static data member or unnamed bit-field corresponding to each
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> is declared with the
type or type alias represented by
<code class="sourceCode cpp"><span class="math inline"><em>t</em></span><sub><span class="math inline"><em>K</em></span></sub></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_144" id="pnum_144">(10.6)</a></span>
A non-static data member corresponding to a reflection
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> for which <code class="sourceCode cpp"><span class="math inline"><em>o</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">.</span>no_unique_address</code>
is <code class="sourceCode cpp"><span class="kw">true</span></code> is
declared with the attribute <code class="sourceCode cpp"><span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_145" id="pnum_145">(10.7)</a></span>
A non-static data member or unnamed bit-field corresponding to a
reflection
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> for which <code class="sourceCode cpp"><span class="math inline"><em>o</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">.</span>bit_width</code>
contains a value is declared as a bit-field whose width is that
value.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_146" id="pnum_146">(10.8)</a></span>
A non-static data member corresponding to a reflection
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> for which <code class="sourceCode cpp"><span class="math inline"><em>o</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">.</span>alignment</code>
contains a value is declared with the
<code class="sourceCode cpp"><em>alignment-specifier</em></code> <code class="sourceCode cpp"><span class="kw">alignas</span><span class="op">(</span><span class="math inline"><em>o</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">.</span>alignment<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_147" id="pnum_147">(10.9)</a></span>
A non-static data member or unnamed bit-field corresponding to a
reflection
<code class="sourceCode cpp"><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub></code> is declared with a
name determined as follows:
<ul>
<li>If <code class="sourceCode cpp"><span class="math inline"><em>o</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">.</span>name</code>
does not contain a value, an unnamed bit-field is declared.</li>
<li>Otherwise, the name of the non-static data member is the identifier
determined by the character sequence encoded by <code class="sourceCode cpp">u8identifier_of<span class="op">(</span><span class="math inline"><em>r</em></span><sub><span class="math inline"><em>K</em></span></sub><span class="op">)</span></code>
in UTF-8.</li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_148" id="pnum_148">(10.10)</a></span>
If <code class="sourceCode cpp"><em>C</em></code> is a union type for
which any of its members are not trivially default constructible, then
<code class="sourceCode cpp"><em>D</em></code> has a user-provided
default constructor which has no effect. <span class="draftnote" style="color: #01796F">[ Drafting note: If P3074 is adopted, do not
include this bullet. ]</span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_149" id="pnum_149">(10.11)</a></span>
If <code class="sourceCode cpp"><em>C</em></code> is a union type for
which any of its members are not trivially destructible, then
<code class="sourceCode cpp"><em>D</em></code> has a user-provided
destructor which has no effect. <span class="draftnote" style="color: #01796F">[ Drafting note: If P3074 is adopted, do not
include this bullet. ]</span></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_150" id="pnum_150">11</a></span>
<em>Returns</em>: <code class="sourceCode cpp">class_type</code>.</p>
</div>
</blockquote>
</div>
<h3 class="unnumbered" id="meta.reflection.annotation-annotation-reflection">[meta.reflection.annotation]
Annotation reflection<a href="#meta.reflection.annotation-annotation-reflection" class="self-link"></a></h3>
<p>Add the new function at the end of [meta.reflection.annotation]:</p>
<div class="std">
<blockquote>
<div class="addu">
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">consteval</span> info annotate<span class="op">(</span>info item, info value, source_location loc <span class="op">=</span> source_location<span class="op">::</span>current<span class="op">())</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_151" id="pnum_151">14</a></span>
<em>Constant When</em>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_152" id="pnum_152">(14.1)</a></span>
<code class="sourceCode cpp">dealias<span class="op">(</span>item<span class="op">)</span></code>
represents a class type, variable, function, or a namespace; and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_153" id="pnum_153">(14.2)</a></span>
<code class="sourceCode cpp">value</code> reprents a value.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_154" id="pnum_154">15</a></span>
<em>Effects</em>: Produces an injected declaration ([expr.const]) at
location <code class="sourceCode cpp">loc</code> redeclaring the entity
represented by <code class="sourceCode cpp">dealias<span class="op">(</span>item<span class="op">)</span></code>.
That injected declaration is annotated by
<code class="sourceCode cpp">value</code> and its locus is immediately
following the manifestly constant-evaluated expression currently under
evaluation.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_155" id="pnum_155">16</a></span>
<em>Returns</em>: <code class="sourceCode cpp">dealias<span class="op">(</span>item<span class="op">)</span></code>.</p>
</div>
</blockquote>
</div>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">5</span>
References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="1" role="doc-bibliography">
<div id="ref-P2758R4" class="csl-entry" role="doc-biblioentry">
[P2758R4] Barry Revzin. 2025-01-07. Emitting messages at compile time.
<a href="https://wg21.link/p2758r4"><div class="csl-block">https://wg21.link/p2758r4</div></a>
</div>
<div id="ref-P2996R10" class="csl-entry" role="doc-biblioentry">
[P2996R10] Wyatt Childers, Peter Dimov, Dan Katz, Barry Revzin, Andrew
Sutton, Faisal Vali, and Daveed Vandevoorde. 2025-02-08. Reflection for
C++26. <a href="https://wg21.link/p2996r10"><div class="csl-block">https://wg21.link/p2996r10</div></a>
</div>
<div id="ref-P2996R9" class="csl-entry" role="doc-biblioentry">
[P2996R9] Barry Revzin, Wyatt Childers, Peter Dimov, Andrew Sutton,
Faisal Vali, Daveed Vandevoorde, Dan Katz. 2025-01-13. Reflection for
C++26. <a href="https://wg21.link/p2996r9"><div class="csl-block">https://wg21.link/p2996r9</div></a>
</div>
<div id="ref-P3289R1" class="csl-entry" role="doc-biblioentry">
[P3289R1] Daveed Vandevoorde, Wyatt Childers, Dan Katz, Barry Revzin.
2025-01-13. Consteval blocks. <a href="https://wg21.link/p3289r1"><div class="csl-block">https://wg21.link/p3289r1</div></a>
</div>
<div id="ref-P3293R1" class="csl-entry" role="doc-biblioentry">
[P3293R1] Barry Revzin, Peter Dimov, Dan Katz, Daveed Vandevoorde.
2024-10-13. Splicing a base class subobject. <a href="https://wg21.link/p3293r1"><div class="csl-block">https://wg21.link/p3293r1</div></a>
</div>
<div id="ref-P3294R2" class="csl-entry" role="doc-biblioentry">
[P3294R2] Barry Revzin, Andrei Alexandrescu, Daveed Vandevoorde.
2024-10-15. Code Injection with Token Sequences. <a href="https://wg21.link/p3294r2"><div class="csl-block">https://wg21.link/p3294r2</div></a>
</div>
<div id="ref-P3394R1" class="csl-entry" role="doc-biblioentry">
[P3394R1] Daveed Vandevoorde, Wyatt Childers, Dan Katz, Barry Revzin.
2025-01-13. Annotations for Reflection. <a href="https://wg21.link/p3394r1"><div class="csl-block">https://wg21.link/p3394r1</div></a>
</div>
<div id="ref-P3569R0" class="csl-entry" role="doc-biblioentry">
[P3569R0] Shafik Yaghmour, Aaron Ballman, Erich Keane, Corentin Jabot,
Vlad Serebrennikov. 2025-01-11. Split define_aggregate from Reflection.
<a href="https://wg21.link/p3569r0"><div class="csl-block">https://wg21.link/p3569r0</div></a>
</div>
</div>
</div>
</div>
</body>
</html>
