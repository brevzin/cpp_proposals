<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2024-12-29" />
  <title>Diverging Expressions with `[[noreturn]]</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.csl-block{margin-left: 1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
text-align: justify;
}
@media screen and (max-width: 30em) {
body {
margin: 1.5em;
}
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
td > div > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #C9FBC9;
--diff-strongins: #acf2bd;
--diff-del: #FFC8EB;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
div.std blockquote { color: #000000; background-color: #F1F1F1;
border: 1px solid #D1D1D1;
padding-left: 0.5em; padding-right: 0.5em; }
div.std.ins blockquote {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.ins > div.example {
color: #000000; background-color: #C8FFC8;
border: 1px solid #B3EBB3;
}
div.std div.sourceCode { background-color: inherit; margin-left: 1em; }
div.std blockquote del { text-decoration: line-through;
color: #000000; background-color: var(--diff-del);
border: none; }
code del { border: 1px solid #ECB3C7; }
span.orange {
background-color: #ffa500;
}
span.yellow {
background-color: #ffff00;
}</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Diverging Expressions with
`[[noreturn]]</h1>
<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P3549R0 <a href="https://wg21.link/P3549">[Latest]</a> <a href="https://wg21.link/P3549/status">[Status]</a></td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2024-12-29</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Bruno Cardoso Lopes<br>&lt;<a href="mailto:bruno.cardoso@gmail.com" class="email">bruno.cardoso@gmail.com</a>&gt;<br>
      Zach Laine<br>&lt;<a href="mailto:whatwasthataddress@gmail.com" class="email">whatwasthataddress@gmail.com</a>&gt;<br>
      Michael Park<br>&lt;<a href="mailto:mcypark@gmail.com" class="email">mcypark@gmail.com</a>&gt;<br>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>
</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction<span></span></a></li>
<li><a href="#diverging-expressions" id="toc-diverging-expressions"><span class="toc-section-number">2</span>
Diverging Expressions<span></span></a>
<ul>
<li><a href="#diverging-do-expressions" id="toc-diverging-do-expressions"><span class="toc-section-number">2.1</span> Diverging
<code class="sourceCode cpp"><span class="cf">do</span></code>
expressions<span></span></a></li>
<li><a href="#a-bottom-type" id="toc-a-bottom-type"><span class="toc-section-number">2.2</span> A bottom
type<span></span></a></li>
<li><a href="#doing-our-due-diligence-to-deduce-do-divergence" id="toc-doing-our-due-diligence-to-deduce-do-divergence"><span class="toc-section-number">2.3</span> Doing Our Due Diligence to Deduce
<code class="sourceCode cpp"><span class="cf">do</span></code>
Divergence<span></span></a></li>
</ul></li>
<li><a href="#bibliography" id="toc-bibliography"><span class="toc-section-number">3</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">1</span>
Introduction<a href="#introduction" class="self-link"></a></h1>
<p>One pattern that will occur with some regularity with pattern
matching <span class="citation" data-cites="P2688R4">[<a href="https://wg21.link/p2688r4" role="doc-biblioref">P2688R4</a>]</span> (and
<code class="sourceCode cpp"><span class="cf">do</span></code>
expressions <span class="citation" data-cites="P2806R2">[<a href="https://wg21.link/p2806r2" role="doc-biblioref">P2806R2</a>]</span>) is the desire to produce
values for some patterns but not for all cases. Consider the following
simplified example:</p>
<table>
<tr>
<td>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j <span class="op">=</span> i match <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> std<span class="op">::</span>terminate<span class="op">()</span>;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  use<span class="op">(</span>j<span class="op">)</span>;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j <span class="op">=</span> i match <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>terminate<span class="op">()</span>;</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  use<span class="op">(</span>j<span class="op">)</span>;</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> h<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j <span class="op">=</span> i match <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>terminate<span class="op">()</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  use<span class="op">(</span>j<span class="op">)</span>;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</td>
</tr>
</table>
<p>In all of these cases, the desire is that if <code class="sourceCode cpp">i <span class="op">==</span> <span class="dv">0</span></code>
then we initialize <code class="sourceCode cpp">j</code> to the value
<code class="sourceCode cpp"><span class="dv">0</span></code>, otherwise
we <code class="sourceCode cpp">std<span class="op">::</span>terminate<span class="op">()</span></code>.
Given that <code class="sourceCode cpp">std<span class="op">::</span>terminate</code>
does in fact, as the name suggests, terminate, we don’t actually have to
worry about producing a value in that case. These examples are all
equivalent — or at least, they should be. But C++ does not currently
recognize them as such (with one exception that we’ll get to later).</p>
<p>The rule for pattern matching by default is that the type of the
match expression is deduced from each arm and each arm has to match. In
the above examples, the first arm always has type
<code class="sourceCode cpp"><span class="dt">int</span></code>. But for
<code class="sourceCode cpp">f<span class="op">()</span></code> and
<code class="sourceCode cpp">g<span class="op">()</span></code>, the
second arm has type
<code class="sourceCode cpp"><span class="dt">void</span></code>. In
order to type check, we have to wrap our call to <code class="sourceCode cpp">std<span class="op">::</span>terminate</code> in
an expression that actually has type
<code class="sourceCode cpp"><span class="dt">int</span></code>. The
<code class="sourceCode cpp"><span class="cf">do</span></code>
expression in
<code class="sourceCode cpp">h<span class="op">()</span></code> is one
such way.</p>
<p>The extra <code class="sourceCode cpp"><span class="op">-&gt;</span> <span class="dt">int</span></code>
does solve the problem, but it’s also misleading. We’re not actually
ever producing an
<code class="sourceCode cpp"><span class="dt">int</span></code> here,
we’re just writing a type annotation to hammer the compiler into
submission. That’s just not a great place to be.</p>
<p>Our goal with this paper is to have all of
<code class="sourceCode cpp">f<span class="op">()</span></code>,
<code class="sourceCode cpp">g<span class="op">()</span></code>, and
<code class="sourceCode cpp">h<span class="op">()</span></code> above
type check. Concretely: we need to recognize that an expression can
<em>diverge</em> and then have pattern matching’s type deduction rules
only consider those arms that do not diverge. Importantly, we want to
treat the expressions:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>terminate<span class="op">()</span></span></code></pre></div>
</blockquote>
</div>
<p>and</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>as both diverging expressions in order to facilitate code evolution.
It would be annoying if a naked call to <code class="sourceCode cpp">std<span class="op">::</span>terminate</code>
worked but once you wrap it in a
<code class="sourceCode cpp"><span class="cf">do</span></code>
expression that does so much as add a single log statement that it
suddenly doesn’t. We want to properly recognize divergence, not just the
most trivial of cases.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="diverging-expressions"><span class="header-section-number">2</span>
Diverging Expressions<a href="#diverging-expressions" class="self-link"></a></h1>
<p>An expression is said to <em>diverge</em> if it unconditionally
escapes control flow. Currently in C++, we have two such expressions in
the language:</p>
<ul>
<li>a <code class="sourceCode cpp"><em>throw-expression</em></code>,
and</li>
<li>a call to a <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>
function.</li>
</ul>
<p>The former explicitly diverges (control flow immediately escapes and
doesn’t return to keep evaluating in the original slot) while the latter
implicitly diverges (technically a function marked <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>
can still return, we just state that doing so is undefined behavior in
<span>9.12.11 <a href="https://wg21.link/dcl.attr.noreturn">[dcl.attr.noreturn]</a></span>).</p>
<p>As hinted at earlier, the language already recognizes that
expressions can diverge in one spot: the conditional operator.
Consider:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <em>condition</em> <span class="op">?</span> <span class="dv">42</span> <span class="op">:</span> <span class="cf">throw</span> std<span class="op">::</span>runtime_error<span class="op">(</span><span class="st">&quot;oops&quot;</span><span class="op">)</span>; <span class="co">// OK</span></span></code></pre></div>
</blockquote>
</div>
<p>The conditional operator has to merge two values into one. But if one
of the operands is a
<code class="sourceCode cpp"><em>throw-expression</em></code>, then the
value of the conditional operator is trivially the other operand — or
there is just no value to speak of. The above is perfectly valid code,
the conditional expression is a prvalue
<code class="sourceCode cpp"><span class="dt">int</span></code> (that
sometimes throws).</p>
<p>The pattern matching paper recognizes this as well, and explicitly
recognizes pattern arms that are
<code class="sourceCode cpp"><em>throw-expression</em></code>s as not
participating in deduction either:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> v match <span class="op">{</span> <span class="co">// OK</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="op">=&gt;</span> <span class="cf">throw</span> std<span class="op">::</span>runtime_error<span class="op">(</span><span class="st">&quot;oops&quot;</span><span class="op">)</span>;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
</div>
<p>But this does not work today, despite being just as diverging as a
<code class="sourceCode cpp"><span class="cf">throw</span></code>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <em>condition</em> <span class="op">?</span> <span class="dv">42</span> <span class="op">:</span> std<span class="op">::</span>terminate<span class="op">()</span>;</span></code></pre></div>
</blockquote>
</div>
<p>Instead you could do something like this (which we think is the kind
of thing that really belongs on a T-shirt):</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <em>condition</em> <span class="op">?</span> <span class="dv">42</span> <span class="op">:</span> <span class="cf">throw</span> <span class="op">(</span>std<span class="op">::</span>terminate<span class="op">()</span>, <span class="dv">0</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
</div>
<p>Note that this <em>does</em> work — we will terminate before we
evaluate the
<code class="sourceCode cpp"><span class="cf">throw</span></code>.</p>
<p>But there’s not any difference between throwing an exception and
invoking a non-returning function when we’re talking about whether an
expression produces a value. Neither produces a value, so neither needs
to participate in any language rules that involve merging multiple
expressions!</p>
<p>We think it’s important to recognize invocations of non-returning
functions as diverging because we want people to be able to write the
code on the left, and not have to write either of the two workarounds
presented:</p>
<table>
<tr>
<th>
Desired</ht>
<th>
Workaround with
<code class="sourceCode cpp"><span class="cf">throw</span></code>
</th>
<th>
Workaround with explicit type
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j <span class="op">=</span> i match <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> std<span class="op">::</span>terminate<span class="op">()</span>;</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  use<span class="op">(</span>j<span class="op">)</span>;</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j <span class="op">=</span> i match <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> <span class="cf">throw</span> <span class="op">(</span>std<span class="op">::</span>terminate<span class="op">()</span>, <span class="dv">0</span><span class="op">)</span>;</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  use<span class="op">(</span>j<span class="op">)</span>;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> h<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j <span class="op">=</span> i match <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>terminate<span class="op">()</span>;</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  use<span class="op">(</span>j<span class="op">)</span>;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</td>
</tr>
</table>
<h2 data-number="2.1" id="diverging-do-expressions"><span class="header-section-number">2.1</span> Diverging
<code class="sourceCode cpp"><span class="cf">do</span></code>
expressions<a href="#diverging-do-expressions" class="self-link"></a></h2>
<p>Consider the following expressions:</p>
<ol type="1">
<li><code class="sourceCode cpp"><span class="cf">throw</span> <span class="dv">42</span></code></li>
<li><code class="sourceCode cpp">std<span class="op">::</span>terminate<span class="op">()</span></code></li>
<li><code class="sourceCode cpp"><span class="cf">do</span> <span class="op">{</span> <span class="cf">throw</span> <span class="dv">42</span>; <span class="op">}</span></code></li>
<li><code class="sourceCode cpp"><span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span></code></li>
</ol>
<p>All four of these expressions diverge, the bottom two just trivially
wrap the top two. So we’d want these to have the same properties when it
comes to divergence — otherwise any slight refactoring could have too
much impact. For instance, the desire to change:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>terminate<span class="op">()</span></span></code></pre></div>
</blockquote>
</div>
<p>into</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    log<span class="op">::</span>fatal<span class="op">(</span><span class="st">&quot;oops, I did it again&quot;</span><span class="op">)</span>;</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>terminate<span class="op">()</span>;</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>should ideally not change any properties of the expression. Both
diverge, one just additionally adds some logging.</p>
<p>One question we have to answer is: What is the
<code class="sourceCode cpp"><span class="kw">decltype</span></code> of
such an expression?</p>
<p>Right now, <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span><span class="cf">throw</span> <span class="dv">42</span><span class="op">)</span></code>
is defined as
<code class="sourceCode cpp"><span class="dt">void</span></code> <a href="https://eel.is/c++draft/expr.throw#1">explicitly</a>. For some
reason. <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>terminate<span class="op">())</span></code>
is more obviously
<code class="sourceCode cpp"><span class="dt">void</span></code> simply
because that’s how the function is defined — it is a <code class="sourceCode cpp"><span class="dt">void</span><span class="op">()</span></code>
(although a <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>
one). So there’s certainly something to be said for going ahead and
wanting to define <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span><span class="cf">do</span> <span class="op">{</span> <span class="cf">throw</span> <span class="dv">42</span>; <span class="op">})</span></code>
as <code class="sourceCode cpp"><span class="dt">void</span></code> as
well.</p>
<p>This approach leads to the following pair of rules:</p>
<ol type="1">
<li>the <em>type</em> of a
<code class="sourceCode cpp"><span class="cf">do</span></code>
expression is either
<ul>
<li>the <em>trailing-return-type</em>, if one is explicitly provided,
or</li>
<li>the type that is
<code class="sourceCode cpp"><span class="kw">do_return</span></code>-ed
consistently (same as the lambda rule except with
<code class="sourceCode cpp"><span class="kw">do_return</span></code>
instead of
<code class="sourceCode cpp"><span class="cf">return</span></code>).</li>
</ul></li>
<li>A <code class="sourceCode cpp"><span class="cf">do</span></code>
expression is said to <em>diverge</em> if every control flow path leads
to executing a diverging expression (i.e. a
<code class="sourceCode cpp"><em>throw-expression</em></code>, a call to
a <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>
function, or evaluating another such diverging expression).</li>
</ol>
<p>There is another approach though.</p>
<h2 data-number="2.2" id="a-bottom-type"><span class="header-section-number">2.2</span> A bottom type<a href="#a-bottom-type" class="self-link"></a></h2>
<p>Several languages have a notion of a bottom type
(<code class="sourceCode cpp">⊥</code>) for diverging expressions. This
type is spelled <code class="sourceCode cpp">Nothing</code> in Scala,
<code class="sourceCode cpp">never</code> in TypeScript,
<code class="sourceCode cpp">Never</code> in Python,
<code class="sourceCode cpp">noreturn</code> in D,
<code class="sourceCode cpp"><span class="op">!</span></code> in Rust,
<code class="sourceCode cpp"><span class="dt">void</span></code> in
Haskell (but notably not
<code class="sourceCode cpp"><span class="dt">void</span></code> in
C++), etc. This type represents an expression that diverges.</p>
<p>Let’s imagine what it would look like if C++ also had such a type.
We’ll call it <code class="sourceCode cpp">noreturn_t</code>. It would
some interesting properties:</p>
<ul>
<li>You cannot produce an instance of such a type. It wouldn’t be very
divergent otherwise! In this case, it’s not just that this type isn’t
constructible, but we would also have to eliminate all of C++’s other
clever ways of producing a value (like <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>).</li>
<li>On the other hand, <code class="sourceCode cpp">noreturn_t</code> is
convertible to any other type (including reference types). This also
would include function pointer conversions — <code class="sourceCode cpp"><span class="kw">auto</span><span class="op">(*)(</span>T<span class="op">)</span> <span class="op">-&gt;</span> noreturn_t</code>
is convertible to <code class="sourceCode cpp"><span class="kw">auto</span><span class="op">(*)(</span>T<span class="op">)</span> <span class="op">-&gt;</span> U</code>
for all <code class="sourceCode cpp">U</code>. This makes sense from a
type-theoretic perspective and makes a lot of other uses just work.</li>
</ul>
<p>We would then change the type of a
<code class="sourceCode cpp"><em>throw-expression</em></code> to be
<code class="sourceCode cpp">noreturn_t</code> (instead of
<code class="sourceCode cpp"><span class="dt">void</span></code>). This
change, coupled with the conversion rule above, means we’d no longer
need the special case in conditional expressions. Consider:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><em>condition</em> <span class="op">?</span> <span class="dv">42</span> <span class="op">:</span> <span class="cf">throw</span> std<span class="op">::</span>runtime_error<span class="op">(</span><span class="st">&quot;oops&quot;</span><span class="op">)</span></span></code></pre></div>
</blockquote>
</div>
<p>The types of the second and third operand are
<code class="sourceCode cpp"><span class="dt">int</span></code> and
<code class="sourceCode cpp">noreturn_t</code>, respectively.
<code class="sourceCode cpp">noreturn_t</code> is convertible to
<code class="sourceCode cpp"><span class="dt">int</span></code> (because
it is convertible to anything), but
<code class="sourceCode cpp"><span class="dt">int</span></code> is not
convertible to <code class="sourceCode cpp">noreturn_t</code> (since
nothing is), thus the result of the expression has type
<code class="sourceCode cpp"><span class="dt">int</span></code>, as
desired.</p>
<p>We would also want to change the signatures of all of our
never-returning functions to have this in their types:</p>
<div class="std">
<blockquote>
<div>
<div class="sourceCode" id="cb16"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>namespace std {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="st">- [[noreturn]] auto terminate() -&gt; void;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="va">+              auto terminate() -&gt; noreturn_t;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
</blockquote>
</div>
<p>Which would likewise allow for the desired conditional with <code class="sourceCode cpp">std<span class="op">::</span>terminate<span class="op">()</span></code>
to work for the same reasons as the conditional with
<code class="sourceCode cpp"><span class="cf">throw</span></code>:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><em>condition</em> <span class="op">?</span> <span class="dv">42</span> <span class="op">:</span> std<span class="op">::</span>terminate<span class="op">()</span></span></code></pre></div>
</blockquote>
</div>
<h2 data-number="2.3" id="doing-our-due-diligence-to-deduce-do-divergence"><span class="header-section-number">2.3</span> Doing Our Due Diligence to
Deduce <code class="sourceCode cpp"><span class="cf">do</span></code>
Divergence<a href="#doing-our-due-diligence-to-deduce-do-divergence" class="self-link"></a></h2>
<p>Consider the following pattern arms:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>1</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;never gonna give you up&quot;</span><span class="op">)</span>; <span class="cf">throw</span> <span class="dv">2</span>; <span class="op">}</span>;</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>2</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;never gonna let you down&quot;</span><span class="op">)</span>; std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>3</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;never gonna run around&quot;</span><span class="op">)</span>; <span class="kw">do_return</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span>;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>4</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;and desert you&quot;</span><span class="op">)</span>; <span class="cf">continue</span>; <span class="op">}</span>;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>5</sub> <span class="op">=&gt;</span> <span class="cf">break</span>;</span></code></pre></div>
</blockquote>
</div>
<p>The last case here is simple — we can special case escaping
statements, and the pattern matching paper already does this.</p>
<p>The first four cases though also all unconditionally diverge. We know
that from simply examining the code. But what is the specific language
rule by which we could ensure that the pattern match expression can
exclude these arms when deducing the type? In
<code class="sourceCode cpp"><em>pattern</em><sub>3</sub></code>, we
actually have a
<code class="sourceCode cpp"><span class="kw">do_return</span></code>
statement, so the
<code class="sourceCode cpp"><span class="cf">do</span></code>
expression there could straightforwardly be said to have type
<code class="sourceCode cpp">noreturn_t</code> and thus diverge. But the
other three have no
<code class="sourceCode cpp"><span class="kw">do_return</span></code>
and thus would, by default, end up having type
<code class="sourceCode cpp"><span class="dt">void</span></code> — which
we do not want. So what do we do?</p>
<p>One option is to copy the logic from some other languages (like Rust)
and also the initial GCC statement-expression model and have an implicit
value from
<code class="sourceCode cpp"><span class="cf">do</span></code>
expressions. That is, the other three patterns above implicitly take
their values from <code class="sourceCode cpp"><span class="cf">throw</span> <span class="dv">2</span></code>,
<code class="sourceCode cpp">std<span class="op">::</span>terminate<span class="op">()</span></code>,
and <code class="sourceCode cpp"><span class="cf">continue</span></code>
respectively — which all have type
<code class="sourceCode cpp">noreturn_t</code>. So this just works. But
the reason we didn’t initially want to do this for
<code class="sourceCode cpp"><span class="cf">do</span></code>
expressions was that we don’t already have a way to turn
<code class="sourceCode cpp"><span class="cf">if</span></code>
statements and
<code class="sourceCode cpp"><span class="cf">for</span></code>/<code class="sourceCode cpp"><span class="cf">while</span></code>
statements into expressions — which makes early returns challenging.
From the gcc doc example:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>gcc</strong>
</div></th>
<th><div style="text-align:center">
<strong>Proposed</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">({</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> foo<span class="op">()</span>;</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> z;</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> z <span class="op">=</span> y;</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> z <span class="op">=</span> <span class="op">-</span>y;</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    z;</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> foo<span class="op">()</span>;</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do_return</span> y;</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do_return</span> <span class="op">-</span>y;</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>With implicit last value (or, furthermore, with an
<code class="sourceCode cpp"><span class="cf">if</span></code>
expression which operates under implicit last value rules):</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Explicit
<code class="sourceCode cpp"><span class="kw">do_return</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong>Implicit last value</strong>
</div></th>
<th><div style="text-align:center">
<strong>An
<code class="sourceCode cpp"><span class="cf">if</span></code>
expression</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div>

<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> foo<span class="op">()</span>;</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do_return</span> y;</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do_return</span> <span class="op">-</span>y;</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> foo<span class="op">()</span>;</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do_return</span> y;</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span>y;</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
<td><div>

<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> foo<span class="op">()</span>;</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        y;</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span>y;</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

</div></td>
</tr>
</tbody>
</table>
<p>But we’re concerned that the mixing and matching of explicit and
implicit yields would be confusing. It’s easy to miss the implicit
<code class="sourceCode cpp"><span class="kw">do_return</span></code> in
the presence of explicit ones. Likewise, attempting to turn
<code class="sourceCode cpp"><span class="cf">if</span></code> into an
expression this late in C++’s lifetime might be too novel? We would also
then have to find a way to turn loops into expressions (or resurface
<code class="sourceCode cpp"><span class="kw">do_return</span></code>,
again running into the explicit/implicit issue).</p>
<p>So if we don’t want to use implicit last value, how else can we
deduce divergence? We suggest the following, simple rule, inspired by
implicit last value:</p>
<div class="std">
<blockquote>
<p>A <code class="sourceCode cpp"><em>statement</em></code> is a
diverging statement if it is:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_1" id="pnum_1">1</a></span>
A <code class="sourceCode cpp"><em>compound-statement</em></code> where
the last statement is a diverging statement,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_2" id="pnum_2">2</a></span>
an <code class="sourceCode cpp"><em>escaping-statement</em></code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_3" id="pnum_3">3</a></span>
a <code class="sourceCode cpp"><em>statement-expression</em></code>
whose <code class="sourceCode cpp"><em>expression</em></code> is a
diverging expression, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_4" id="pnum_4">4</a></span>
an <code class="sourceCode cpp"><span class="cf">if</span></code>
statement with an
<code class="sourceCode cpp"><span class="cf">else</span></code> branch,
where both substatements are diverging statements.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_5" id="pnum_5">5</a></span>
a constexpr
<code class="sourceCode cpp"><span class="cf">if</span></code> statement
where the taken substatement is a diverging statement.</li>
</ul>
<p>A <code class="sourceCode cpp"><em>do-expression</em></code> is a
diverging expression if:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_6" id="pnum_6">1</a></span>
it has a
<code class="sourceCode cpp"><em>trailing-return-type</em></code> of
<code class="sourceCode cpp">noreturn_t</code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_7" id="pnum_7">2</a></span>
its return type is deduced as
<code class="sourceCode cpp">noreturn_t</code>, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_8" id="pnum_8">3</a></span>
its return type is deduced as
<code class="sourceCode cpp"><span class="dt">void</span></code> and the
last <code class="sourceCode cpp"><em>statement</em></code> is a
diverging statement.</li>
</ul>
</blockquote>
</div>
<p>The first two bullets handle simple cases like <code class="sourceCode cpp"><span class="cf">do</span> <span class="op">-&gt;</span> noreturn_t <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></code>
and <code class="sourceCode cpp"><span class="cf">do</span> <span class="op">{</span> <span class="kw">do_return</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span></code>.
The third case is the more complicated one. We need to deduce
<code class="sourceCode cpp"><span class="dt">void</span></code> because
if there are any
<code class="sourceCode cpp"><span class="kw">do_return</span></code>s
that yield a value, then the expression does not diverge. Then, in the
<code class="sourceCode cpp"><span class="dt">void</span></code>-returning
cases, we need to see which ones of those actually diverge. Which is
non-trivial because we need to handle things like:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// just an escaping-statement</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span> <span class="cf">continue</span>; <span class="op">}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">// a statement-expression that is a diverging expressoin</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">// an if statement with just an if, this is NOT diverging</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co">// because if the <em>condition</em> is false, then we&#39;re just a void expression</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span> <span class="cf">if</span> <span class="op">(</span><em>condition</em><span class="op">)</span> <span class="op">{</span> <span class="cf">throw</span> <span class="dv">1</span>; <span class="op">}</span> <span class="op">}</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="co">// but this one DOES diverge (just differently in both branches)</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span> <span class="cf">if</span> <span class="op">(</span><em>condition</em><span class="op">)</span> <span class="op">{</span> <span class="cf">continue</span>; <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="cf">break</span>; <span class="op">}</span> <span class="op">}</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="co">// this diverges if the condition is true</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><em>condition</em><span class="op">)</span> <span class="op">{</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span> <span class="op">}</span></span></code></pre></div>
</blockquote>
</div>
<p>This rule ensures that all of our initial pattern arms diverge, as
desired:</p>
<div class="std">
<blockquote>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>1</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;never gonna make you cry&quot;</span><span class="op">)</span>; <span class="cf">throw</span> <span class="dv">2</span>; <span class="op">}</span>;</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>2</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;never gonna say goodbye&quot;</span><span class="op">)</span>; std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span>;</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>3</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;never gonna tell a lie&quot;</span><span class="op">)</span>; <span class="kw">do_return</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span>;</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>4</sub> <span class="op">=&gt;</span> <span class="cf">do</span> <span class="op">{</span> std<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;and hurt you&quot;</span><span class="op">)</span>; <span class="cf">continue</span>; <span class="op">}</span>;</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><em>pattern</em><sub>5</sub> <span class="op">=&gt;</span> <span class="cf">break</span>;</span></code></pre></div>
</blockquote>
</div>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">3</span>
References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="1" role="doc-bibliography">
<div id="ref-P2688R4" class="csl-entry" role="doc-biblioentry">
[P2688R4] Michael Park. 2024-12-17. Pattern Matching: `match`
Expression. <a href="https://wg21.link/p2688r4"><div class="csl-block">https://wg21.link/p2688r4</div></a>
</div>
<div id="ref-P2806R2" class="csl-entry" role="doc-biblioentry">
[P2806R2] Barry Revzin, Bruno Cardoso Lopez, Zach Laine, Michael Park.
2023-11-16. do expressions. <a href="https://wg21.link/p2806r2"><div class="csl-block">https://wg21.link/p2806r2</div></a>
</div>
</div>
</div>
</div>
</body>
</html>
