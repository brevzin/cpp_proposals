<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Adding <=> to library</title>
<style type="text/css">html {
	position: relative;
	max-width: 1024px;
	height: 100%;
}
body {
	font-family: Helvetica, arial, sans-serif;
	font-size: 14px;
	line-height: 1.6;
	padding-top: 10px;
	padding-bottom: 10px;
	background-color: white;
	padding: 30px;
}
body>*:first-child {
	margin-top: 0 !important;
}
body>*:last-child {
	margin-bottom: 0 !important;
}
a {
	color: #4183C4;
}
a.absent {
	color: #cc0000;
}
a.anchor {
	display: block;
	padding-left: 30px;
	margin-left: -30px;
	cursor: pointer;
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	margin: 20px 0 10px;
	padding: 0;
	font-weight: bold;
	-webkit-font-smoothing: antialiased;
	cursor: text;
	position: relative;
}
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
	text-decoration: none;
}
h1 tt, h1 code {
	font-size: inherit;
}
h2 tt, h2 code {
	font-size: inherit;
}
h3 tt, h3 code {
	font-size: inherit;
}
h4 tt, h4 code {
	font-size: inherit;
}
h5 tt, h5 code {
	font-size: inherit;
}
h6 tt, h6 code {
	font-size: inherit;
}
h1 {
	font-size: 28px;
	color: black;
}
h2 {
	font-size: 24px;
	border-bottom: 1px solid #cccccc;
	color: black;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 16px;
}
h5 {
	font-size: 14px;
}
h6 {
	color: #777777;
	font-size: 14px;
}
p, blockquote, ol, dl, li, table, pre {
	margin: 15px 0;
}
hr {
	background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
	border: 0 none;
	color: #cccccc;
	height: 4px;
	padding: 0;
}
body>h2:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child+h2 {
	margin-top: 0;
	padding-top: 0;
}
body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
	margin-top: 0;
	padding-top: 0;
}
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
	margin-top: 0;
	padding-top: 0;
}
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
	margin-top: 0;
}
li p.first {
	display: inline-block;
}
li {
	margin: 0;
}
ol {
	padding-left: 30px;
    margin: 5px;
    counter-reset: item;
    margin-left: -1px;
    margin-bottom: -1px;
    margin-top: -1px;
}
ol > li {
    counter-increment: item;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ol ol > li {
    display: block;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ol ol > li:before {
    content: counters(item, ".") ". ";
    margin-left: -30px;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ul :first-child, ol :first-child {
	margin-top: 0;
}
ul ul { 
    margin-left: -15px;
}
dl {
	padding: 0;
}
dl dt {
	font-size: 14px;
	font-weight: bold;
	font-style: italic;
	padding: 0;
	margin: 15px 0 5px;
}
dl dt:first-child {
	padding: 0;
}
dl dt> :first-child {
	margin-top: 0;
}
dl dt> :last-child {
	margin-bottom: 0;
}
dl dd {
	margin: 0 0 15px;
	padding: 0 15px;
}
dl dd> :first-child {
	margin-top: 0;
}
dl dd> :last-child {
	margin-bottom: 0;
}
blockquote {
	border-left: 4px solid #dddddd;
	padding: 0 15px;
	color: #777777;
}
blockquote> :first-child {
	margin-top: 0;
}
blockquote> :last-child {
	margin-bottom: 0;
}
table {
	padding: 0;
	border-collapse: collapse;
}
table tr {
	border-top: 1px solid #cccccc;
	background-color: white;
	margin: 0;
	padding: 0;
}
table tr:nth-child(2n) {
	background-color: #f8f8f8;
}
table tr th {
	font-weight: bold;
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr td {
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr th :first-child, table tr td :first-child {
	margin-top: 0;
}
table tr th :last-child, table tr td :last-child {
	margin-bottom: 0;
}
td {
	vertical-align: top;
}
img {
	max-width: 100%;
}
span.frame {
	display: block;
	overflow: hidden;
}
span.frame>span {
	border: 1px solid #dddddd;
	display: block;
	float: left;
	overflow: hidden;
	margin: 13px 0 0;
	padding: 7px;
	width: auto;
}
span.frame span img {
	display: block;
	float: left;
}
span.frame span span {
	clear: both;
	color: #333333;
	display: block;
	padding: 5px 0 0;
}
span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-center>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: center;
}
span.align-center span img {
	margin: 0 auto;
	text-align: center;
}
span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-right>span {
	display: block;
	overflow: hidden;
	margin: 13px 0 0;
	text-align: right;
}
span.align-right span img {
	margin: 0;
	text-align: right;
}
span.float-left {
	display: block;
	margin-right: 13px;
	overflow: hidden;
	float: left;
}
span.float-left span {
	margin: 13px 0 0;
}
span.float-right {
	display: block;
	margin-left: 13px;
	overflow: hidden;
	float: right;
}
span.float-right>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: right;
}
code, tt {
	margin: 0 2px;
	padding: 0 5px;
	white-space: nowrap;
	border: 1px solid #eaeaea;
	background-color: #f8f8f8;
	border-radius: 3px;
}
pre code {
	margin: 0;
	padding: 0;
	white-space: pre;
	border: none;
	background: transparent;
}
.highlight pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
	padding: 6px 10px;
	border-radius: 3px;
}
pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
    overflow-x: hidden;
    overflow-y: hidden;
    padding: 6px 10px;
	border-radius: 3px;
}
pre code, pre tt {
	background-color: transparent;
	border: none;
}
sup {
	font-size: 0.83em;
	vertical-align: super;
	line-height: 0;
}
kbd {
	display: inline-block;
	padding: 3px 5px;
	font-size: 11px;
	line-height: 10px;
	color: #555;
	vertical-align: middle;
	background-color: #fcfcfc;
	border: solid 1px #ccc;
	border-bottom-color: #bbb;
	border-radius: 3px;
	box-shadow: inset 0 -1px 0 #bbb
}
* {
	-webkit-print-color-adjust: exact;
}
ins {
	color: #00A000
}
del {
	color: #A00000
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
    font-size: 83%;
}
a.self-link:hover {
    opacity: 1;
}
a.self-link::before {
    content: "§";
}</style>
<style type="text/css">/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+c+cpp&plugins=line-highlight */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f8f8f8;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #9a6e3a;
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function,
.token.class-name {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

pre[data-line] {
	position: relative;
	padding: 1em 0 1em 3em;
}

.line-highlight {
	position: absolute;
	left: 0;
	right: 0;
	padding: inherit 0;
	margin-top: 1em; /* Same as .prism’s padding-top */

	background: hsla(24, 20%, 50%,.08);
	background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));

	pointer-events: none;

	line-height: inherit;
	white-space: pre;
}

	.line-highlight:before,
	.line-highlight[data-end]:after {
		content: attr(data-start);
		position: absolute;
		top: .4em;
		left: .6em;
		min-width: 1em;
		padding: 0 .5em;
		background-color: hsla(24, 20%, 50%,.4);
		color: hsl(24, 20%, 95%);
		font: bold 65%/1.5 sans-serif;
		text-align: center;
		vertical-align: .3em;
		border-radius: 999px;
		text-shadow: none;
		box-shadow: 0 1px white;
	}

	.line-highlight[data-end]:after {
		content: attr(data-end);
		top: auto;
		bottom: .4em;
	}

.line-numbers .line-highlight:before,
.line-numbers .line-highlight:after {
	content: none;
}

</style>
<script type="text/javascript">/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+c+cpp+nasm+rust&plugins=line-highlight */
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-([\w-]+)\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof r?new r(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,t){var r=n.util.type(e);switch(t=t||{},r){case"Object":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a={};t[n.util.objId(e)]=a;for(var l in e)e.hasOwnProperty(l)&&(a[l]=n.util.clone(e[l],t));return a;case"Array":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a=[];return t[n.util.objId(e)]=a,e.forEach(function(e,r){a[r]=n.util.clone(e,t)}),a}return e}},languages:{extend:function(e,t){var r=n.util.clone(n.languages[e]);for(var a in t)r[a]=t[a];return r},insertBefore:function(e,t,r,a){a=a||n.languages;var l=a[e];if(2==arguments.length){r=arguments[1];for(var i in r)r.hasOwnProperty(i)&&(l[i]=r[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in r)r.hasOwnProperty(i)&&(o[i]=r[i]);o[s]=l[s]}var u=a[e];return a[e]=o,n.languages.DFS(n.languages,function(t,n){n===u&&t!=e&&(this[t]=o)}),o},DFS:function(e,t,r,a){a=a||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],r||l),"Object"!==n.util.type(e[l])||a[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||a[n.util.objId(e[l])]||(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,a)):(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,a)))}},plugins:{},highlightAll:function(e,t){n.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,r){var a={callback:r,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var l,i=a.elements||e.querySelectorAll(a.selector),o=0;l=i[o++];)n.highlightElement(l,t===!0,a.callback)},highlightElement:function(t,r,a){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,t.parentNode&&(o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l));var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return u.code&&(n.hooks.run("before-highlight",u),u.element.textContent=u.code,n.hooks.run("after-highlight",u)),n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),r&&_self.Worker){var g=new Worker(n.filename);g.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,a){var l={code:e,grammar:t,language:a};return n.hooks.run("before-tokenize",l),l.tokens=n.tokenize(l.code,l.grammar),n.hooks.run("after-tokenize",l),r.stringify(n.util.encode(l.tokens),l.language)},matchGrammar:function(e,t,r,a,l,i,o){var s=n.Token;for(var u in r)if(r.hasOwnProperty(u)&&r[u]){if(u==o)return;var g=r[u];g="Array"===n.util.type(g)?g:[g];for(var c=0;c<g.length;++c){var h=g[c],f=h.inside,d=!!h.lookbehind,m=!!h.greedy,p=0,y=h.alias;if(m&&!h.pattern.global){var v=h.pattern.toString().match(/[imuy]*$/)[0];h.pattern=RegExp(h.pattern.source,v+"g")}h=h.pattern||h;for(var b=a,k=l;b<t.length;k+=t[b].length,++b){var w=t[b];if(t.length>e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,r,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var r=[e],a=t.rest;if(a){for(var l in a)t[l]=a[l];delete t.rest}return n.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){var r=n.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){var r=n.hooks.all[e];if(r&&r.length)for(var a,l=0;a=r[l++];)a(t)}}},r=n.Token=function(e,t,n,r,a){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length,this.greedy=!!a};if(r.stringify=function(e,t,a){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return r.stringify(n,t,e)}).join("");var l={type:e.type,content:r.stringify(e.content,t,a),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:a};if(e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o=Object.keys(l.attributes).map(function(e){return e+'="'+(l.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+l.tag+' class="'+l.classes.join(" ")+'"'+(o?" "+o:"")+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),r=t.language,a=t.code,l=t.immediateClose;_self.postMessage(n.highlight(a,n.languages[r],r)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return a&&(n.filename=a.src,n.manual||a.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.markup={comment:/<!--[\s\S]*?-->/,prolog:/<\?[\s\S]+?\?>/,doctype:/<!DOCTYPE[\s\S]+?>/i,cdata:/<!\[CDATA\[[\s\S]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,inside:{punctuation:[/^=/,{pattern:/(^|[^\\])["']/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
Prism.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(?:;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^{}\s][^{};]*?(?=\s*\{)/,string:{pattern:/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/\B!important\b/i,"function":/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.languages.css,Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css",greedy:!0}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag));
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(?:true|false)\b/,"function":/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?/,number:/(?:\b0x[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?)[ful]*/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|concept|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,"boolean":/\b(?:true|false)\b/,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/}),Prism.languages.insertBefore("cpp","keyword",{"class-name":{pattern:/(class\s+)\w+/i,lookbehind:!0}}),Prism.languages.insertBefore("cpp","string",{"raw-string":{pattern:/R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,alias:"string",greedy:!0}});
Prism.languages.nasm={comment:/;.*$/m,string:/(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,label:{pattern:/(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,lookbehind:!0,alias:"function"},keyword:[/\[?BITS (?:16|32|64)\]?/,{pattern:/(^\s*)section\s*[a-zA-Z.]+:?/im,lookbehind:!0},/(?:extern|global)[^;\r\n]*/i,/(?:CPU|FLOAT|DEFAULT).*$/m],register:{pattern:/\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|sp|si|di)|[cdefgs]s)\b/i,alias:"variable"},number:/(?:\b|(?=\$))(?:0[hx][\da-f]*\.?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|\d*\.?\d+(?:\.?e[+-]?\d+)?[dt]?)\b/i,operator:/[\[\]*+\-\/%<>=&|$!]/};
Prism.languages.rust={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:[{pattern:/b?r(#*)"(?:\\.|(?!"\1)[^\\\r\n])*"\1/,greedy:!0},{pattern:/b?"(?:\\.|[^\\\r\n"])*"/,greedy:!0}],"char":{pattern:/b?'(?:\\(?:x[0-7][\da-fA-F]|u{(?:[\da-fA-F]_*){1,6}|.)|[^\\\r\n\t'])'/,alias:"string"},"lifetime-annotation":{pattern:/'[^\s>']+/,alias:"symbol"},keyword:/\b(?:abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,attribute:{pattern:/#!?\[.+?\]/,greedy:!0,alias:"attr-name"},"function":[/\w+(?=\s*\()/,/\w+!(?=\s*\(|\[)/],"macro-rules":{pattern:/\w+!/,alias:"function"},number:/\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\d(?:_?\d)*)?\.?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:[iu](?:8|16|32|64)?|f32|f64))?\b/,"closure-params":{pattern:/\|[^|]*\|(?=\s*[{-])/,inside:{punctuation:/[|:,]/,operator:/[&*]/}},punctuation:/[{}[\];(),:]|\.+|->/,operator:/[-+*\/%!^]=?|=[=>]?|@|&[&=]?|\|[|=]?|<<?=?|>>?=?/};
!function(){function e(e,t){return Array.prototype.slice.call((t||document).querySelectorAll(e))}function t(e,t){return t=" "+t+" ",(" "+e.className+" ").replace(/[\n\t]/g," ").indexOf(t)>-1}function n(e,n,i){n="string"==typeof n?n:e.getAttribute("data-line");for(var o,l=n.replace(/\s+/g,"").split(","),a=+e.getAttribute("data-line-offset")||0,s=r()?parseInt:parseFloat,d=s(getComputedStyle(e).lineHeight),u=t(e,"line-numbers"),c=0;o=l[c++];){var p=o.split("-"),m=+p[0],f=+p[1]||m,h=e.querySelector('.line-highlight[data-range="'+o+'"]')||document.createElement("div");if(h.setAttribute("aria-hidden","true"),h.setAttribute("data-range",o),h.className=(i||"")+" line-highlight",u&&Prism.plugins.lineNumbers){var g=Prism.plugins.lineNumbers.getLine(e,m),y=Prism.plugins.lineNumbers.getLine(e,f);g&&(h.style.top=g.offsetTop+"px"),y&&(h.style.height=y.offsetTop-g.offsetTop+y.offsetHeight+"px")}else h.setAttribute("data-start",m),f>m&&h.setAttribute("data-end",f),h.style.top=(m-a-1)*d+"px",h.textContent=new Array(f-m+2).join(" \n");u?e.appendChild(h):(e.querySelector("code")||e).appendChild(h)}}function i(){var t=location.hash.slice(1);e(".temporary.line-highlight").forEach(function(e){e.parentNode.removeChild(e)});var i=(t.match(/\.([\d,-]+)$/)||[,""])[1];if(i&&!document.getElementById(t)){var r=t.slice(0,t.lastIndexOf(".")),o=document.getElementById(r);o&&(o.hasAttribute("data-line")||o.setAttribute("data-line",""),n(o,i,"temporary "),document.querySelector(".temporary.line-highlight").scrollIntoView())}}if("undefined"!=typeof self&&self.Prism&&self.document&&document.querySelector){var r=function(){var e;return function(){if("undefined"==typeof e){var t=document.createElement("div");t.style.fontSize="13px",t.style.lineHeight="1.5",t.style.padding=0,t.style.border=0,t.innerHTML="&nbsp;<br />&nbsp;",document.body.appendChild(t),e=38===t.offsetHeight,document.body.removeChild(t)}return e}}(),o=0;Prism.hooks.add("before-sanity-check",function(t){var n=t.element.parentNode,i=n&&n.getAttribute("data-line");if(n&&i&&/pre/i.test(n.nodeName)){var r=0;e(".line-highlight",n).forEach(function(e){r+=e.textContent.length,e.parentNode.removeChild(e)}),r&&/^( \n)+$/.test(t.code.slice(-r))&&(t.code=t.code.slice(0,-r))}}),Prism.hooks.add("complete",function l(e){var r=e.element.parentNode,a=r&&r.getAttribute("data-line");if(r&&a&&/pre/i.test(r.nodeName)){clearTimeout(o);var s=Prism.plugins.lineNumbers,d=e.plugins&&e.plugins.lineNumbers;t(r,"line-numbers")&&s&&!d?Prism.hooks.add("line-numbers",l):(n(r,a),o=setTimeout(i,1))}}),window.addEventListener("hashchange",i),window.addEventListener("resize",function(){var e=document.querySelectorAll("pre[data-line]");Array.prototype.forEach.call(e,function(e){n(e)})})}}();
</script>

</head>
<body>
<address align=right>
Document Number: D1189R0 <br />
Date: 2019-02-22 <br />
Audience: LEWG <br />
Reply-To: Barry Revzin, barry dot revzin at gmail dot com <br />
</address>
<hr /><h1 align=center><p>Adding &lt;=&gt; to library</p></h1>
<h2>Contents</h2>
<div class="toc">
<ol>
<li><a href="#introduction">Introduction</a><ol>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#non-member-hidden-friend-or-member">Non-member, hidden friend, or member?</a></li>
</ol>
</li>
<li><a href="#dealing-with-operator-and-operator">Dealing with operator==() and operator!=()</a><ol>
<li><a href="#most-operators-are-obsolete">Most operator!=()s are obsolete</a></li>
<li><a href="#reversed-operators-too">Reversed operator==s too</a></li>
<li><a href="#defaulting-operator">Defaulting operator==()</a></li>
</ol>
</li>
<li><a href="#adding-to-stdbasic_string">Adding &lt;=&gt; to std::basic_string</a><ol>
<li><a href="#add-a-type-alias">Add a type alias</a></li>
<li><a href="#add-a-static-member-function">Add a static member function</a></li>
<li><a href="#proposal">Proposal</a></li>
</ol>
</li>
<li><a href="#adding-to-stdvector">Adding &lt;=&gt; to std::vector</a><ol>
<li><a href="#proposal_1">Proposal</a></li>
</ol>
</li>
<li><a href="#adding-to-stdoptional">Adding &lt;=&gt; to std::optional</a><ol>
<li><a href="#proposal_2">Proposal</a></li>
</ol>
</li>
<li><a href="#adding-to-stdunique_ptr">Adding &lt;=&gt; to std::unique_ptr</a><ol>
<li><a href="#proposal_3">Proposal</a></li>
</ol>
</li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#references">References</a></li>
</ol>
</div>

<h2 id="introduction">1. Introduction<a class="self-link" href="#introduction"></a></h2>
<p>This paper builds on all of David Stone's effort in <a href="https://wg21.link/p0790r2" title="Effect of operator&lt;=&gt; on the C++ Standard Library">P0790R2</a> and exists just to fill in the missing holes. I believe it's very important to ship C++20 with <code class="language-cpp">&lt;=&gt;</code> for all of these types - and this is my attempt to help get there. Of the types which P0790R2 does not provide a solution, they can be divided into four neat categories, each with a canonical representative. This paper will go through these four in turn:</p>
<ul>
<li><code class="language-cpp">std::basic_string</code></li>
<li><code class="language-cpp">std::vector</code></li>
<li><code class="language-cpp">std::optional</code></li>
<li><code class="language-cpp">std::unique_ptr</code></li>
</ul>
<p>Critically, no change proposed in this paper will change the semantics of any comparison. The answer that a particular comparison gave in C++17 will be the same as what that code will give in C++20. But the path taken to get to that answer may change.</p>
<h3 id="motivation">1.1. Motivation<a class="self-link" href="#motivation"></a></h3>
<p>But why should we bother? What's the motivation for doing all this work?</p>
<p>Major benefits of <code class="language-cpp">operator&lt;=&gt;</code> are that it is easier to implement than the status quo comparisons implemented via <code class="language-cpp">operator&lt;</code>, that it can provide better performance than the status quo, and that it can be more correct than the status quo. But of course, none of that is true if we don't actually use it in our own library. There is the inevitable user frustration than this doesn't work:</p>
<pre class="codehilite"><code class="language-cpp">struct Person {
    std::string last;
    std::string first;
    auto operator&lt;=&gt;(Person const&amp;) const = default;
};</code></pre>


<p>Here is a type ready-made for a three-way comparison (indeed, it already has one), but defaulting doesn't work? So much for ease of use! </p>
<p>A user might then, if <a href="https://wg21.link/p1186r1" title="When do you actually use &lt;=&gt;?">P1186R1</a> is adopted, try to do this:</p>
<pre class="codehilite"><code class="language-cpp">struct Person {
    std::string last;
    std::string first;
    strong_ordering operator&lt;=&gt;(Person const&amp;) const = default;
};</code></pre>


<p>This will, potentially, walk each string twice - when we could have performed this comparison by walking each string only once (at most). So much for performance!</p>
<p>We don't even need to go into user types to see this issue. Consider:</p>
<pre class="codehilite"><code class="language-cpp">void func(std::vector&lt;std::string&gt; const&amp; names, std::vector&lt;std::string&gt; const&amp; other_names)
{
    if (names &lt; other_names) {
        // ...
    }
}</code></pre>


<p>Even though <code class="language-cpp">std::string</code> already has a three-way comparison function (by way of <code class="language-cpp">compare()</code>), the invocation of <code class="language-cpp">&lt;</code> above won't use it - it'll instead invoke <code class="language-cpp">&lt;</code> up to twice on each string. That's twice as much work as needs to be done to answer this question. If we adopt <code class="language-cpp">&lt;=&gt;</code> for all of thse library types as we should, then the above comparison would go through <code class="language-cpp">std::vector</code>'s <code class="language-cpp">&lt;=&gt;</code> which would go through <code class="language-cpp">std::string</code>'s <code class="language-cpp">&lt;=&gt;</code> which ensures that we only compare each <code class="language-cpp">string</code> at most one time. We're not just talking about making comparisons for user-defined types easier to write and more performant, we're also talking about making already existing comparisons of standard library types more performant.</p>
<p>And these problems stack, as the standard library types are inevitably used together. A <code class="language-cpp">std::optional&lt;std::vector&lt;std::string&gt;&gt;</code> should provide an <code class="language-cpp">operator&lt;=&gt;</code> with a comparison category of <code class="language-cpp">strong_ordering</code>, which should be efficient, and it should really be there for C++20.</p>
<h3 id="non-member-hidden-friend-or-member">1.2. Non-member, hidden friend, or member?<a class="self-link" href="#non-member-hidden-friend-or-member"></a></h3>
<p>This paper proposes adding a whole lot of <code class="language-cpp">operator&lt;=&gt;</code>s into the standard library. There are three ways we could do this:</p>
<ul>
<li>non-member functions</li>
<li>hidden friends</li>
<li>member functions</li>
</ul>
<p>Most (if not all?) of these operators are non-member functions today. This has the downside of polluting scope and increasing then number of candidates for each of the comparisons that overload resolution has to look through. It has the additional downside of allowing surprising conversions in certain cases simply because of ADL (e.g. <a href="https://wg21.link/lwg3065" title="LWG 2989 missed that all path's other operators should be hidden friends as well">LWG3065</a>).</p>
<p>This leads many people to rightly suggest to make operators hidden friends instead, which maintains the advantage of non-member functions by allowing conversions in both arguments but reduces the number of candidates for unrelated types and doesn't have surprise conversions in both arguments. However, it does introduce some new possibilities for conversions that did not exist with the non-member function approach. Consider (on <a href="https://godbolt.org/z/s7wxPE">godbolt</a>):</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct C {
#ifdef FRIEND
    friend bool operator&lt;(C, C);
#endif
};

#ifndef FRIEND
template &lt;typename T&gt;
bool operator&lt;(C&lt;T&gt;, C&lt;T&gt;);
#endif

void ex(C&lt;int&gt; a, C&lt;int&gt; b) {
    a &lt; b;                     // #1
    std::ref(a) &lt; b;           // #2
    a &lt; std::ref(b);           // #3
    std::ref(a) &lt; std::ref(b); // #4
}</code></pre>


<p>With the non-member operator template (i.e. without <code class="language-cpp">FRIEND</code> defined), only <code class="language-cpp">#1</code> is a valid expression. But with the hidden friend, <em>all four</em> are valid. These kind of additional conversions may be surprising - and it is certainly possible that they could lead to ambiguities. </p>
<p>But with <code class="language-cpp">operator&lt;=&gt;</code> we can actually take a third approach: member functions. Because <code class="language-cpp">&lt;=&gt;</code> considers reversed candidates as well, a member function is sufficient:</p>
<pre class="codehilite"><code class="language-cpp">struct X {
    X(int);
    bool operator==(X const&amp;) const;
    strong_ordering operator&lt;=&gt;(X const&amp;) const;
};

// all of these are ok
X{42} &lt; X{57};
X{42} &lt; 57;
42 &lt; X{57};
42 == X{57};
X{42} != 57;</code></pre>


<p>Using a member function does not pollute the global scope and does not add to the work that overload resolution has to do needlessly. It does have unique behavior where conversions are concerned though. If we return to the earlier example with <code class="language-cpp">C&lt;T&gt;</code>:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct C {
    std::strong_ordering operator&lt;=&gt;(C);
};

void ex(C&lt;int&gt; a, C&lt;int&gt; b) {
    a &lt; b;                     // #1
    std::ref(a) &lt; b;           // #2
    a &lt; std::ref(b);           // #3
    std::ref(a) &lt; std::ref(b); // #4
}</code></pre>


<p>With this implementation, <code class="language-cpp">#1</code> compiles straightforwardly. But <code class="language-cpp">#2</code> and <code class="language-cpp">#3</code> are <em>also</em> valid. <code class="language-cpp">#3</code> evaluates as <code class="language-cpp">a.operator&lt;=&gt;(std::ref(b)) &lt; 0</code> while <code class="language-cpp">#2</code> evaluates as <code class="language-cpp">0 &lt; b.operator&lt;=&gt;(std::ref(a))</code>. Only <code class="language-cpp">#4</code> is ill-formed in this case. Recall that in the non-member case, only <code class="language-cpp">#1</code> was valid and in the hidden friend case, all four were. </p>
<p>There, however, does exist a situation where moving from non-member comparison operator templates to a member spaceship function can change behavior. It's not completely free. This example courtesy of Tim Song:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>Non-member <code class="language-cpp">&lt;</code> template</p>
</th>
<th style="width:50%">
<p>Member <code class="language-cpp">&lt;=&gt;</code></p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px" data-line="4,5,6,7,10,11,12,13"><code class="language-cpp">template &lt;typename CharT, typename Traits, typename Alloc&gt;
struct basic_string { /* ... */ };

// #1
template &lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator&lt;(basic_string&lt;CharT, Traits, Alloc&gt; const&amp;,
               basic_string&lt;CharT, Traits, Alloc&gt; const&amp;);

struct B { };
// #2
template&lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator&lt;(basic_string&lt;CharT, Traits, Alloc&gt; const&amp;,
               B const&amp;);

struct C {
    operator string() const;
    operator B() const;
};

&quot;&quot;s &lt; C();</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px" data-line="3,4,10,11,12,13"><code class="language-cpp">template &lt;typename CharT, typename Traits, typename Alloc&gt;
struct basic_string {
    // #3
    auto operator&lt;=&gt;(basic_string const&amp;) const;
};



struct B { };
// #2
template&lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator&lt;(basic_string&lt;CharT, Traits, Alloc&gt; const&amp;,
               B const&amp;);

struct C {
    operator string() const;
    operator B() const;
};

&quot;&quot;s &lt; C();</code></pre>
</td>
</tr>
</table>

<p>Today, this goes through the global <code class="language-cpp">operator&lt;</code> template (<code class="language-cpp">#2</code>). The <code class="language-cpp">operator&lt;</code> taking two <code class="language-cpp">basic_string</code>s (<code class="language-cpp">#1</code>) is not a candidate because <code class="language-cpp">C</code> is not a <code class="language-cpp">basic_string</code>. However, if we change <code class="language-cpp">basic_string</code> to instead have a member spaceship operator... then this spaceship (<code class="language-cpp">#3</code>) suddenly not only becomes a candidate (since <code class="language-cpp">C</code> is convertible to <code class="language-cpp">string</code>) but actually becomes the best viable candidate because the tie-breaker preferring a non-template to a template is higher than the tie-breaker preferring a non-rewritten candidate to a rewritten one. The same thing would happen in the case of a hidden (non-template) friend.</p>
<p>This seems like a fairly contrived scenario. Though like all fairly contrived scenarios, it assuredly exists in some C++ code base somewhere. The most conservative approach would be to stay put and keep the proposed <code class="language-cpp">operator&lt;=&gt;</code>s as non-member operator templates. But there are very clear benefits of making them member functions, so I think member <code class="language-cpp">operator&lt;=&gt;</code> is still the way to go.</p>
<h2 id="dealing-with-operator-and-operator">2. Dealing with <code class="language-cpp">operator==()</code> and <code class="language-cpp">operator!=()</code><a class="self-link" href="#dealing-with-operator-and-operator"></a></h2>
<p>Before getting to how to handle <code class="language-cpp">operator&lt;=&gt;()</code> for all of these situations, let's first talk about the equality operators. There are several changes to how these operators behave as a result of <a href="https://wg21.link/p1185r1" title="&lt;=&gt; != ==">P1185R1</a> (R0 was approved by EWG in San Diego, R1 will likely be moved in Kona - there is still an open design question, but it is about a part of that proposal which is irrelevant to this paper). </p>
<h3 id="most-operators-are-obsolete">2.1. Most <code class="language-cpp">operator!=()</code>s are obsolete<a class="self-link" href="#most-operators-are-obsolete"></a></h3>
<p>The first part of P1185R1 changes the candidate set for inequality operators to include equality operators. In other words, for types in which <code class="language-cpp">a != b</code> is defined to mean <code class="language-cpp">!(a == b)</code>, we no longer need to define <code class="language-cpp">operator!=</code>. The language will simply do the right thing for us.
Just about every <code class="language-cpp">operator!=()</code> in the library does this. Indeed, we have blanket wording in [operators] which lets us avoid having to write the boilerplate every time. The only exceptions to this are:</p>
<ul>
<li>the types in the group represented by <code class="language-cpp">std::optional</code>, which will be discussed <a href="#adding-to-stdoptional">later</a></li>
<li><code class="language-cpp">std::valarray</code>, for which <code class="language-cpp">==</code> doesn't really mean equality anyway</li>
</ul>
<p>The other ~250 declarations of <code class="language-cpp">operator!=()</code> can just be removed entirely. The semantics for all callers will remain the same. </p>
<h3 id="reversed-operators-too">2.2. Reversed <code class="language-cpp">operator==</code>s too<a class="self-link" href="#reversed-operators-too"></a></h3>
<p>Some library types provided mixed-type equality operators. For example, the class template <code class="language-cpp">std::basic_string</code> provides the following equality and inequality operators today:</p>
<pre class="codehilite"><code class="language-cpp">// #1
template &lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator==(basic_string&lt;CharT, Traits, Alloc&gt; const&amp;, basic_string&lt;CharT, Traits, Alloc&gt; const&amp;);

// #2
template &lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator!=(basic_string&lt;CharT, Traits, Alloc&gt; const&amp;, basic_string&lt;CharT, Traits, Alloc&gt; const&amp;);

// #3
template &lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator==(basic_string&lt;CharT, Traits, Alloc&gt; const&amp;, CharT const*);

// #4
template &lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator==(CharT const*, basic_string&lt;CharT, Traits, Alloc&gt; const&amp;);

// #5
template &lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator!=(basic_string&lt;CharT, Traits, Alloc&gt; const&amp;, CharT const*);

// #6
template &lt;typename CharT, typename Traits, typename Alloc&gt;
bool operator!=(CharT const*, basic_string&lt;CharT, Traits, Alloc&gt; const&amp;);</code></pre>


<p>The previous section suggests removing the inequality operators (<code class="language-cpp">#2</code>, <code class="language-cpp">#5</code>, and <code class="language-cpp">#6</code>) and just relying on their equality counterparts to be used as rewritten candidates. But P1185R1, in addition to allowing inequality to be able to be rewritten as equality, also allows equality to be reversed. That is, a source expression <code class="language-cpp">a == b</code> can find <code class="language-cpp">b == a</code> as a candidate.</p>
<p>This means that <code class="language-cpp">#4</code> in the above isn't necessary either, since we can rely on <code class="language-cpp">"hello" == "hello"s</code> to invoke <code class="language-cpp">#3</code>. We really only need <code class="language-cpp">#1</code> and <code class="language-cpp">#3</code> in the above declarations. In other words, in order to be able to provide full equality and inequality between a <code class="language-cpp">basic_string</code> and its corresponding <code class="language-cpp">CharT const*</code>, we just need to write a single operator (<code class="language-cpp">#3</code>) instead of today's four. </p>
<p>This paper proposes removing all of these duplicated <code class="language-cpp">operator==</code> declarations as well. The full list is:</p>
<ul>
<li><code class="language-cpp">error_code</code> / <code class="language-cpp">error_condition</code></li>
<li><code class="language-cpp">optional&lt;T&gt;</code> / <code class="language-cpp">nullopt</code></li>
<li><code class="language-cpp">unique_ptr&lt;T,D&gt;</code> / <code class="language-cpp">nullptr_t</code></li>
<li><code class="language-cpp">shared_ptr&lt;T&gt;</code> / <code class="language-cpp">nullptr_t</code></li>
<li><code class="language-cpp">function&lt;R(Args...)&gt;</code> / <code class="language-cpp">nullptr_t</code></li>
<li><code class="language-cpp">move_iterator</code> / <code class="language-cpp">move_sentinel&lt;S&gt;</code></li>
<li><code class="language-cpp">counted_iterator</code> / <code class="language-cpp">default_sentinel_t</code></li>
<li><code class="language-cpp">unreachable_sentinel_t</code> / <code class="language-cpp">I</code></li>
<li><code class="language-cpp">istream_iterator</code> / <code class="language-cpp">default_sentinel_t</code></li>
<li><code class="language-cpp">istreambuf_iterator</code> / <code class="language-cpp">default_sentinel_t</code></li>
<li><code class="language-cpp">filter_view::iterator</code> / <code class="language-cpp">filter_view::sentinel</code></li>
<li><code class="language-cpp">transform_view::iterator</code> / <code class="language-cpp">transform_view::sentinel</code></li>
<li><code class="language-cpp">iota_view::iterator</code> / <code class="language-cpp">iota_view::sentinel</code></li>
<li><code class="language-cpp">take_view::iterator</code> / <code class="language-cpp">take_view::sentinel</code></li>
<li><code class="language-cpp">join_view::iterator</code> / <code class="language-cpp">join_view::sentinel</code></li>
<li><code class="language-cpp">split_view::outer_iterator</code> / <code class="language-cpp">default_sentinel_t</code></li>
<li><code class="language-cpp">split_view::inner_iterator</code> / <code class="language-cpp">default_sentinel_t</code></li>
<li><code class="language-cpp">complex&lt;T&gt;</code> / <code class="language-cpp">T</code></li>
<li><code class="language-cpp">valarray&lt;T&gt;</code> / <code class="language-cpp">valarray&lt;T&gt;::value_type</code></li>
<li><code class="language-cpp">leap</code> / <code class="language-cpp">sys_time&lt;D&gt;</code></li>
<li><code class="language-cpp">sub_match</code> / <code class="language-cpp">basic_string</code></li>
<li><code class="language-cpp">sub_match</code> / <code class="language-cpp">value_type const*</code></li>
<li><code class="language-cpp">sub_match</code> / <code class="language-cpp">value_type const&amp;</code></li>
</ul>
<p>Note that even though this paper is not removing <code class="language-cpp">optional&lt;T&gt;</code>'s or <code class="language-cpp">valarray&lt;T&gt;</code>s <code class="language-cpp">operator!=</code>s as a whole, it can still remove the reversed <code class="language-cpp">operator==</code>s and the corresponding reversed <code class="language-cpp">operator!=</code>s.</p>
<h3 id="defaulting-operator">2.3. Defaulting <code class="language-cpp">operator==()</code><a class="self-link" href="#defaulting-operator"></a></h3>
<p>Another important aspect of P1185 is that it redefines "strong structural equality" to be based on a defaulted <code class="language-cpp">operator==()</code> rather than a defaulted <code class="language-cpp">operator&lt;=&gt;()</code>, which is the requirement for a type being usable as a non-type template parameter - a new C++20 language feature introduced by way of <a href="https://wg21.link/p0732r2" title="Class Types in Non-Type Template Parameters">P0732R2</a></p>
<p>There are many library types which currently define their <code class="language-cpp">operator==()</code> as member-wise equality. Respecifying all of these <code class="language-cpp">operator==()</code>s as being <code class="language-cpp">default</code>ed instead will not change any semantics or ABI, but will simply directly allow these types to be usable as non-type template parameters. So this paper proposes to do that for:</p>
<ul>
<li><code class="language-cpp">pair</code></li>
<li><code class="language-cpp">tuple</code></li>
<li><code class="language-cpp">array</code></li>
</ul>
<p>... and any library type that meets this member-wise equality condition that is missing from the above list.</p>
<h2 id="adding-to-stdbasic_string">3. Adding <code class="language-cpp">&lt;=&gt;</code> to <code class="language-cpp">std::basic_string</code><a class="self-link" href="#adding-to-stdbasic_string"></a></h2>
<p>This group is composed of templates which implement their comparisons via <code class="language-cpp">Traits::compare()</code>: <code class="language-cpp">std::basic_string</code>, <code class="language-cpp">std::basic_string_view</code>, and <code class="language-cpp">std::sub_match</code>. Because <code class="language-cpp">Traits::compare()</code> is already a three-way comparison, this seems like a trivial case. Just write this and ship it right?</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename CharT, typename Traits, typename Alloc&gt;
auto operator&lt;=&gt;(basic_string&lt;CharT, Traits, Alloc&gt; const&amp; lhs,
                 basic_string&lt;CharT, Traits, Alloc&gt; const&amp; rhs)
{
    return lhs.compare(rhs) &lt;=&gt; 0;
}</code></pre>


<p>Unfortunately, since <code class="language-cpp">lhs.compare(rhs)</code> is an <code class="language-cpp">int</code>, this would unconditionally yield a <code class="language-cpp">std::strong_ordering</code>. The result of this will be correct as far as all the binary comparisons though, but comparing arbitrary <code class="language-cpp">basic_string</code>'s is not necessarily a <code class="language-cpp">strong_ordering</code>. Indeed, the <a href="http://www.gotw.ca/gotw/029.htm" title="GotW #29: Strings">canonical example</a> of providing a custom <code class="language-cpp">Traits</code> for <code class="language-cpp">basic_string</code> is to implement a case-insensitive comparison - which should be a <code class="language-cpp">weak_ordering</code>. So we cannot simply pick <code class="language-cpp">strong_ordering</code>. On the other hand, <code class="language-cpp">std::string</code>'s <code class="language-cpp">operator&lt;=&gt;</code> should <em>certainly</em> yield <code class="language-cpp">strong_ordering</code> so we cannot simply pick <code class="language-cpp">weak_ordering</code> either. We'll have to do something slightly more complex.</p>
<p>We could simply bless all the standard-mandated specializations of <code class="language-cpp">std::char_traits</code> and say that those are <code class="language-cpp">strong_ordering</code>, and any other trait is a <code class="language-cpp">weak_ordering</code>. But that seems overly restrictive on users who might want to provide a custom traits which provides an ordering which is either strong or partial. </p>
<p>Instead, I propose one of two choices: add a member type alias to the traits expressing the comparison category, or add a new static member function performing a three-way comparison and yielding a comparison category.</p>
<h3 id="add-a-type-alias">3.1. Add a type alias<a class="self-link" href="#add-a-type-alias"></a></h3>
<p>This is the least intrusive option. Simply add a member alias to the standard-mandated specializations of <code class="language-cpp">char_traits</code>:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;&gt; struct char_traits&lt;char&gt; {
    using comparison_category = strong_ordering;
};</code></pre>


<p>And replace the four relational operators with an <code class="language-cpp">operator&lt;=&gt;</code> whose return type is based on that category:</p>
<pre class="codehilite"><code class="language-cpp">// exposition-only
template &lt;typename T&gt;
struct traits_category {
    using type = weak_ordering;
};

template &lt;typename T&gt;
    requires requires { typename T::comparison_category; }
struct traits_category {
    using type = typename T::comparison_category;
};

template &lt;typename T&gt;
using traits_category_t = typename traits_category&lt;T&gt;::type;

// actual implementation
template &lt;typename CharT, typename Traits, typename Alloc&gt;
class basic_string {
    // ...
    traits_category_t&lt;Traits&gt; operator&lt;=&gt;(basic_string const&amp; rhs) const
    {
        return compare(rhs) &lt;=&gt; 0;
    }
    // ...
};</code></pre>


<p>This works because <code class="language-cpp">int</code>'s comparison category is <code class="language-cpp">strong_ordering</code>, which is implicitly convertible to any other comparison category.</p>
<p>This is a fairly small change. The downside is that any future custom traits will still have to write <code class="language-cpp">compare()</code> functions that return an <code class="language-cpp">int</code> instead of one of the standard comparison categories. To that end, we could:</p>
<h3 id="add-a-static-member-function">3.2. Add a static member function<a class="self-link" href="#add-a-static-member-function"></a></h3>
<p>Add a static member function returning a comparison category:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;&gt; struct char_traits&lt;char&gt; {
    static constexpr strong_ordering compare_3way(const char* s1, const char* s2, size_t count)
    {
        return compare(s1, s2, count) &lt;=&gt; 0;
    }
};</code></pre>


<p>And then use that if it is present:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename CharT, typename Traits, typename Alloc&gt;
class basic_string {
    // ...
    auto operator&lt;=&gt;(basic_string const&amp; rhs) const
    {
        auto impl = [](CharT const* lhs, CharT const* rhs, size_t sz) {
            if constexpr (requires { Traits::compare_3way(lhs, rhs, sz); }) {
                return Traits::compare_3way(lhs, rhs, sz);
            } else {
                return static_cast&lt;weak_ordering&gt;(
                    Traits::compare(lhs, rhs, sz) &lt;=&gt; 0);
            }
        };

        auto cmp = impl(data(), rhs.data(), min(size(), rhs.size()));
        return cmp != 0 ? cmp : size() &lt;=&gt; rhs.size();
    }
    // ...
};</code></pre>


<p>This is somewhat more involved than the previous alternative, but not by much. Since we'd still need to provide a version of <code class="language-cpp">compare</code> that returns an <code class="language-cpp">int</code>, this may not actually be worth it - since while it's very easy to convert an <code class="language-cpp">int</code> to a comparison category (simply <code class="language-cpp">&lt;=&gt;</code> it against <code class="language-cpp">0</code>), there's no actual easy way of going the other way without branching. But it <em>does</em> offer a way to make a <code class="language-cpp">basic_string</code> with a partial ordering, if that is desired.  </p>
<h3 id="proposal">3.3. Proposal<a class="self-link" href="#proposal"></a></h3>
<p>I weakly favor the member type alias approach. Remove <code class="language-cpp">operator&lt;</code>, <code class="language-cpp">operator&gt;</code>, <code class="language-cpp">operator&lt;=</code>, and <code class="language-cpp">operator&gt;=</code> for <code class="language-cpp">basic_string</code>, <code class="language-cpp">basic_string_view</code>, and <code class="language-cpp">sub_match</code> and replace them with <code class="language-cpp">operator&lt;=&gt;</code>s which invoke <code class="language-cpp">x.compare(y) &lt;=&gt; 0</code> cast to the appropriate comparison category (with argument adjustments as appropriate). This <code class="language-cpp">operator&lt;=&gt;</code> should be a member function. </p>
<h2 id="adding-to-stdvector">4. Adding <code class="language-cpp">&lt;=&gt;</code> to <code class="language-cpp">std::vector</code><a class="self-link" href="#adding-to-stdvector"></a></h2>
<p>There are many types in the standard library that are, fundamentally, sequences of objects. Those sequences can be heterogeneous or homogeneous, fixed-length or variable-length, but they're all still sequences. The way we order these sequences, the way we write the comparison operators for them today, is lexicographically. Basically, this general algorithm:</p>
<pre class="codehilite"><code class="language-cpp">bool operator&lt;(Sequence const&amp; x, Sequence const&amp; y) {
    size_t const N = min(x.size(), y.size());
    if (x[0] &lt; y[0]) return true;
    if (y[0] &lt; x[0]) return false;

    if (x[1] &lt; y[1]) return true;
    if (y[1] &lt; x[1]) return false;

    // ...

    if (x[N-1] &lt; y[N-1]) return true;
    if (y[N-1] &lt; x[N-1]) return false;

    return x.size() &lt; y.size();
}</code></pre>


<p>For variable-sized sequences, this means we perform up to <code class="language-cpp">2N</code> invocations of an underlying <code class="language-cpp">operator&lt;</code>. For fixed-size sequences, we can optimize out the last two comparisons here so we only do up to <code class="language-cpp">2N-1</code> such invocations. </p>
<p>There are two important things to point about comparing sequences.</p>
<ul>
<li>Every underlying type must be totally ordered. We are assuming that once <code class="language-cpp">x[i] &lt; y[i]</code> and <code class="language-cpp">y[i] &lt; x[i]</code> are both <code class="language-cpp">false</code> that these elements are equivalent. For partial orders, this will give nonsense answers - which is why the standard library today simply states that comparing sequences with unordered elements are undefined behavior (e.g. <code class="language-cpp">vector&lt;float&gt;</code> with any <code class="language-cpp">NAN</code>).</li>
<li>We are basically <em>already</em> doing three-way comparisons here. It's not enough to know the result of <code class="language-cpp">operator&lt;</code> - we need to know the full three-way ordering between every pair of elements. </li>
</ul>
<p>Since we are doing what looks a lot like a three-way comparison anyway, we can write a direct translation of the above algorithm to <code class="language-cpp">operator&lt;=&gt;</code> as follows:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p><code class="language-cpp">operator&lt;()</code></p>
</th>
<th style="width:50%">
<p><code class="language-cpp">operator&lt;=&gt;()</code></p>
</th>
</tr>
<tr>
<td style="width:50%">
<pre style="background:transparent;border:0px"><code class="language-cpp">bool operator&lt;(Sequence const&amp; x, Sequence const&amp; y) {
    size_t const N = min(x.size(), y.size());
    if (x[0] &lt; y[0]) return true;
    if (y[0] &lt; x[0]) return false;

    if (x[1] &lt; y[1]) return true;
    if (y[1] &lt; x[1]) return false;

    // ...

    if (x[N-1] &lt; y[N-1]) return true;
    if (y[N-1] &lt; x[N-1]) return false;

    return x.size() &lt; y.size();
}</code></pre>
</td>
<td style="width:50%">
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
weak_ordering __cmp(T const&amp; a, T const&amp; b) {
    if (a &lt; b) return weak_ordering::less;
    if (b &lt; a) return weak_ordering::greater;
    return weak_ordering::equivalent;
}

weak_ordering operator&lt;=&gt;(Sequence const&amp; x, Sequence const&amp; y) {
    size_t const N = min(x.size(), y.size());
    if (auto c = __cmp(x[0], y[0]); c != 0) return c;
    if (auto c = __cmp(x[1], y[1]); c != 0) return c;
    // ...        
    if (auto c = __cmp(x[N-1], y[N-1]); c != 0) return c;

    return x.size() &lt;=&gt; y.size();
}</code></pre>
</td>
</tr>
</table>

<p>The implementation at right has the same semantics as the implementation at the left, it gives the same answer in all cases... because really we're performing exactly the same operations in the same order. Just slightly restructured. But once we restructure this way, we can do a lot better by simply using <code class="language-cpp">&lt;=&gt;</code> where possible:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p><code class="language-cpp">operator&lt;()</code></p>
</th>
<th style="width:50%">
<p><code class="language-cpp">operator&lt;=&gt;()</code></p>
</th>
</tr>
<tr>
<td style="width:50%">
<pre style="background:transparent;border:0px"><code class="language-cpp">bool operator&lt;(Sequence const&amp; x, Sequence const&amp; y) {
    size_t const N = min(x.size(), y.size());
    if (x[0] &lt; y[0]) return true;
    if (y[0] &lt; x[0]) return false;

    if (x[1] &lt; y[1]) return true;
    if (y[1] &lt; x[1]) return false;

    // ...

    if (x[N-1] &lt; y[N-1]) return true;
    if (y[N-1] &lt; x[N-1]) return false;

    return x.size() &lt; y.size();
}</code></pre>
</td>
<td style="width:50%">
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;ThreeWayComparable T&gt;
auto __cmp(T const&amp; a, T const&amp; b) {
    return a &lt;=&gt; b;
}

template &lt;typename T&gt;
weak_ordering __cmp(T const&amp; a, T const&amp; b) {
    if (a &lt; b) return weak_ordering::less;
    if (b &lt; a) return weak_ordering::greater;
    return weak_ordering::equivalent;
}

???? operator&lt;=&gt;(Sequence const&amp; x, Sequence const&amp; y) {
    size_t const N = min(x.size(), y.size());
    if (auto c = __cmp(x[0], y[0]); c != 0) return c;
    if (auto c = __cmp(x[1], y[1]); c != 0) return c;
    // ...        
    if (auto c = __cmp(x[N-1], y[N-1]); c != 0) return c;

    return x.size() &lt;=&gt; y.size();
}</code></pre>
</td>
</tr>
</table>

<p><code class="language-cpp">ThreeWayComparable</code> is a concept proposed in <a href="https://wg21.link/p1188r0" title="Library utilities for &lt;=&gt;">P1188R0</a>.</p>
<p>Now, I will claim that the implementation at right is superior to the implementation at left, even in the cases where the underlying objects don't provide <code class="language-cpp">&lt;=&gt;</code>. Consider a normal type that might exist in any given code-base today:</p>
<pre class="codehilite"><code class="language-cpp">struct Legacy {
    bool operator&lt;(Legacy const&amp;) const;
};</code></pre>


<p>Let's build from this. If I compare two <code class="language-cpp">pair&lt;Legacy, int&gt;</code>s - either using the preexisting <code class="language-cpp">operator&lt;</code> (the left implementation) or the suggested <code class="language-cpp">operator&lt;=&gt;</code> (the right implementation), I'm going to do the same operations either way: at most two invocations of <code class="language-cpp">Legacy::operator&lt;</code>. Unsurprising. But what if I compare two <code class="language-cpp">vector&lt;pair&lt;Legacy, int&gt;&gt;</code>s? As I mentioned earlier, we perform up to <code class="language-cpp">2N</code> invocations of the <code class="language-cpp">operator&lt;</code> for each object... which means in this case we're performing up to <code class="language-cpp">4N</code> invocations of <code class="language-cpp">Legacy::operator&lt;</code> if we stick with today's <code class="language-cpp">operator&lt;</code> implementation. This is because we have to compare each <code class="language-cpp">pair</code> in both directions. But if we use the <code class="language-cpp">operator&lt;=&gt;</code> rewrite for both <code class="language-cpp">pair</code> and <code class="language-cpp">vector</code>, we only have to perform up to <code class="language-cpp">2N</code> invocations of <code class="language-cpp">Legacy::operator&lt;</code>! This is because we're no longer throwing away work. </p>
<p>Of course, if the underlying objects <em>do</em> provide <code class="language-cpp">&lt;=&gt;</code>, this can be even better. Comparing two <code class="language-cpp">vector&lt;pair&lt;string, int&gt;&gt;</code> will transition from up to <code class="language-cpp">4N</code> invocations of <code class="language-cpp">basic_string::operator&lt;</code> to up to <code class="language-cpp">N</code> invocations of <code class="language-cpp">basic_string::operator&lt;=&gt;</code>.  That's... a lot.</p>
<p>In addition to the free performance win (fewer potential comparisons) and free complexity win (fewer functions to write and providing an <code class="language-cpp">operator&lt;=&gt;</code> makes it easier for users that use templates as members to write their own <code class="language-cpp">operator&lt;=&gt;</code>s), there's also a nice semantics win that we get from such a transition. I mentioned earlier how these sequence types do not work for partially ordered subtypes. But for types which provide an <code class="language-cpp">operator&lt;=&gt;</code> which returns <code class="language-cpp">std::partial_ordering</code> - we can easily do the right thing and provide sound comparisons that are themselves partially ordered. Less undefined behavior, which typically would manifest as just wrong or nonsense answers. </p>
<h3 id="proposal_1">4.1. Proposal<a class="self-link" href="#proposal_1"></a></h3>
<p>Remove <code class="language-cpp">operator&lt;</code>, <code class="language-cpp">operator&gt;</code>, <code class="language-cpp">operator&lt;=</code>, and <code class="language-cpp">operator&gt;=</code> for <code class="language-cpp">array</code>, <code class="language-cpp">deque</code>, <code class="language-cpp">forward_list</code>, <code class="language-cpp">list</code>, <code class="language-cpp">map</code>, <code class="language-cpp">move_iterator</code>, <code class="language-cpp">multimap</code>, <code class="language-cpp">multiset</code>, <code class="language-cpp">pair</code>, <code class="language-cpp">set</code>, <code class="language-cpp">tuple</code>, <code class="language-cpp">unordered_map</code>, <code class="language-cpp">unordered_multimap</code>, <code class="language-cpp">unordered_multiset</code>, <code class="language-cpp">unordered_set</code>, and <code class="language-cpp">vector</code> (including <code class="language-cpp">vector&lt;bool&gt;</code>). For each of them, add a <code class="language-cpp">operator&lt;=&gt;</code> with the same comparison semantics as today which compares each type <code class="language-cpp">T</code> as if by the exposition-only <code class="language-cpp">__cmp</code> function template above. These <code class="language-cpp">operator&lt;=&gt;</code>s should be member functions.</p>
<h2 id="adding-to-stdoptional">5. Adding <code class="language-cpp">&lt;=&gt;</code> to <code class="language-cpp">std::optional</code><a class="self-link" href="#adding-to-stdoptional"></a></h2>
<p>This group is composed of templates which forward <em>all</em> of their operations to underlying types. No operator is written in terms of any other operator. Even <code class="language-cpp">!=</code> is not defined in terms of <code class="language-cpp">==</code>. This group includes <code class="language-cpp">std::optional</code>, <code class="language-cpp">std::variant</code>, <code class="language-cpp">std::queue</code>, <code class="language-cpp">std::stack</code>, and <code class="language-cpp">std::reverse_iterator</code>.</p>
<p>Unlike the types in the previous section - which were all sequences of some kind that assume a total order - the types in this group do not assume any semantics at all. An important consequence is that they provide the correct answer for types that have partial orders:</p>
<pre class="codehilite"><code class="language-cpp">struct Q {
    float f;
    bool operator==(Q const&amp; rhs) const { return f == rhs.f; }
    bool operator&lt; (Q const&amp; rhs) const { return f &lt; rhs.f; }
    bool operator&gt; (Q const&amp; rhs) const { return f &gt; rhs.f; }
};

// partial order, so no trichotomy
Q{1.f} == Q{NAN}; // false
Q{1.f} &lt; Q{NAN};  // false
Q{1.f} &gt; Q{NAN};  // false

// the types in the previous category assume trichotomy
vector&lt;Q&gt;{1.f} == vector&lt;Q&gt;{NAN}; // false
vector&lt;Q&gt;{1.f} &lt; vector&lt;Q&gt;{NAN};  // false
vector&lt;Q&gt;{1.f} &gt; vector&lt;Q&gt;{NAN};  // true?!

// but the types in this category do not
optional&lt;Q&gt;{1.f} == optional&lt;Q&gt;{NAN}; // false
optional&lt;Q&gt;{1.f} &lt; optional&lt;Q&gt;{NAN};  // false
optional&lt;Q&gt;{1.f} &gt; optional&lt;Q&gt;{NAN};  // false</code></pre>


<p>This design for <code class="language-cpp">optional</code> and <code class="language-cpp">variant</code> is a result of <a href="https://wg21.link/p0307r2" title="Making Optional Greater Equal Again">P0307R2</a>. I do not know why <code class="language-cpp">queue</code> and <code class="language-cpp">stack</code> even have comparisons, or why <code class="language-cpp">reverse_iterator</code> behaves this way.</p>
<p>But the important thing is that we cannot change the semantics of <code class="language-cpp">optional</code> - the previous solution of synthesizing a <code class="language-cpp">weak_ordering</code> from applying <code class="language-cpp">operator&lt;</code> in both direction is not okay here. That would change the answer for some comparisons, and this paper will not change semantics.</p>
<p>It turns out we cannot synthesize a <code class="language-cpp">partial_ordering</code> either. The only sound way to do such a synthesis would be:</p>
<pre class="codehilite"><code class="language-cpp">partial_ordering __cmp_partial(Q const&amp; a, Q const&amp; b)
{
    if (a == b) return partial_ordering::equivalent;
    if (a &lt; b)  return partial_ordering::less;
    if (b &lt; a)  return partial_ordering::greater;
    return partial_ordering::unordered;
}</code></pre>


<p>But this requires additional operations on <code class="language-cpp">Q</code>. Today, I can compare two <code class="language-cpp">optional&lt;Q&gt;</code>'s with <code class="language-cpp">&lt;</code> with <code class="language-cpp">Q</code> only having <code class="language-cpp">&lt;</code>... and importantly I can compare two <code class="language-cpp">optional&lt;Q&gt;</code>'s with <code class="language-cpp">&gt;</code> with <code class="language-cpp">Q</code> only having <code class="language-cpp">&gt;</code>. There's no way to synthesize a <code class="language-cpp">&lt;=&gt;</code> for <code class="language-cpp">optional&lt;Q&gt;</code> in this scenario that has both the same semantics and the same operational requirements. That is a non-starter. </p>
<p>However, it's still really important to add <code class="language-cpp">&lt;=&gt;</code> to these types for the same reason it's important to add <code class="language-cpp">&lt;=&gt;</code> to the other types. It's just more difficult to do. Our only option is to adopt a new <code class="language-cpp">operator&lt;=&gt;</code> that is constrained on the underlying types having <code class="language-cpp">&lt;=&gt;</code> ensuring that <code class="language-cpp">operator&lt;=&gt;</code> is <em>more constrained than</em> each of the two-way relational operators. Such an implementation, based on P1188R0, might look like:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    template &lt;ThreeWayComparableWith&lt;T&gt; U&gt;
    compare_3way_type_t&lt;T,U&gt; operator&lt;=&gt;(optional&lt;U&gt; const&amp; rhs) const;
    {
        if (has_value() &amp;&amp; rhs.has_value()) {
            return **this &lt;=&gt; *rhs;
        } else {
            return has_value() &lt;=&gt; rhs.has_value();
        }
    }
    // ...
};</code></pre>


<p>Making the spaceship operator more constrained that the other relational operators ensures that it gets precedence over them during normal comparisons. </p>
<h3 id="proposal_2">5.1. Proposal<a class="self-link" href="#proposal_2"></a></h3>
<p>Add a new <code class="language-cpp">operator&lt;=&gt;</code> for each kind of comparison for <code class="language-cpp">optional</code>, <code class="language-cpp">variant</code>, <code class="language-cpp">queue</code>, <code class="language-cpp">stack</code>, and <code class="language-cpp">reverse_iterator</code> such that <code class="language-cpp">operator&lt;=&gt;</code> is constrained on the relevant template parameters satisfying <code class="language-cpp">ThreeWayComparableWith</code> (or just <code class="language-cpp">ThreeWayComparable</code>), ensuring that <code class="language-cpp">operator&lt;=&gt;</code> is the best viable candidate for all relational comparisons in code. This <code class="language-cpp">operator&lt;=&gt;</code> should be a member function.</p>
<p>Do not remove any of the preexisting comparison operators for these types, including even <code class="language-cpp">operator!=()</code>.</p>
<p>The exception is the comparisons between <code class="language-cpp">optional&lt;T&gt;</code> and <code class="language-cpp">nullopt</code>. Those do not actually depend on the semantics of <code class="language-cpp">T</code> in any way - so in this particular case, we can remove the relational operators and all the reversed candidates and replace them with member <code class="language-cpp">operator&lt;=&gt;</code>. Instead of the 12 operator functions we have today, we only need two - both of whose implementations are trivial:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
class optional {
public:
    bool operator==(nullopt_t) const { return !has_value(); }
    strong_ordering operator&lt;=&gt;(nullopt_t) const { return has_value() &lt;=&gt; false; }
};</code></pre>


<h2 id="adding-to-stdunique_ptr">6. Adding <code class="language-cpp">&lt;=&gt;</code> to <code class="language-cpp">std::unique_ptr</code><a class="self-link" href="#adding-to-stdunique_ptr"></a></h2>
<p>For <code class="language-cpp">std::unique_ptr</code> and <code class="language-cpp">std::shared_ptr</code>, the comparison of <code class="language-cpp">&lt;</code> does not use raw <code class="language-cpp">operator&lt;</code> but rather goes through <code class="language-cpp">std::less</code>. However, they do this in a slightly different way: Comparing a <code class="language-cpp">unique_ptr&lt;T1,D1&gt;</code> to a <code class="language-cpp">unique_ptr&lt;T2,D2&gt;</code> goes through <code class="language-cpp">less&lt;common_type_t&lt;unique_ptr&lt;T1,D1&gt;::pointer, unique_ptr&lt;T2,D2&gt;::pointer&gt;&gt;</code> whereas comparing a <code class="language-cpp">shared_ptr&lt;T1&gt;</code> to a <code class="language-cpp">shared_ptr&lt;T2&gt;</code> goes through <code class="language-cpp">less&lt;&gt;</code>. </p>
<p>Either way, P1188R0 proposes a three-way comparison object named <code class="language-cpp">std::compare_3way</code> that satisfies the requirement that the ordering is a strict weak order, using the same wording that we have for <code class="language-cpp">std::less</code> today. We can use this object to implement the comparisons doing something like:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, typename D&gt;
class unique_ptr {
    // ...
    template &lt;typename T2, typename D2&gt;
    auto operator&lt;=&gt;(unique_ptr&lt;T2,D2&gt; const&amp; rhs) const
    {
        using CT = common_type_t&lt;pointer, typename unique_ptr&lt;T2,D2&gt;::pointer&gt;;
        return compare_3way&lt;CT&gt;()(get(), rhs.get());
    }
    // ...
};

template &lt;typename T&gt;
class shared_ptr {
    // ...
    template &lt;typename U&gt;
    auto operator&lt;=&gt;(shared_ptr&lt;U&gt; const&amp; rhs) const
    {
        return compare_3way()(get(), rhs.get());
    }
    // ...
};</code></pre>


<h3 id="proposal_3">6.1. Proposal<a class="self-link" href="#proposal_3"></a></h3>
<p>Remove <code class="language-cpp">operator&lt;</code>, <code class="language-cpp">operator&gt;</code>, <code class="language-cpp">operator&lt;=</code>, and <code class="language-cpp">operator&gt;=</code> for <code class="language-cpp">unique_ptr</code> and <code class="language-cpp">shared_ptr</code> and replace them with <code class="language-cpp">operator&lt;=&gt;</code>s which go through the proposed <code class="language-cpp">compare_3way</code> function object in the same way that the preexisting comparisons do today. These <code class="language-cpp">operator&lt;=&gt;</code>s should be member functions.</p>
<h2 id="acknowledgements">7. Acknowledgements<a class="self-link" href="#acknowledgements"></a></h2>
<p>Thanks to David Stone for all the rest of the library work. Thanks to Agustín Bergé, Tim Song, Herb Sutter, and Jonathan Wakely for discussing issues around these cases. </p>
<h2 id="references">8. References<a class="self-link" href="#references"></a></h2><ul><li><a href="https://cplusplus.github.io/LWG/issue3065">[LWG3065]</a><span style="margin-left: 5px;">"LWG 2989 missed that all path's other operators should be hidden friends as well" by Billy O'Neal III, 2018-11-13</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf">[P0307R2]</a><span style="margin-left: 5px;">"Making Optional Greater Equal Again" by Tony Van Eerd, 2016-03-15</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r2.pdf">[P0732R2]</a><span style="margin-left: 5px;">"Class Types in Non-Type Template Parameters" by Jeff Snyder, Louis Dionne, 2018-06-06</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0790r2.html">[P0790R2]</a><span style="margin-left: 5px;">"Effect of operator&lt;=&gt; on the C++ Standard Library" by David Stone, 2019-01-21</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1185r1.html">[P1185R1]</a><span style="margin-left: 5px;">"&lt;=&gt; != ==" by Barry Revzin, 2019-01-22</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1186r1.html">[P1186R1]</a><span style="margin-left: 5px;">"When do you actually use &lt;=&gt;?" by Barry Revzin, 2019-01-22</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1188r0.html">[P1188R0]</a><span style="margin-left: 5px;">"Library utilities for &lt;=&gt;" by Barry Revzin, 2019-01-22</span></li><li><a href="http://www.gotw.ca/gotw/029.htm">[gotw.29]</a><span style="margin-left: 5px;">"GotW #29: Strings" by Herb Sutter, 1998-01-03</span></li></ul>
</html>