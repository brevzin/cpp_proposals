<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2022-02-14" />
  <title>ranges::copy should say output_iterator somewhere</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center"><code class="sourceCode cpp">ranges<span class="op">::</span>copy</code> should say <code class="sourceCode cpp">output_iterator</code> somewhere</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P2550R0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2022-02-14</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      LWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction<span></span></a>
<ul>
<li><a href="#output-concept-hierarchy"><span class="toc-section-number">1.1</span> Output concept hierarchy<span></span></a></li>
<li><a href="#does-anything-in-ranges-use-output_iterator"><span class="toc-section-number">1.2</span> Does anything in Ranges use <code class="sourceCode cpp">output_iterator</code>?<span></span></a></li>
</ul></li>
<li><a href="#proposal-a-weaker-output-iterator"><span class="toc-section-number">2</span> Proposal: A Weaker Output Iterator<span></span></a>
<ul>
<li><a href="#wording"><span class="toc-section-number">2.1</span> Wording<span></span></a>
<ul>
<li><a href="#rangescopy"><span class="toc-section-number">2.1.1</span> <code class="sourceCode cpp">ranges<span class="op">::</span>copy</code><span></span></a></li>
<li><a href="#rangescopy_n"><span class="toc-section-number">2.1.2</span> <code class="sourceCode cpp">ranges<span class="op">::</span>copy_n</code><span></span></a></li>
<li><a href="#rangescopy_if"><span class="toc-section-number">2.1.3</span> <code class="sourceCode cpp">ranges<span class="op">::</span>copy_if</code><span></span></a></li>
<li><a href="#rangesmove"><span class="toc-section-number">2.1.4</span> <code class="sourceCode cpp">ranges<span class="op">::</span>move</code><span></span></a></li>
<li><a href="#rangestransform"><span class="toc-section-number">2.1.5</span> <code class="sourceCode cpp">ranges<span class="op">::</span>transform</code><span></span></a></li>
<li><a href="#rangesreplace_copy"><span class="toc-section-number">2.1.6</span> <code class="sourceCode cpp">ranges<span class="op">::</span>replace_copy</code><span></span></a></li>
<li><a href="#rangesfill"><span class="toc-section-number">2.1.7</span> <code class="sourceCode cpp">ranges<span class="op">::</span>fill</code><span></span></a></li>
<li><a href="#rangesgenerate"><span class="toc-section-number">2.1.8</span> <code class="sourceCode cpp">ranges<span class="op">::</span>generate</code><span></span></a></li>
<li><a href="#rangesremove_copy"><span class="toc-section-number">2.1.9</span> <code class="sourceCode cpp">ranges<span class="op">::</span>remove_copy</code><span></span></a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">1</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>In the beginning, we had:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> InputIterator, <span class="kw">class</span> OutputIterator<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="kw">constexpr</span> OutputIterator copy<span class="op">(</span>InputIterator first, InputIterator last,</span>
<span id="cb1-3"><a href="#cb1-3"></a>                                OutputIterator result<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>And then, in C++20, we added Concepts and Ranges - which came with a whole library of <code class="sourceCode cpp"><span class="kw">concept</span></code>s for the standard library, in particular for iterators and ragnes. This included a concept <code class="sourceCode cpp">input_iterator</code> and <code class="sourceCode cpp">output_iterator</code>. We also added new rangified versions of all the algorithms, constrained using these concepts.</p>
<p>The new overloads look like this:</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span><span class="op">&lt;</span>input_iterator I, sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S, weakly_incrementable O<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">requires</span> indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>I, O<span class="op">&gt;</span> ranges<span class="op">::</span>copy<span class="op">(</span>I first, S last, O result<span class="op">)</span>;</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">template</span><span class="op">&lt;</span>input_range R, weakly_incrementable O<span class="op">&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="kw">requires</span> indirectly_copyable<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;</span>, O<span class="op">&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>borrowed_iterator_t<span class="op">&lt;</span>R<span class="op">&gt;</span>, O<span class="op">&gt;</span> ranges<span class="op">::</span>copy<span class="op">(</span>R<span class="op">&amp;&amp;</span> r, O result<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>The crux of this paper is that <code class="sourceCode cpp">std<span class="op">::</span>copy</code> takes an <code class="sourceCode cpp">OutputIterator</code> (even if the name of this parameter does nothing), but <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>copy</code> does not have anything named <code class="sourceCode cpp">output_iterator</code> in this constraints at all. That just seems wrong. Output iterator is a thing that users understand, but “weakly incrementable” and “indirectly copyable,” while reasonable names for the functionality they require, are not particularly well known and are not really useful when they show up in diagnostics.</p>
<p>We should do better here.</p>
<h2 data-number="1.1" id="output-concept-hierarchy"><span class="header-section-number">1.1</span> Output concept hierarchy<a href="#output-concept-hierarchy" class="self-link"></a></h2>
<p>Let me start with what all the relevant <code class="sourceCode cpp"><span class="kw">concept</span></code>s actually are:</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">concept</span> weakly_incrementable <span class="op">=</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    movable<span class="op">&lt;</span>I<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="kw">requires</span><span class="op">(</span>I i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>      <span class="kw">typename</span> iter_difference_t<span class="op">&lt;</span>I<span class="op">&gt;</span>;</span>
<span id="cb3-6"><a href="#cb3-6"></a>      <span class="kw">requires</span> <em>is-signed-integer-like</em><span class="op">&lt;</span>iter_difference_t<span class="op">&lt;</span>I<span class="op">&gt;&gt;</span>;</span>
<span id="cb3-7"><a href="#cb3-7"></a>      <span class="op">{</span> <span class="op">++</span>i <span class="op">}</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span>I<span class="op">&amp;&gt;</span>;   <span class="co">// not required to be equality-preserving</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>      i<span class="op">++</span>;                      <span class="co">// not required to be equality-preserving</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="op">}</span>;</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I<span class="op">&gt;</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>  <span class="kw">concept</span> input_or_output_iterator <span class="op">=</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span class="kw">requires</span><span class="op">(</span>I i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>      <span class="op">{</span> <span class="op">*</span>i <span class="op">}</span> <span class="op">-&gt;</span> <em>can-reference</em>;</span>
<span id="cb3-15"><a href="#cb3-15"></a>    <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    weakly_incrementable<span class="op">&lt;</span>I<span class="op">&gt;</span>;</span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Out, <span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>  <span class="kw">concept</span> indirectly_writable <span class="op">=</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="kw">requires</span><span class="op">(</span>Out<span class="op">&amp;&amp;</span> o, T<span class="op">&amp;&amp;</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>      <span class="op">*</span>o <span class="op">=</span> std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span>;  <span class="co">// not required to be equality-preserving</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>      <span class="op">*</span>std<span class="op">::</span>forward<span class="op">&lt;</span>Out<span class="op">&gt;(</span>o<span class="op">)</span> <span class="op">=</span> std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span>;   <span class="co">// not required to be equality-preserving</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>      <span class="kw">const_cast</span><span class="op">&lt;</span><span class="kw">const</span> iter_reference_t<span class="op">&lt;</span>Out<span class="op">&gt;&amp;&amp;&gt;(*</span>o<span class="op">)</span> <span class="op">=</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>        std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span>;     <span class="co">// not required to be equality-preserving</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>      <span class="kw">const_cast</span><span class="op">&lt;</span><span class="kw">const</span> iter_reference_t<span class="op">&lt;</span>Out<span class="op">&gt;&amp;&amp;&gt;(*</span>std<span class="op">::</span>forward<span class="op">&lt;</span>Out<span class="op">&gt;(</span>o<span class="op">))</span> <span class="op">=</span></span>
<span id="cb3-26"><a href="#cb3-26"></a>        std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span>;     <span class="co">// not required to be equality-preserving</span></span>
<span id="cb3-27"><a href="#cb3-27"></a>    <span class="op">}</span>;</span>
<span id="cb3-28"><a href="#cb3-28"></a></span>
<span id="cb3-29"><a href="#cb3-29"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> In, <span class="kw">class</span> Out<span class="op">&gt;</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>  <span class="kw">concept</span> indirectly_copyable <span class="op">=</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>    indirectly_readable<span class="op">&lt;</span>In<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb3-32"><a href="#cb3-32"></a>    indirectly_writable<span class="op">&lt;</span>Out, iter_reference_t<span class="op">&lt;</span>In<span class="op">&gt;&gt;</span>;</span>
<span id="cb3-33"><a href="#cb3-33"></a></span>
<span id="cb3-34"><a href="#cb3-34"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I, <span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb3-35"><a href="#cb3-35"></a>  <span class="kw">concept</span> output_iterator <span class="op">=</span></span>
<span id="cb3-36"><a href="#cb3-36"></a>    input_or_output_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>    indirectly_writable<span class="op">&lt;</span>I, T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb3-38"><a href="#cb3-38"></a>    <span class="kw">requires</span><span class="op">(</span>I i, T<span class="op">&amp;&amp;</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-39"><a href="#cb3-39"></a>      <span class="op">*</span>i<span class="op">++</span> <span class="op">=</span> std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span>;        <span class="co">// not required to be equality-preserving</span></span>
<span id="cb3-40"><a href="#cb3-40"></a>    <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>And let me present two possible specifications for <code class="sourceCode cpp">ranges<span class="op">::</span>copy</code>.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>In C++20</strong>
</div></th>
<th><div style="text-align:center">
<strong>Hypothetical</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_iterator I,</span>
<span id="cb4-2"><a href="#cb4-2"></a>          sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S,</span>
<span id="cb4-3"><a href="#cb4-3"></a>          weakly_incrementable O<span class="op">&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">requires</span> indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>ranges<span class="op">::</span>copy<span class="op">(</span>I first, S last, O result<span class="op">)</span>;</span></code></pre></div></td>
<td><div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_iterator I,</span>
<span id="cb5-2"><a href="#cb5-2"></a>          sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S,</span>
<span id="cb5-3"><a href="#cb5-3"></a>          output_iterator<span class="op">&lt;</span>iter_reference_t<span class="op">&lt;</span>I<span class="op">&gt;&gt;</span> O<span class="op">&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>ranges<span class="op">::</span>copy<span class="op">(</span>I first, S last, O result<span class="op">)</span>;</span></code></pre></div></td>
</tr>
</tbody>
</table>
<p>Now, the one on the right actually says <code class="sourceCode cpp">output_iterator</code>, which I think is extremely valuable. But are the requirements any different?</p>
<p>In C++20, we require:</p>
<ul>
<li><code class="sourceCode cpp">O</code> is <code class="sourceCode cpp">weakly_incrementable</code></li>
<li><code class="sourceCode cpp">indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></code>, which means <code class="sourceCode cpp">I</code> is <code class="sourceCode cpp">indirectly_readable</code> (which is already required by <code class="sourceCode cpp">input_iterator</code>) and <code class="sourceCode cpp">O</code> is <code class="sourceCode cpp">indirectly_writable<span class="op">&lt;</span>iter_reference_t<span class="op">&lt;</span>I<span class="op">&gt;&gt;</span></code></li>
</ul>
<p>The hypothetical version requires <code class="sourceCode cpp">output_iterator<span class="op">&lt;</span>iter_reference_t<span class="op">&lt;</span>I<span class="op">&gt;&gt;</span></code>, which breaks down into:</p>
<ul>
<li><code class="sourceCode cpp">input_or_output_iterator</code>
<ul>
<li>dereferencable (already required by <code class="sourceCode cpp">indirectly_writable</code>, since you have to have <code class="sourceCode cpp"><span class="op">*</span>o <span class="op">=</span> expr;</code> work)</li>
<li><code class="sourceCode cpp">weakly_incrementable</code> (explicitly required in C++20)</li>
</ul></li>
<li><code class="sourceCode cpp">indirectly_writable</code> (explicitly required in C++20)</li>
<li><code class="sourceCode cpp"><span class="op">*</span>i<span class="op">++</span> <span class="op">=</span> t;</code> (<em>not</em> required in C++20)</li>
</ul>
<p>Basically: the two formulations have identical requirements <em>except</em> that today’s specification of <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>copy</code> does not require <code class="sourceCode cpp"><span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> t;</code> to work, while my hypothetical one does. Generally speaking, this is a good thing. It may be syntactically nice to write <code class="sourceCode cpp"><span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> t;</code> instead of <code class="sourceCode cpp"><span class="op">*</span>out <span class="op">=</span> t; <span class="op">++</span>out;</code>, but it’s not actually necessary to solve any problems. This makes <code class="sourceCode cpp">ranges<span class="op">::</span>copy</code> more usable, but it means that our most output-y of output algorithms doesn’t use <code class="sourceCode cpp">output_iterator</code>.</p>
<h2 data-number="1.2" id="does-anything-in-ranges-use-output_iterator"><span class="header-section-number">1.2</span> Does anything in Ranges use <code class="sourceCode cpp">output_iterator</code>?<a href="#does-anything-in-ranges-use-output_iterator" class="self-link"></a></h2>
<p>I thought it’d be useful to go through everything in <code class="sourceCode cpp"><span class="op">&lt;</span>algorithm<span class="op">&gt;</span></code> that uses an output iterator (if not an <code class="sourceCode cpp">output_iterator</code>) and catalogue all the kinds of constraints we have on them. There are many different approaches (in the below, <code class="sourceCode cpp">X</code> just denotes some type, <code class="sourceCode cpp">O</code> is our output iterator, <code class="sourceCode cpp">I</code> is the corresponding input iterator):</p>
<ul>
<li><code class="sourceCode cpp">weakly_incrementable<span class="op">&lt;</span>O<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></code>: <code class="sourceCode cpp">ranges<span class="op">::</span>copy</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>copy_n</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>copy_if</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>remove_copy</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>remove_copy_if</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>unique_copy</code> (although this one has a disjunction that might include other constraints), <code class="sourceCode cpp">ranges<span class="op">::</span>reverse_copy</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>rotate_copy</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>partition_copy</code></li>
<li><code class="sourceCode cpp">weakly_incrementable<span class="op">&lt;</span>O<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> indirectly_movable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></code>: <code class="sourceCode cpp">ranges<span class="op">::</span>move</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>move_if</code></li>
<li><code class="sourceCode cpp">weakly_incrementable<span class="op">&lt;</span>O<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> indirectly_writable<span class="op">&lt;</span>O, X<span class="op">&gt;</span></code>: <code class="sourceCode cpp">ranges<span class="op">::</span>transform</code></li>
<li><code class="sourceCode cpp">output_iterator<span class="op">&lt;</span>O, X<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></code>: <code class="sourceCode cpp">ranges<span class="op">::</span>replace_copy</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>replace_copy_if</code></li>
<li><code class="sourceCode cpp">output_iterator<span class="op">&lt;</span>O, X<span class="op">&gt;</span></code>: <code class="sourceCode cpp">ranges<span class="op">::</span>fill</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>fill_n</code></li>
<li><code class="sourceCode cpp">input_or_output_iterator<span class="op">&lt;</span>O<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> indirectly_writable<span class="op">&lt;</span>O, X<span class="op">&gt;</span></code>: <code class="sourceCode cpp">ranges<span class="op">::</span>generate</code> (see below), <code class="sourceCode cpp">ranges<span class="op">::</span>generate_n</code></li>
<li><code class="sourceCode cpp">weakly_incrementable<span class="op">&lt;</span>O<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> mergeable<span class="op">&lt;</span>I1, I2, O, X, X<span class="op">&gt;</span></code> (technically <code class="sourceCode cpp">mergeable</code>’s requirements on <code class="sourceCode cpp">O</code> are just <code class="sourceCode cpp">indirectly_copyable</code>, but putting it separately for completeness): <code class="sourceCode cpp">ranges<span class="op">::</span>merge</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>set_union</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>set_intersection</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>set_difference</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>set_symmetric_difference</code></li>
</ul>
<p>Put differently, there are only 4 algorithms that use <code class="sourceCode cpp">output_iterator</code>: <code class="sourceCode cpp">ranges<span class="op">::</span>replace_copy</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>replace_copy_if</code>, <code class="sourceCode cpp">ranges<span class="op">::</span>fill</code>, and <code class="sourceCode cpp">ranges<span class="op">::</span>fill_n</code>. However, there are 2 algorithms that use <code class="sourceCode cpp">output_range<span class="op">&lt;</span>R<span class="op">&gt;</span></code> (which requires its iterator to be an <code class="sourceCode cpp">output_iterator</code>): <code class="sourceCode cpp">ranges<span class="op">::</span>fill</code> and <code class="sourceCode cpp">ranges<span class="op">::</span>generate</code>. The former makes sense, but the latter’s iterator/sentinel overload doesn’t require <code class="sourceCode cpp">output_iterator</code>. This means that <code class="sourceCode cpp">ranges<span class="op">::</span>generate<span class="op">(</span>r, f<span class="op">)</span></code> requires <code class="sourceCode cpp"><span class="op">*</span>r<span class="op">.</span>begin<span class="op">()++</span> <span class="op">=</span> f<span class="op">()</span>;</code> to work, but <code class="sourceCode cpp">ranges<span class="op">::</span>generate<span class="op">(</span>r<span class="op">.</span>begin<span class="op">()</span>, r<span class="op">.</span>end<span class="op">()</span>, f<span class="op">)</span></code> does not. That just seems inconsistent.</p>
<p>Now, <code class="sourceCode cpp">indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></code> is really two constraints put together. It requires that <code class="sourceCode cpp">I</code> is an <code class="sourceCode cpp">input_iterator</code> and that <code class="sourceCode cpp">O</code> is <code class="sourceCode cpp">indirectly_writable<span class="op">&lt;</span>iter_reference_t<span class="op">&lt;</span>I<span class="op">&gt;&gt;</span></code>. This constraint is by far the most common formulation for output ranges. But it’s a bit redundant, since all of these algorithms already separately require <code class="sourceCode cpp">input_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code>. The only new requirement that <code class="sourceCode cpp">indirectly_copyable</code> brings in is the <code class="sourceCode cpp">indirectly_writable</code> one. What I mean is that instead of:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">template</span><span class="op">&lt;</span>input_iterator I, sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S, weakly_incrementable O<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="kw">requires</span> indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>I, O<span class="op">&gt;</span> ranges<span class="op">::</span>copy<span class="op">(</span>I first, S last, O result<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>we could get the same exact same requirements (no more, no less) by instead writing:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span><span class="op">&lt;</span>input_iterator I, sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S, weakly_incrementable O<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="kw">requires</span> indirectly_writable<span class="op">&lt;</span>O, iter_reference_t<span class="op">&lt;</span>I<span class="op">&gt;&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>I, O<span class="op">&gt;</span> ranges<span class="op">::</span>copy<span class="op">(</span>I first, S last, O result<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>The same idea could hold for the algorithms requiring <code class="sourceCode cpp">indirectly_movable</code> (replaced with a different kind of <code class="sourceCode cpp">indirectly_writable</code> constraint).</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="proposal-a-weaker-output-iterator"><span class="header-section-number">2</span> Proposal: A Weaker Output Iterator<a href="#proposal-a-weaker-output-iterator" class="self-link"></a></h1>
<p>We can’t remove the <code class="sourceCode cpp"><span class="op">*</span>out<span class="op">++=</span> r;</code> requirement from <code class="sourceCode cpp">output_iterator</code>. It’s 2022, surely somebody has written some C++20 code by now, and might rely on that part of the <code class="sourceCode cpp"><span class="kw">concept</span></code>. Similarly, we cannot add the <code class="sourceCode cpp"><span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> r;</code> requirement to all the algorithms which take an output iterator, since likewise somebody could have written C++20 code that passes in a type into these algorithms that meets every requirement but that one, and this added constraint would break their code.</p>
<p>This paper does not propose either adding or removing any requirements to algorithms.</p>
<p>Let me repeat in different words: this paper does not propose anything that would change any behavior of C++20 code.</p>
<p>Instead, the problem this paper seeks to solve is that we have all these algorithms which require an output iterator but don’t actually use those terms anywhere, which just seems wrong, and leads to diagnostics that are just worse than they could be. We can do better by introducing a new, weaker output iterator concept:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I, <span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="kw">concept</span> weak_output_iterator <span class="op">=</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    input_or_output_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    indirectly_writable<span class="op">&lt;</span>I, T<span class="op">&gt;</span>;</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I, <span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="kw">concept</span> output_iterator <span class="op">=</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    weak_output_iterator<span class="op">&lt;</span>I, T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="kw">requires</span><span class="op">(</span>I i, T<span class="op">&amp;&amp;</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>      <span class="op">*</span>i<span class="op">++</span> <span class="op">=</span> std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span>;        <span class="co">// not required to be equality-preserving</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>We can discuss whether this should be exposition-only or not, but it seems like it shouldn’t be.</p>
<p>With such a concept, we can go through all the algorithms and respecify them to just use it. For example, <code class="sourceCode cpp">ranges<span class="op">::</span>copy</code> becomes:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>In C++20</strong>
</div></th>
<th><div style="text-align:center">
<strong>Proposed</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_iterator I,</span>
<span id="cb9-2"><a href="#cb9-2"></a>          sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S,</span>
<span id="cb9-3"><a href="#cb9-3"></a>          weakly_incrementable O<span class="op">&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="kw">requires</span> indirectly_copyable<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>ranges<span class="op">::</span>copy<span class="op">(</span>I first, S last, O result<span class="op">)</span>;</span></code></pre></div></td>
<td><div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_iterator I,</span>
<span id="cb10-2"><a href="#cb10-2"></a>          sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S,</span>
<span id="cb10-3"><a href="#cb10-3"></a>          weak_output_iterator<span class="op">&lt;</span>iter_reference_t<span class="op">&lt;</span>I<span class="op">&gt;&gt;</span> O<span class="op">&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="kw">constexpr</span> ranges<span class="op">::</span>copy_result<span class="op">&lt;</span>I, O<span class="op">&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>ranges<span class="op">::</span>copy<span class="op">(</span>I first, S last, O result<span class="op">)</span>;</span></code></pre></div></td>
</tr>
</tbody>
</table>
<p>Unlike my hypothetical spelling earlier, these two now have identical requirements.</p>
<h2 data-number="2.1" id="wording"><span class="header-section-number">2.1</span> Wording<a href="#wording" class="self-link"></a></h2>
<p>Change <span>23.2 <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb11"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb11-1"><a href="#cb11-1"></a>namespace std {</span>
<span id="cb11-2"><a href="#cb11-2"></a>  // ...</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a>  // [iterator.concept.output], concept output_iterator</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="va">+ template&lt;class I, class T&gt;</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="va">+   concept weak_output_iterator = <em>see below</em>;</span></span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a>  template&lt;class I, class T&gt;</span>
<span id="cb11-9"><a href="#cb11-9"></a>    concept output_iterator = see below;</span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a>  // ...</span>
<span id="cb11-12"><a href="#cb11-12"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Change <span>23.3.4.10 <a href="https://wg21.link/iterator.concept.output">[iterator.concept.output]</a></span> <span class="ednote" style="color: #0000ff">[ Editor&#39;s note: The semantic effects are specific to <code class="sourceCode default">output_iterator</code>, not <code class="sourceCode default">weak_output_iterator</code> ]</span>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_1" id="pnum_1">1</a></span> The <span class="addu"><code class="sourceCode cpp">weak_output_iterator</code> and</span> <code class="sourceCode cpp">output_iterator</code> <span class="rm" style="color: #bf0303"><del>concept defines</del></span> <span class="addu">concepts define</span> requirements for a type that can be used to write values (from the requirement for <code class="sourceCode cpp">indirectly_writable</code> ([iterator.concept.writable])) and which can be both pre- and post-incremented. [<em>Note 1</em>: Output iterators are not required to model <code class="sourceCode cpp">equality_comparable</code>. — <em>end note</em>]</p>
<div>
<div class="sourceCode" id="cb12"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb12-1"><a href="#cb12-1"></a><span class="va">+ template&lt;class I, class T&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="va">+   concept weak_output_iterator =</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="va">+     input_or_output_iterator&lt;I&gt; &amp;&amp;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="va">+     indirectly_writable&lt;I, T&gt;;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a>  template&lt;class I, class T&gt;</span>
<span id="cb12-7"><a href="#cb12-7"></a>    concept output_iterator =</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="st">-     input_or_output_iterator&lt;I&gt; &amp;&amp;</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="st">-     indirectly_writable&lt;I, T&gt; &amp;&amp;</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="va">+     weak_output_iterator&lt;I, T&gt; &amp;&amp;</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>      requires(I i, T&amp;&amp; t) {</span>
<span id="cb12-12"><a href="#cb12-12"></a>        *i++ = std::forward&lt;T&gt;(t);        // not required to be equality-preserving</span>
<span id="cb12-13"><a href="#cb12-13"></a>      };</span></code></pre></div>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_2" id="pnum_2">2</a></span> Let <code class="sourceCode cpp">E</code> be an expression such that <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">((</span>E<span class="op">))</span></code> is <code class="sourceCode cpp">T</code>, and let <code class="sourceCode cpp">i</code> be a dereferenceable object of type <code class="sourceCode cpp">I</code>. <code class="sourceCode cpp">I</code> and <code class="sourceCode cpp">T</code> model <code class="sourceCode cpp">output_iterator<span class="op">&lt;</span>I, T<span class="op">&gt;</span></code> only if <code class="sourceCode cpp"><span class="op">*</span>i<span class="op">++</span> <span class="op">=</span> E;</code> has effects equivalent to: <code class="sourceCode cpp"><span class="op">*</span>i <span class="op">=</span> E; <span class="op">++</span>i;</code></p>
</blockquote>
<p>Change all the constraints to use <code class="sourceCode cpp">weak_output_iterator</code> in the algorithms. The wording diff here only includes the synopsis, the same changes need to be made in these algorithms’ corresponding definition too. These are all in <span>25.4 <a href="https://wg21.link/algorithm.syn">[algorithm.syn]</a></span>, broken up by algorithm for convenience:</p>
<h3 data-number="2.1.1" id="rangescopy"><span class="header-section-number">2.1.1</span> <code class="sourceCode cpp">ranges<span class="op">::</span>copy</code><a href="#rangescopy" class="self-link"></a></h3>
<blockquote>
<div>
<div class="sourceCode" id="cb13"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb13-1"><a href="#cb13-1"></a>namespace std::ranges {</span>
<span id="cb13-2"><a href="#cb13-2"></a>    template&lt;class I, class O&gt;</span>
<span id="cb13-3"><a href="#cb13-3"></a>      using copy_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="st">-   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="st">-     requires indirectly_copyable&lt;I, O&gt;</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="va">+   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weak_output_iterator&lt;iter_reference_t&lt;I&gt;&gt; O&gt;</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>      constexpr copy_result&lt;I, O&gt;</span>
<span id="cb13-9"><a href="#cb13-9"></a>        copy(I first, S last, O result);</span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="st">-   template&lt;input_range R, weakly_incrementable O&gt;</span></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="st">-     requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="va">+   template&lt;input_range R, weak_output_iterator&lt;range_reference_t&lt;R&gt;&gt; O&gt;</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>      constexpr copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb13-15"><a href="#cb13-15"></a>        copy(R&amp;&amp; r, O result);</span>
<span id="cb13-16"><a href="#cb13-16"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="2.1.2" id="rangescopy_n"><span class="header-section-number">2.1.2</span> <code class="sourceCode cpp">ranges<span class="op">::</span>copy_n</code><a href="#rangescopy_n" class="self-link"></a></h3>
<blockquote>
<div>
<div class="sourceCode" id="cb14"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb14-1"><a href="#cb14-1"></a>namespace std::ranges {</span>
<span id="cb14-2"><a href="#cb14-2"></a>    template&lt;class I, class O&gt;</span>
<span id="cb14-3"><a href="#cb14-3"></a>      using copy_n_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="st">-   template&lt;input_iterator I, weakly_incrementable O&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="st">-     requires indirectly_copyable&lt;I, O&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="va">+   template&lt;input_iterator I, weak_output_iterator&lt;iter_reference_t&lt;I&gt;&gt; O&gt;</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>      constexpr copy_n_result&lt;I, O&gt;</span>
<span id="cb14-9"><a href="#cb14-9"></a>        copy_n(I first, iter_difference_t&lt;I&gt; n, O result);</span>
<span id="cb14-10"><a href="#cb14-10"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="2.1.3" id="rangescopy_if"><span class="header-section-number">2.1.3</span> <code class="sourceCode cpp">ranges<span class="op">::</span>copy_if</code><a href="#rangescopy_if" class="self-link"></a></h3>
<blockquote>
<div>
<div class="sourceCode" id="cb15"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb15-1"><a href="#cb15-1"></a>namespace std::ranges {</span>
<span id="cb15-2"><a href="#cb15-2"></a>    template&lt;class I, class O&gt;</span>
<span id="cb15-3"><a href="#cb15-3"></a>      using copy_if_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb15-4"><a href="#cb15-4"></a></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="st">-   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="va">+   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weak_output_iterator&lt;iter_reference_t&lt;I&gt;&gt; O,</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>             class Proj = identity,</span>
<span id="cb15-8"><a href="#cb15-8"></a>             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="st">-     requires indirectly_copyable&lt;I, O&gt;</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>      constexpr copy_if_result&lt;I, O&gt;</span>
<span id="cb15-11"><a href="#cb15-11"></a>        copy_if(I first, S last, O result, Pred pred, Proj proj = {});</span>
<span id="cb15-12"><a href="#cb15-12"></a></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="st">-   template&lt;input_range R, weakly_incrementable O,</span></span>
<span id="cb15-14"><a href="#cb15-14"></a><span class="va">+   template&lt;input_range R, weak_output_iterator&lt;range_reference_t&lt;R&gt;&gt; O,</span></span>
<span id="cb15-15"><a href="#cb15-15"></a>             class Proj = identity,</span>
<span id="cb15-16"><a href="#cb15-16"></a>             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="st">-     requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>      constexpr copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb15-19"><a href="#cb15-19"></a>        copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});</span>
<span id="cb15-20"><a href="#cb15-20"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="2.1.4" id="rangesmove"><span class="header-section-number">2.1.4</span> <code class="sourceCode cpp">ranges<span class="op">::</span>move</code><a href="#rangesmove" class="self-link"></a></h3>
<blockquote>
<div>
<div class="sourceCode" id="cb16"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb16-1"><a href="#cb16-1"></a>namespace std::ranges {</span>
<span id="cb16-2"><a href="#cb16-2"></a>    template&lt;class I, class O&gt;</span>
<span id="cb16-3"><a href="#cb16-3"></a>      using move_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="st">-   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="st">-     requires indirectly_movable&lt;I, O&gt;</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="va">+   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weak_output_iterator&lt;iter_rvalue_reference_t&lt;I&gt;&gt; O&gt;</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>      constexpr move_result&lt;I, O&gt;</span>
<span id="cb16-9"><a href="#cb16-9"></a>        move(I first, S last, O result);</span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="st">-   template&lt;input_range R, weakly_incrementable O&gt;</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="st">-     requires indirectly_movable&lt;iterator_t&lt;R&gt;, O&gt;</span></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="va">+   template&lt;input_range, weak_output_iterator&lt;range_rvalue_reference_t&lt;R&gt;&gt; O&gt;</span></span>
<span id="cb16-14"><a href="#cb16-14"></a>      constexpr move_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb16-15"><a href="#cb16-15"></a>        move(R&amp;&amp; r, O result);</span>
<span id="cb16-16"><a href="#cb16-16"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="2.1.5" id="rangestransform"><span class="header-section-number">2.1.5</span> <code class="sourceCode cpp">ranges<span class="op">::</span>transform</code><a href="#rangestransform" class="self-link"></a></h3>
<p><span class="draftnote" style="color: #01796F">[ Drafting note: Here, I’m using <code class="sourceCode cpp"><span class="kw">class</span> O</code> and having a trailing <code class="sourceCode cpp"><span class="kw">requires</span> weak_output_iterator<span class="op">&lt;</span>O, T<span class="op">&gt;</span></code> because the relevant type <code class="sourceCode cpp">T</code> here is based on <code class="sourceCode cpp">Proj</code>, which is declared after <code class="sourceCode cpp">O</code>. ]</span></p>
<blockquote>
<div>
<div class="sourceCode" id="cb17"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb17-1"><a href="#cb17-1"></a>namespace std::ranges {</span>
<span id="cb17-2"><a href="#cb17-2"></a>    template&lt;class I, class O&gt;</span>
<span id="cb17-3"><a href="#cb17-3"></a>      using unary_transform_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="st">-   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="va">+   template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class O,</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>             copy_constructible F, class Proj = identity&gt;</span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="st">-     requires indirectly_writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I, Proj&gt;&gt;&gt;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="va">+     requires weak_output_iterator&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I, Proj&gt;&gt;&gt;</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>      constexpr unary_transform_result&lt;I, O&gt;</span>
<span id="cb17-11"><a href="#cb17-11"></a>        transform(I first1, S last1, O result, F op, Proj proj = {});</span>
<span id="cb17-12"><a href="#cb17-12"></a></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="st">-   template&lt;input_range R, weakly_incrementable O, copy_constructible F,</span></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="va">+   template&lt;input_range R, class O, copy_constructible F,</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>             class Proj = identity&gt;</span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="st">-     requires indirectly_writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;</span></span>
<span id="cb17-17"><a href="#cb17-17"></a><span class="va">+     requires weak_output_iterator&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>      constexpr unary_transform_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb17-19"><a href="#cb17-19"></a>        transform(R&amp;&amp; r, O result, F op, Proj proj = {});</span>
<span id="cb17-20"><a href="#cb17-20"></a></span>
<span id="cb17-21"><a href="#cb17-21"></a>    template&lt;class I1, class I2, class O&gt;</span>
<span id="cb17-22"><a href="#cb17-22"></a>      using binary_transform_result = in_in_out_result&lt;I1, I2, O&gt;;</span>
<span id="cb17-23"><a href="#cb17-23"></a></span>
<span id="cb17-24"><a href="#cb17-24"></a>    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb17-25"><a href="#cb17-25"></a><span class="st">-            weakly_incrementable O, copy_constructible F, class Proj1 = identity,</span></span>
<span id="cb17-26"><a href="#cb17-26"></a><span class="va">+            class O, copy_constructible F, class Proj1 = identity,</span></span>
<span id="cb17-27"><a href="#cb17-27"></a>             class Proj2 = identity&gt;</span>
<span id="cb17-28"><a href="#cb17-28"></a><span class="st">-     requires indirectly_writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I1, Proj1&gt;,</span></span>
<span id="cb17-29"><a href="#cb17-29"></a><span class="va">+     requires weak_output_iterator&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I1, Proj1&gt;,</span></span>
<span id="cb17-30"><a href="#cb17-30"></a>                                             projected&lt;I2, Proj2&gt;&gt;&gt;</span>
<span id="cb17-31"><a href="#cb17-31"></a>      constexpr binary_transform_result&lt;I1, I2, O&gt;</span>
<span id="cb17-32"><a href="#cb17-32"></a>        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,</span>
<span id="cb17-33"><a href="#cb17-33"></a>                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb17-34"><a href="#cb17-34"></a></span>
<span id="cb17-35"><a href="#cb17-35"></a><span class="st">-   template&lt;input_range R1, input_range R2, weakly_incrementable O,</span></span>
<span id="cb17-36"><a href="#cb17-36"></a><span class="va">+   template&lt;input_range R1, input_range R2, class O,</span></span>
<span id="cb17-37"><a href="#cb17-37"></a>             copy_constructible F, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb17-38"><a href="#cb17-38"></a><span class="st">-     requires indirectly_writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,</span></span>
<span id="cb17-39"><a href="#cb17-39"></a><span class="va">+     requires weak_output_iterator&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,</span></span>
<span id="cb17-40"><a href="#cb17-40"></a>                                             projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;&gt;</span>
<span id="cb17-41"><a href="#cb17-41"></a>      constexpr binary_transform_result&lt;borrowed_iterator_t&lt;R1&gt;, borrowed_iterator_t&lt;R2&gt;, O&gt;</span>
<span id="cb17-42"><a href="#cb17-42"></a>        transform(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,</span>
<span id="cb17-43"><a href="#cb17-43"></a>                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb17-44"><a href="#cb17-44"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="2.1.6" id="rangesreplace_copy"><span class="header-section-number">2.1.6</span> <code class="sourceCode cpp">ranges<span class="op">::</span>replace_copy</code><a href="#rangesreplace_copy" class="self-link"></a></h3>
<p><span class="draftnote" style="color: #01796F">[ Drafting note: These already require <code class="sourceCode cpp">output_iterator</code> in one spot, so can require <code class="sourceCode cpp">output_iterator</code> in another too. This makes it more clear that it’s an output iterator for multiple types. ]</span></p>
<blockquote>
<div>
<div class="sourceCode" id="cb18"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb18-1"><a href="#cb18-1"></a>namespace std::ranges {</span>
<span id="cb18-2"><a href="#cb18-2"></a>    template&lt;class I, class O&gt;</span>
<span id="cb18-3"><a href="#cb18-3"></a>      using replace_copy_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a>    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T1, class T2,</span>
<span id="cb18-6"><a href="#cb18-6"></a>             output_iterator&lt;const T2&amp;&gt; O, class Proj = identity&gt;</span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="st">-     requires indirectly_copyable&lt;I, O&gt; &amp;&amp;</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="va">+     requires output_iterator&lt;O, iter_reference_t&lt;I&gt;&gt;</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>               indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;</span>
<span id="cb18-10"><a href="#cb18-10"></a>      constexpr replace_copy_result&lt;I, O&gt;</span>
<span id="cb18-11"><a href="#cb18-11"></a>        replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,</span>
<span id="cb18-12"><a href="#cb18-12"></a>                     Proj proj = {});</span>
<span id="cb18-13"><a href="#cb18-13"></a>    template&lt;input_range R, class T1, class T2, output_iterator&lt;const T2&amp;&gt; O,</span>
<span id="cb18-14"><a href="#cb18-14"></a>             class Proj = identity&gt;</span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="st">-     requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;</span></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="va">+     requires output_iterator&lt;O, range_reference_t&lt;R&gt;&gt; &amp;&amp;</span></span>
<span id="cb18-17"><a href="#cb18-17"></a>               indirect_binary_predicate&lt;ranges::equal_to,</span>
<span id="cb18-18"><a href="#cb18-18"></a>                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;</span>
<span id="cb18-19"><a href="#cb18-19"></a>      constexpr replace_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb18-20"><a href="#cb18-20"></a>        replace_copy(R&amp;&amp; r, O result, const T1&amp; old_value, const T2&amp; new_value,</span>
<span id="cb18-21"><a href="#cb18-21"></a>                     Proj proj = {});</span>
<span id="cb18-22"><a href="#cb18-22"></a></span>
<span id="cb18-23"><a href="#cb18-23"></a>    template&lt;class I, class O&gt;</span>
<span id="cb18-24"><a href="#cb18-24"></a>      using replace_copy_if_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb18-25"><a href="#cb18-25"></a></span>
<span id="cb18-26"><a href="#cb18-26"></a>    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, output_iterator&lt;const T&amp;&gt; O,</span>
<span id="cb18-27"><a href="#cb18-27"></a>             class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</span>
<span id="cb18-28"><a href="#cb18-28"></a><span class="st">-     requires indirectly_copyable&lt;I, O&gt;</span></span>
<span id="cb18-29"><a href="#cb18-29"></a><span class="va">+     requires output_iterator&lt;O, iter_reference_t&lt;I&gt;&gt;</span></span>
<span id="cb18-30"><a href="#cb18-30"></a>      constexpr replace_copy_if_result&lt;I, O&gt;</span>
<span id="cb18-31"><a href="#cb18-31"></a>        replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,</span>
<span id="cb18-32"><a href="#cb18-32"></a>                        Proj proj = {});</span>
<span id="cb18-33"><a href="#cb18-33"></a>    template&lt;input_range R, class T, output_iterator&lt;const T&amp;&gt; O, class Proj = identity,</span>
<span id="cb18-34"><a href="#cb18-34"></a>             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</span>
<span id="cb18-35"><a href="#cb18-35"></a><span class="st">-     requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;</span></span>
<span id="cb18-36"><a href="#cb18-36"></a><span class="va">+     requires output_iterator&lt;O, range_reference_t&lt;R&gt;&gt; &amp;&amp;</span></span>
<span id="cb18-37"><a href="#cb18-37"></a>      constexpr replace_copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb18-38"><a href="#cb18-38"></a>        replace_copy_if(R&amp;&amp; r, O result, Pred pred, const T&amp; new_value,</span>
<span id="cb18-39"><a href="#cb18-39"></a>                        Proj proj = {});</span>
<span id="cb18-40"><a href="#cb18-40"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="2.1.7" id="rangesfill"><span class="header-section-number">2.1.7</span> <code class="sourceCode cpp">ranges<span class="op">::</span>fill</code><a href="#rangesfill" class="self-link"></a></h3>
<p>No changes necessary, already requires <code class="sourceCode cpp">output_iterator</code>.</p>
<h3 data-number="2.1.8" id="rangesgenerate"><span class="header-section-number">2.1.8</span> <code class="sourceCode cpp">ranges<span class="op">::</span>generate</code><a href="#rangesgenerate" class="self-link"></a></h3>
<p>This is the weird one. The range overload of <code class="sourceCode cpp">generate</code> requires <code class="sourceCode cpp">output_range</code>, which requires <code class="sourceCode cpp">output_iterator</code>, which requires <code class="sourceCode cpp"><span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> t;</code> to work. But the iterator/sentinel overload does not require <code class="sourceCode cpp">output_iterator</code>, so it does not. This doesn’t make much sense to me - these two really should line up. I don’t know if we can strengthen one, but I also don’t want to weaken the other (also <code class="sourceCode cpp">output_range</code> is our only range-based output concept, and I don’t want to add a <code class="sourceCode cpp">weak_output_range</code>).</p>
<p>This is what it would look like if we strengthened the iterator overloads of <code class="sourceCode cpp">generate</code> and <code class="sourceCode cpp">generate_n</code>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb19"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb19-1"><a href="#cb19-1"></a>namespace std::ranges {</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="st">-   template&lt;input_or_output_iterator O,</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="va">+   template&lt;class O,</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>             sentinel_for&lt;O&gt; S, copy_constructible F&gt;</span>
<span id="cb19-5"><a href="#cb19-5"></a>      requires invocable&lt;F&amp;&gt; &amp;&amp;</span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="st">-              indirectly_writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="va">+              output_iterator&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>      constexpr O generate(O first, S last, F gen);</span>
<span id="cb19-9"><a href="#cb19-9"></a></span>
<span id="cb19-10"><a href="#cb19-10"></a>    template&lt;class R, copy_constructible F&gt;</span>
<span id="cb19-11"><a href="#cb19-11"></a>      requires invocable&lt;F&amp;&gt; &amp;&amp; output_range&lt;R, invoke_result_t&lt;F&amp;&gt;&gt;</span>
<span id="cb19-12"><a href="#cb19-12"></a>      constexpr borrowed_iterator_t&lt;R&gt; generate(R&amp;&amp; r, F gen);</span>
<span id="cb19-13"><a href="#cb19-13"></a></span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="st">-   template&lt;input_or_output_iterator O,</span></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="va">+   template&lt;class O,</span></span>
<span id="cb19-16"><a href="#cb19-16"></a>             copy_constructible F&gt;</span>
<span id="cb19-17"><a href="#cb19-17"></a>      requires invocable&lt;F&amp;&gt; &amp;&amp;</span>
<span id="cb19-18"><a href="#cb19-18"></a><span class="st">-              indirectly_writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="va">+              output_iterator&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb19-20"><a href="#cb19-20"></a>      constexpr O generate_n(O first, iter_difference_t&lt;O&gt; n, F gen);</span>
<span id="cb19-21"><a href="#cb19-21"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>And this is what it would look like if we weakened the range overload:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb20"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb20-1"><a href="#cb20-1"></a>namespace std::ranges {</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="st">-   template&lt;input_or_output_iterator O,</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="va">+   template&lt;class O,</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>             sentinel_for&lt;O&gt; S, copy_constructible F&gt;</span>
<span id="cb20-5"><a href="#cb20-5"></a>      requires invocable&lt;F&amp;&gt; &amp;&amp;</span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="st">-              indirectly_writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="va">+              weak_output_iterator&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>      constexpr O generate(O first, S last, F gen);</span>
<span id="cb20-9"><a href="#cb20-9"></a></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="st">-   template&lt;class R,</span></span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="va">+   template&lt;range R,</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>             copy_constructible F&gt;</span>
<span id="cb20-13"><a href="#cb20-13"></a>      requires invocable&lt;F&amp;&gt; &amp;&amp;</span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="st">-              output_range&lt;R, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="va">+              weak_output_iterator&lt;iterator_t&lt;R&gt;, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>      constexpr borrowed_iterator_t&lt;R&gt; generate(R&amp;&amp; r, F gen);</span>
<span id="cb20-17"><a href="#cb20-17"></a></span>
<span id="cb20-18"><a href="#cb20-18"></a><span class="st">-   template&lt;input_or_output_iterator O,</span></span>
<span id="cb20-19"><a href="#cb20-19"></a><span class="va">+   template&lt;class O,</span></span>
<span id="cb20-20"><a href="#cb20-20"></a>             copy_constructible F&gt;</span>
<span id="cb20-21"><a href="#cb20-21"></a>      requires invocable&lt;F&amp;&gt; &amp;&amp;</span>
<span id="cb20-22"><a href="#cb20-22"></a><span class="st">-              indirectly_writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb20-23"><a href="#cb20-23"></a><span class="va">+              weak_output_iterator&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;</span></span>
<span id="cb20-24"><a href="#cb20-24"></a>      constexpr O generate_n(O first, iter_difference_t&lt;O&gt; n, F gen);</span>
<span id="cb20-25"><a href="#cb20-25"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="2.1.9" id="rangesremove_copy"><span class="header-section-number">2.1.9</span> <code class="sourceCode cpp">ranges<span class="op">::</span>remove_copy</code><a href="#rangesremove_copy" class="self-link"></a></h3>
<blockquote>
<div>
<div class="sourceCode" id="cb21"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb21-1"><a href="#cb21-1"></a>namespace std::ranges {</span>
<span id="cb21-2"><a href="#cb21-2"></a>    template&lt;class I, class O&gt;</span>
<span id="cb21-3"><a href="#cb21-3"></a>      using remove_copy_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,</span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="st">-            weakly_incrementable O,</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="va">+            weak_output_iterator&lt;iter_reference_t&lt;I&gt;&gt; O,</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>             class T,</span>
<span id="cb21-9"><a href="#cb21-9"></a>             class Proj = identity&gt;</span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="st">-     requires indirectly_copyable&lt;I, O&gt; &amp;&amp;</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="va">+     requires</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>               indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;</span>
<span id="cb21-13"><a href="#cb21-13"></a>      constexpr remove_copy_result&lt;I, O&gt;</span>
<span id="cb21-14"><a href="#cb21-14"></a>        remove_copy(I first, S last, O result, const T&amp; value, Proj proj = {});</span>
<span id="cb21-15"><a href="#cb21-15"></a></span>
<span id="cb21-16"><a href="#cb21-16"></a>    template&lt;input_range R,</span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="st">-            weakly_incrementable O,</span></span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="va">+            weak_output_iterator&lt;range_reference_t&lt;R&gt;&gt; O,</span></span>
<span id="cb21-19"><a href="#cb21-19"></a>             class T, class Proj = identity&gt;</span>
<span id="cb21-20"><a href="#cb21-20"></a><span class="st">-     requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;</span></span>
<span id="cb21-21"><a href="#cb21-21"></a><span class="va">+     requires</span></span>
<span id="cb21-22"><a href="#cb21-22"></a>               indirect_binary_predicate&lt;ranges::equal_to,</span>
<span id="cb21-23"><a href="#cb21-23"></a>                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;</span>
<span id="cb21-24"><a href="#cb21-24"></a>      constexpr remove_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb21-25"><a href="#cb21-25"></a>        remove_copy(R&amp;&amp; r, O result, const T&amp; value, Proj proj = {});</span>
<span id="cb21-26"><a href="#cb21-26"></a></span>
<span id="cb21-27"><a href="#cb21-27"></a>    template&lt;class I, class O&gt;</span>
<span id="cb21-28"><a href="#cb21-28"></a>      using remove_copy_if_result = in_out_result&lt;I, O&gt;;</span>
<span id="cb21-29"><a href="#cb21-29"></a></span>
<span id="cb21-30"><a href="#cb21-30"></a>    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,</span>
<span id="cb21-31"><a href="#cb21-31"></a><span class="st">-            weakly_incrementable O,</span></span>
<span id="cb21-32"><a href="#cb21-32"></a><span class="va">+            weak_output_iterator&lt;iter_reference_t&lt;I&gt;&gt; O,</span></span>
<span id="cb21-33"><a href="#cb21-33"></a>             class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</span>
<span id="cb21-34"><a href="#cb21-34"></a><span class="st">-     requires indirectly_copyable&lt;I, O&gt;</span></span>
<span id="cb21-35"><a href="#cb21-35"></a>      constexpr remove_copy_if_result&lt;I, O&gt;</span>
<span id="cb21-36"><a href="#cb21-36"></a>        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});</span>
<span id="cb21-37"><a href="#cb21-37"></a></span>
<span id="cb21-38"><a href="#cb21-38"></a>    template&lt;input_range R,</span>
<span id="cb21-39"><a href="#cb21-39"></a><span class="st">-            weakly_incrementable O,</span></span>
<span id="cb21-40"><a href="#cb21-40"></a><span class="va">+            weak_output_iterator&lt;range_reference_t&lt;R&gt;&gt; O,</span></span>
<span id="cb21-41"><a href="#cb21-41"></a>             class Proj = identity,</span>
<span id="cb21-42"><a href="#cb21-42"></a>             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</span>
<span id="cb21-43"><a href="#cb21-43"></a><span class="st">-     requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span></span>
<span id="cb21-44"><a href="#cb21-44"></a>      constexpr remove_copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb21-45"><a href="#cb21-45"></a>        remove_copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});</span>
<span id="cb21-46"><a href="#cb21-46"></a>}</span></code></pre></div>
</div>
</blockquote>
</div>
</div>
</body>
</html>
